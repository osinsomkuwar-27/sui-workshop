{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _client, _contract, _network, _host, _path, _claimApi, _gasCoin, _hasSui, _ownedObjects, _ZkSendLink_instances, loadBagObject_fn, loadBag_fn, loadClaimedAssets_fn, createSponsoredTransaction_fn, executeSponsoredTransaction_fn, fetch_fn, listNonContractClaimableAssets_fn, createNonContractClaimTransaction_fn, loadOwnedObjects_fn;\nimport { bcs } from \"@mysten/sui/bcs\";\nimport { getFullnodeUrl, SuiClient } from \"@mysten/sui/client\";\nimport { Ed25519Keypair } from \"@mysten/sui/keypairs/ed25519\";\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { fromBase64, normalizeStructTag, normalizeSuiAddress, normalizeSuiObjectId, parseStructTag, SUI_TYPE_ARG, toBase64 } from \"@mysten/sui/utils\";\nimport { ZkSendLinkBuilder } from \"./builder.js\";\nimport { getAssetsFromTransaction, isOwner, ownedAfterChange } from \"./utils.js\";\nimport { getContractIds, ZkBag } from \"./zk-bag.js\";\nconst DEFAULT_ZK_SEND_LINK_OPTIONS = {\n  host: \"https://getstashed.com\",\n  path: \"/claim\",\n  network: \"mainnet\"\n};\nconst SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);\nconst SUI_COIN_OBJECT_TYPE = normalizeStructTag(\"0x2::coin::Coin<0x2::sui::SUI>\");\nconst _ZkSendLink = class _ZkSendLink {\n  constructor({\n    network = DEFAULT_ZK_SEND_LINK_OPTIONS.network,\n    client = new SuiClient({\n      url: getFullnodeUrl(network)\n    }),\n    keypair,\n    contract = getContractIds(network),\n    address,\n    host = DEFAULT_ZK_SEND_LINK_OPTIONS.host,\n    path = DEFAULT_ZK_SEND_LINK_OPTIONS.path,\n    claimApi = `${host}/api`,\n    isContractLink\n  }) {\n    __privateAdd(this, _ZkSendLink_instances);\n    __privateAdd(this, _client);\n    __privateAdd(this, _contract);\n    __privateAdd(this, _network);\n    __privateAdd(this, _host);\n    __privateAdd(this, _path);\n    __privateAdd(this, _claimApi);\n    // State for non-contract based links\n    __privateAdd(this, _gasCoin);\n    __privateAdd(this, _hasSui, false);\n    __privateAdd(this, _ownedObjects, []);\n    if (!keypair && !address) {\n      throw new Error(\"Either keypair or address must be provided\");\n    }\n    __privateSet(this, _client, client);\n    this.keypair = keypair;\n    this.address = address ?? keypair.toSuiAddress();\n    __privateSet(this, _claimApi, claimApi);\n    __privateSet(this, _network, network);\n    __privateSet(this, _host, host);\n    __privateSet(this, _path, path);\n    if (isContractLink) {\n      if (!contract) {\n        throw new Error(\"Contract options are required for contract based links\");\n      }\n      __privateSet(this, _contract, new ZkBag(contract.packageId, contract));\n    }\n  }\n  static async fromUrl(url, options = {}) {\n    const parsed = new URL(url);\n    const isContractLink = parsed.hash.startsWith(\"#$\");\n    const parsedNetwork = parsed.searchParams.get(\"network\") === \"testnet\" ? \"testnet\" : \"mainnet\";\n    const network = options.network ?? parsedNetwork;\n    let link;\n    if (isContractLink) {\n      const keypair = Ed25519Keypair.fromSecretKey(fromBase64(parsed.hash.slice(2)));\n      link = new _ZkSendLink({\n        ...options,\n        keypair,\n        network,\n        host: `${parsed.protocol}//${parsed.host}`,\n        path: parsed.pathname,\n        isContractLink: true\n      });\n    } else {\n      const keypair = Ed25519Keypair.fromSecretKey(fromBase64(isContractLink ? parsed.hash.slice(2) : parsed.hash.slice(1)));\n      link = new _ZkSendLink({\n        ...options,\n        keypair,\n        network,\n        host: `${parsed.protocol}//${parsed.host}`,\n        path: parsed.pathname,\n        isContractLink: false\n      });\n    }\n    await link.loadAssets();\n    return link;\n  }\n  static async fromAddress(address, options) {\n    const link = new _ZkSendLink({\n      ...options,\n      address,\n      isContractLink: true\n    });\n    await link.loadAssets();\n    return link;\n  }\n  async loadClaimedStatus() {\n    await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this, {\n      loadAssets: false\n    });\n  }\n  async loadAssets(options = {}) {\n    if (__privateGet(this, _contract)) {\n      await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this, options);\n    } else {\n      await __privateMethod(this, _ZkSendLink_instances, loadOwnedObjects_fn).call(this, options);\n    }\n  }\n  async claimAssets(address, {\n    reclaim,\n    sign\n  } = {}) {\n    if (!this.keypair && !sign) {\n      throw new Error(\"Cannot claim assets without links keypair\");\n    }\n    if (this.claimed) {\n      throw new Error(\"Assets have already been claimed\");\n    }\n    if (!this.assets) {\n      throw new Error(\"Link assets could not be loaded.  Link has not been indexed or has already been claimed\");\n    }\n    if (!__privateGet(this, _contract)) {\n      const bytes2 = await this.createClaimTransaction(address).build({\n        client: __privateGet(this, _client)\n      });\n      const signature2 = sign ? await sign(bytes2) : (await this.keypair.signTransaction(bytes2)).signature;\n      return __privateGet(this, _client).executeTransactionBlock({\n        transactionBlock: bytes2,\n        signature: signature2\n      });\n    }\n    if (!this.assets) {\n      await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this);\n    }\n    const tx = this.createClaimTransaction(address, {\n      reclaim\n    });\n    const sponsored = await __privateMethod(this, _ZkSendLink_instances, createSponsoredTransaction_fn).call(this, tx, address, reclaim ? address : this.keypair.toSuiAddress());\n    const bytes = fromBase64(sponsored.bytes);\n    const signature = sign ? await sign(bytes) : (await this.keypair.signTransaction(bytes)).signature;\n    const {\n      digest\n    } = await __privateMethod(this, _ZkSendLink_instances, executeSponsoredTransaction_fn).call(this, sponsored, signature);\n    const result = await __privateGet(this, _client).waitForTransaction({\n      digest,\n      options: {\n        showEffects: true\n      }\n    });\n    if (result.effects?.status.status !== \"success\") {\n      throw new Error(`Claim transaction failed: ${result.effects?.status.error ?? \"Unknown error\"}`);\n    }\n    return result;\n  }\n  createClaimTransaction(address, {\n    reclaim\n  } = {}) {\n    if (!__privateGet(this, _contract)) {\n      return __privateMethod(this, _ZkSendLink_instances, createNonContractClaimTransaction_fn).call(this, address);\n    }\n    if (!this.keypair && !reclaim) {\n      throw new Error(\"Cannot claim assets without the links keypair\");\n    }\n    const tx = new Transaction();\n    const sender = reclaim ? address : this.keypair.toSuiAddress();\n    tx.setSender(sender);\n    const store = tx.object(__privateGet(this, _contract).ids.bagStoreId);\n    const command = reclaim ? __privateGet(this, _contract).reclaim({\n      arguments: [store, this.address]\n    }) : __privateGet(this, _contract).init_claim({\n      arguments: [store]\n    });\n    const [bag, proof] = tx.add(command);\n    const objectsToTransfer = [];\n    const objects = [...(this.assets?.coins ?? []), ...(this.assets?.nfts ?? [])];\n    for (const object of objects) {\n      objectsToTransfer.push(__privateGet(this, _contract).claim({\n        arguments: [bag, proof, tx.receivingRef({\n          objectId: object.objectId,\n          version: object.version,\n          digest: object.digest\n        })],\n        typeArguments: [object.type]\n      }));\n    }\n    if (objectsToTransfer.length > 0) {\n      tx.transferObjects(objectsToTransfer, address);\n    }\n    tx.add(__privateGet(this, _contract).finalize({\n      arguments: [bag, proof]\n    }));\n    return tx;\n  }\n  async createRegenerateTransaction(sender, options = {}) {\n    if (!this.assets) {\n      await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this);\n    }\n    if (this.claimed) {\n      throw new Error(\"Assets have already been claimed\");\n    }\n    if (!__privateGet(this, _contract)) {\n      throw new Error(\"Regenerating non-contract based links is not supported\");\n    }\n    const tx = new Transaction();\n    tx.setSender(sender);\n    const store = tx.object(__privateGet(this, _contract).ids.bagStoreId);\n    const newLinkKp = Ed25519Keypair.generate();\n    const newLink = new ZkSendLinkBuilder({\n      ...options,\n      sender,\n      client: __privateGet(this, _client),\n      contract: __privateGet(this, _contract).ids,\n      host: __privateGet(this, _host),\n      path: __privateGet(this, _path),\n      keypair: newLinkKp\n    });\n    const to = tx.pure.address(newLinkKp.toSuiAddress());\n    tx.add(__privateGet(this, _contract).update_receiver({\n      arguments: [store, this.address, to]\n    }));\n    return {\n      url: newLink.getLink(),\n      transaction: tx\n    };\n  }\n};\n_client = new WeakMap();\n_contract = new WeakMap();\n_network = new WeakMap();\n_host = new WeakMap();\n_path = new WeakMap();\n_claimApi = new WeakMap();\n_gasCoin = new WeakMap();\n_hasSui = new WeakMap();\n_ownedObjects = new WeakMap();\n_ZkSendLink_instances = new WeakSet();\nloadBagObject_fn = async function () {\n  if (!__privateGet(this, _contract)) {\n    throw new Error(\"Cannot load bag object for non-contract based links\");\n  }\n  const bagField = await __privateGet(this, _client).getDynamicFieldObject({\n    parentId: __privateGet(this, _contract).ids.bagStoreTableId,\n    name: {\n      type: \"address\",\n      value: this.address\n    }\n  });\n  this.bagObject = bagField.data;\n  if (this.bagObject) {\n    this.claimed = false;\n  }\n};\nloadBag_fn = async function ({\n  transaction,\n  loadAssets = true,\n  loadClaimedAssets = loadAssets\n} = {}) {\n  if (!__privateGet(this, _contract)) {\n    return;\n  }\n  if (!this.bagObject || !this.claimed) {\n    await __privateMethod(this, _ZkSendLink_instances, loadBagObject_fn).call(this);\n  }\n  if (!loadAssets) {\n    return;\n  }\n  if (!this.bagObject) {\n    if (loadClaimedAssets) {\n      await __privateMethod(this, _ZkSendLink_instances, loadClaimedAssets_fn).call(this);\n    }\n    return;\n  }\n  const bagId = this.bagObject.content.fields.value.fields?.id?.id;\n  if (bagId && transaction?.balanceChanges && transaction.objectChanges) {\n    this.assets = getAssetsFromTransaction({\n      transaction,\n      address: bagId,\n      isSent: false\n    });\n    return;\n  }\n  const itemIds = this.bagObject?.content?.fields?.value?.fields?.item_ids.fields.contents;\n  this.creatorAddress = this.bagObject?.content?.fields?.value?.fields?.owner;\n  if (!itemIds) {\n    throw new Error(\"Invalid bag field\");\n  }\n  const objectsResponse = await __privateGet(this, _client).multiGetObjects({\n    ids: itemIds,\n    options: {\n      showType: true,\n      showContent: true\n    }\n  });\n  this.assets = {\n    balances: [],\n    nfts: [],\n    coins: []\n  };\n  const balances = /* @__PURE__ */new Map();\n  objectsResponse.forEach((object, i) => {\n    if (!object.data || !object.data.type) {\n      throw new Error(`Failed to load claimable object ${itemIds[i]}`);\n    }\n    const type = parseStructTag(normalizeStructTag(object.data.type));\n    if (type.address === normalizeSuiAddress(\"0x2\") && type.module === \"coin\" && type.name === \"Coin\") {\n      this.assets.coins.push({\n        objectId: object.data.objectId,\n        type: object.data.type,\n        version: object.data.version,\n        digest: object.data.digest\n      });\n      if (object.data.content?.dataType === \"moveObject\") {\n        const amount = BigInt(object.data.content.fields.balance);\n        const coinType = normalizeStructTag(parseStructTag(object.data.content.type).typeParams[0]);\n        if (!balances.has(coinType)) {\n          balances.set(coinType, {\n            coinType,\n            amount\n          });\n        } else {\n          balances.get(coinType).amount += amount;\n        }\n      }\n    } else {\n      this.assets.nfts.push({\n        objectId: object.data.objectId,\n        type: object.data.type,\n        version: object.data.version,\n        digest: object.data.digest\n      });\n    }\n  });\n  this.assets.balances = [...balances.values()];\n};\nloadClaimedAssets_fn = async function () {\n  const result = await __privateGet(this, _client).queryTransactionBlocks({\n    limit: 1,\n    filter: {\n      FromAddress: this.address\n    },\n    options: {\n      showObjectChanges: true,\n      showBalanceChanges: true,\n      showInput: true\n    }\n  });\n  if (!result?.data[0]) {\n    return;\n  }\n  const [tx] = result.data;\n  if (tx.transaction?.data.transaction.kind !== \"ProgrammableTransaction\") {\n    return;\n  }\n  const transfer = tx.transaction.data.transaction.transactions.findLast(tx2 => \"TransferObjects\" in tx2);\n  if (!transfer) {\n    return;\n  }\n  const receiverArg = transfer.TransferObjects[1];\n  if (!(typeof receiverArg === \"object\" && \"Input\" in receiverArg)) {\n    return;\n  }\n  const input = tx.transaction.data.transaction.inputs[receiverArg.Input];\n  if (input.type !== \"pure\") {\n    return;\n  }\n  const receiver = typeof input.value === \"string\" ? input.value : bcs.Address.parse(new Uint8Array(input.value.Pure));\n  this.claimed = true;\n  this.claimedBy = receiver;\n  this.assets = getAssetsFromTransaction({\n    transaction: tx,\n    address: receiver,\n    isSent: false\n  });\n};\ncreateSponsoredTransaction_fn = async function (tx, claimer, sender) {\n  return __privateMethod(this, _ZkSendLink_instances, fetch_fn).call(this, \"transaction-blocks/sponsor\", {\n    method: \"POST\",\n    body: JSON.stringify({\n      network: __privateGet(this, _network),\n      sender,\n      claimer,\n      transactionBlockKindBytes: toBase64(await tx.build({\n        onlyTransactionKind: true,\n        client: __privateGet(this, _client)\n      }))\n    })\n  });\n};\nexecuteSponsoredTransaction_fn = async function (input, signature) {\n  return __privateMethod(this, _ZkSendLink_instances, fetch_fn).call(this, `transaction-blocks/sponsor/${input.digest}`, {\n    method: \"POST\",\n    body: JSON.stringify({\n      signature\n    })\n  });\n};\nfetch_fn = async function (path, init) {\n  const res = await fetch(`${__privateGet(this, _claimApi)}/v1/${path}`, {\n    ...init,\n    headers: {\n      ...init.headers,\n      \"Content-Type\": \"application/json\"\n    }\n  });\n  if (!res.ok) {\n    console.error(path, await res.text());\n    throw new Error(`Request to claim API failed with status code ${res.status}`);\n  }\n  const {\n    data\n  } = await res.json();\n  return data;\n};\nlistNonContractClaimableAssets_fn = async function () {\n  const balances = [];\n  const nfts = [];\n  const coins = [];\n  if (__privateGet(this, _ownedObjects).length === 0 && !__privateGet(this, _hasSui)) {\n    return {\n      balances,\n      nfts,\n      coins\n    };\n  }\n  const address = new Ed25519Keypair().toSuiAddress();\n  const normalizedAddress = normalizeSuiAddress(address);\n  const tx = this.createClaimTransaction(normalizedAddress);\n  if (__privateGet(this, _gasCoin) || !__privateGet(this, _hasSui)) {\n    tx.setGasPayment([]);\n  }\n  const dryRun = await __privateGet(this, _client).dryRunTransactionBlock({\n    transactionBlock: await tx.build({\n      client: __privateGet(this, _client)\n    })\n  });\n  dryRun.balanceChanges.forEach(balanceChange => {\n    if (BigInt(balanceChange.amount) > 0n && isOwner(balanceChange.owner, normalizedAddress)) {\n      balances.push({\n        coinType: normalizeStructTag(balanceChange.coinType),\n        amount: BigInt(balanceChange.amount)\n      });\n    }\n  });\n  dryRun.objectChanges.forEach(objectChange => {\n    if (\"objectType\" in objectChange) {\n      const type = parseStructTag(objectChange.objectType);\n      if (type.address === normalizeSuiAddress(\"0x2\") && type.module === \"coin\" && type.name === \"Coin\") {\n        if (ownedAfterChange(objectChange, normalizedAddress)) {\n          coins.push(objectChange);\n        }\n        return;\n      }\n    }\n    if (ownedAfterChange(objectChange, normalizedAddress)) {\n      nfts.push(objectChange);\n    }\n  });\n  return {\n    balances,\n    nfts,\n    coins\n  };\n};\ncreateNonContractClaimTransaction_fn = function (address) {\n  if (!this.keypair) {\n    throw new Error(\"Cannot claim assets without the links keypair\");\n  }\n  const tx = new Transaction();\n  tx.setSender(this.keypair.toSuiAddress());\n  const objectsToTransfer = __privateGet(this, _ownedObjects).filter(object => {\n    if (__privateGet(this, _gasCoin)) {\n      if (object.objectId === __privateGet(this, _gasCoin).coinObjectId) {\n        return false;\n      }\n    } else if (object.type === SUI_COIN_OBJECT_TYPE) {\n      return false;\n    }\n    return true;\n  }).map(object => tx.object(object.objectId));\n  if (__privateGet(this, _gasCoin) && this.creatorAddress) {\n    tx.transferObjects([tx.gas], this.creatorAddress);\n  } else {\n    objectsToTransfer.push(tx.gas);\n  }\n  if (objectsToTransfer.length > 0) {\n    tx.transferObjects(objectsToTransfer, address);\n  }\n  return tx;\n};\nloadOwnedObjects_fn = async function ({\n  loadClaimedAssets = true\n} = {}) {\n  this.assets = {\n    nfts: [],\n    balances: [],\n    coins: []\n  };\n  let nextCursor;\n  do {\n    const ownedObjects = await __privateGet(this, _client).getOwnedObjects({\n      cursor: nextCursor,\n      owner: this.address,\n      options: {\n        showType: true,\n        showContent: true\n      }\n    });\n    nextCursor = ownedObjects.hasNextPage ? ownedObjects.nextCursor : null;\n    for (const object of ownedObjects.data) {\n      if (object.data) {\n        __privateGet(this, _ownedObjects).push({\n          objectId: normalizeSuiObjectId(object.data.objectId),\n          version: object.data.version,\n          digest: object.data.digest,\n          type: normalizeStructTag(object.data.type)\n        });\n      }\n    }\n  } while (nextCursor);\n  const coins = await __privateGet(this, _client).getCoins({\n    coinType: SUI_COIN_TYPE,\n    owner: this.address\n  });\n  __privateSet(this, _hasSui, coins.data.length > 0);\n  __privateSet(this, _gasCoin, coins.data.find(coin => BigInt(coin.balance) % 1000n === 987n));\n  const result = await __privateGet(this, _client).queryTransactionBlocks({\n    limit: 1,\n    order: \"ascending\",\n    filter: {\n      ToAddress: this.address\n    },\n    options: {\n      showInput: true,\n      showBalanceChanges: true,\n      showObjectChanges: true\n    }\n  });\n  this.creatorAddress = result.data[0]?.transaction?.data.sender;\n  if (__privateGet(this, _hasSui) || __privateGet(this, _ownedObjects).length > 0) {\n    this.claimed = false;\n    this.assets = await __privateMethod(this, _ZkSendLink_instances, listNonContractClaimableAssets_fn).call(this);\n  } else if (result.data[0] && loadClaimedAssets) {\n    this.claimed = true;\n    await __privateMethod(this, _ZkSendLink_instances, loadClaimedAssets_fn).call(this);\n  }\n};\nlet ZkSendLink = _ZkSendLink;\nexport { ZkSendLink };","map":{"version":3,"names":["_client","_contract","_network","_host","_path","_claimApi","_gasCoin","_hasSui","_ownedObjects","_ZkSendLink_instances","loadBagObject_fn","loadBag_fn","loadClaimedAssets_fn","createSponsoredTransaction_fn","executeSponsoredTransaction_fn","fetch_fn","listNonContractClaimableAssets_fn","createNonContractClaimTransaction_fn","loadOwnedObjects_fn","bcs","getFullnodeUrl","SuiClient","Ed25519Keypair","Transaction","fromBase64","normalizeStructTag","normalizeSuiAddress","normalizeSuiObjectId","parseStructTag","SUI_TYPE_ARG","toBase64","ZkSendLinkBuilder","getAssetsFromTransaction","isOwner","ownedAfterChange","getContractIds","ZkBag","DEFAULT_ZK_SEND_LINK_OPTIONS","host","path","network","SUI_COIN_TYPE","SUI_COIN_OBJECT_TYPE","_ZkSendLink","constructor","client","url","keypair","contract","address","claimApi","isContractLink","__privateAdd","Error","__privateSet","toSuiAddress","packageId","fromUrl","options","parsed","URL","hash","startsWith","parsedNetwork","searchParams","get","link","fromSecretKey","slice","protocol","pathname","loadAssets","fromAddress","loadClaimedStatus","__privateMethod","call","__privateGet","claimAssets","reclaim","sign","claimed","assets","bytes2","createClaimTransaction","build","signature2","signTransaction","signature","executeTransactionBlock","transactionBlock","tx","sponsored","bytes","digest","result","waitForTransaction","showEffects","effects","status","error","sender","setSender","store","object","ids","bagStoreId","command","arguments","init_claim","bag","proof","add","objectsToTransfer","objects","coins","nfts","push","claim","receivingRef","objectId","version","typeArguments","type","length","transferObjects","finalize","createRegenerateTransaction","newLinkKp","generate","newLink","to","pure","update_receiver","getLink","transaction","WeakMap","WeakSet","bagField","getDynamicFieldObject","parentId","bagStoreTableId","name","value","bagObject","data","loadClaimedAssets","bagId","content","fields","id","balanceChanges","objectChanges","isSent","itemIds","item_ids","contents","creatorAddress","owner","objectsResponse","multiGetObjects","showType","showContent","balances","Map","forEach","i","module","dataType","amount","BigInt","balance","coinType","typeParams","has","set","values","queryTransactionBlocks","limit","filter","FromAddress","showObjectChanges","showBalanceChanges","showInput","kind","transfer","transactions","findLast","tx2","receiverArg","TransferObjects","input","inputs","Input","receiver","Address","parse","Uint8Array","Pure","claimedBy","claimer","method","body","JSON","stringify","transactionBlockKindBytes","onlyTransactionKind","init","res","fetch","headers","ok","console","text","json","normalizedAddress","setGasPayment","dryRun","dryRunTransactionBlock","balanceChange","objectChange","objectType","coinObjectId","map","gas","nextCursor","ownedObjects","getOwnedObjects","cursor","hasNextPage","getCoins","find","coin","order","ToAddress","ZkSendLink"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\zksend\\src\\links\\claim.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/sui/bcs';\nimport { getFullnodeUrl, SuiClient } from '@mysten/sui/client';\nimport type {\n\tCoinStruct,\n\tSuiObjectData,\n\tSuiTransaction,\n\tSuiTransactionBlockResponse,\n} from '@mysten/sui/client';\nimport type { Keypair } from '@mysten/sui/cryptography';\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\nimport type { TransactionObjectArgument } from '@mysten/sui/transactions';\nimport { Transaction } from '@mysten/sui/transactions';\nimport {\n\tfromBase64,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n\tparseStructTag,\n\tSUI_TYPE_ARG,\n\ttoBase64,\n} from '@mysten/sui/utils';\n\nimport type { ZkSendLinkBuilderOptions } from './builder.js';\nimport { ZkSendLinkBuilder } from './builder.js';\nimport type { LinkAssets } from './utils.js';\nimport { getAssetsFromTransaction, isOwner, ownedAfterChange } from './utils.js';\nimport type { ZkBagContractOptions } from './zk-bag.js';\nimport { getContractIds, ZkBag } from './zk-bag.js';\n\nconst DEFAULT_ZK_SEND_LINK_OPTIONS = {\n\thost: 'https://getstashed.com',\n\tpath: '/claim',\n\tnetwork: 'mainnet' as const,\n};\n\nconst SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);\nconst SUI_COIN_OBJECT_TYPE = normalizeStructTag('0x2::coin::Coin<0x2::sui::SUI>');\n\nexport type ZkSendLinkOptions = {\n\tclaimApi?: string;\n\tkeypair?: Keypair;\n\tclient?: SuiClient;\n\tnetwork?: 'mainnet' | 'testnet';\n\thost?: string;\n\tpath?: string;\n\taddress?: string;\n\tisContractLink: boolean;\n\tcontract?: ZkBagContractOptions | null;\n} & (\n\t| {\n\t\t\taddress: string;\n\t\t\tkeypair?: never;\n\t  }\n\t| {\n\t\t\tkeypair: Keypair;\n\t\t\taddress?: never;\n\t  }\n);\n\nexport class ZkSendLink {\n\taddress: string;\n\tkeypair?: Keypair;\n\tcreatorAddress?: string;\n\tassets?: LinkAssets;\n\tclaimed?: boolean;\n\tclaimedBy?: string;\n\tbagObject?: SuiObjectData | null;\n\n\t#client: SuiClient;\n\t#contract?: ZkBag<ZkBagContractOptions>;\n\t#network: 'mainnet' | 'testnet';\n\t#host: string;\n\t#path: string;\n\t#claimApi: string;\n\n\t// State for non-contract based links\n\t#gasCoin?: CoinStruct;\n\t#hasSui = false;\n\t#ownedObjects: {\n\t\tobjectId: string;\n\t\tversion: string;\n\t\tdigest: string;\n\t\ttype: string;\n\t}[] = [];\n\n\tconstructor({\n\t\tnetwork = DEFAULT_ZK_SEND_LINK_OPTIONS.network,\n\t\tclient = new SuiClient({ url: getFullnodeUrl(network) }),\n\t\tkeypair,\n\t\tcontract = getContractIds(network),\n\t\taddress,\n\t\thost = DEFAULT_ZK_SEND_LINK_OPTIONS.host,\n\t\tpath = DEFAULT_ZK_SEND_LINK_OPTIONS.path,\n\t\tclaimApi = `${host}/api`,\n\t\tisContractLink,\n\t}: ZkSendLinkOptions) {\n\t\tif (!keypair && !address) {\n\t\t\tthrow new Error('Either keypair or address must be provided');\n\t\t}\n\n\t\tthis.#client = client;\n\t\tthis.keypair = keypair;\n\t\tthis.address = address ?? keypair!.toSuiAddress();\n\t\tthis.#claimApi = claimApi;\n\t\tthis.#network = network;\n\t\tthis.#host = host;\n\t\tthis.#path = path;\n\n\t\tif (isContractLink) {\n\t\t\tif (!contract) {\n\t\t\t\tthrow new Error('Contract options are required for contract based links');\n\t\t\t}\n\n\t\t\tthis.#contract = new ZkBag(contract.packageId, contract);\n\t\t}\n\t}\n\n\tstatic async fromUrl(\n\t\turl: string,\n\t\toptions: Omit<ZkSendLinkOptions, 'keypair' | 'address' | 'isContractLink'> = {},\n\t) {\n\t\tconst parsed = new URL(url);\n\t\tconst isContractLink = parsed.hash.startsWith('#$');\n\t\tconst parsedNetwork = parsed.searchParams.get('network') === 'testnet' ? 'testnet' : 'mainnet';\n\t\tconst network = options.network ?? parsedNetwork;\n\n\t\tlet link: ZkSendLink;\n\t\tif (isContractLink) {\n\t\t\tconst keypair = Ed25519Keypair.fromSecretKey(fromBase64(parsed.hash.slice(2)));\n\t\t\tlink = new ZkSendLink({\n\t\t\t\t...options,\n\t\t\t\tkeypair,\n\t\t\t\tnetwork,\n\t\t\t\thost: `${parsed.protocol}//${parsed.host}`,\n\t\t\t\tpath: parsed.pathname,\n\t\t\t\tisContractLink: true,\n\t\t\t});\n\t\t} else {\n\t\t\tconst keypair = Ed25519Keypair.fromSecretKey(\n\t\t\t\tfromBase64(isContractLink ? parsed.hash.slice(2) : parsed.hash.slice(1)),\n\t\t\t);\n\t\t\tlink = new ZkSendLink({\n\t\t\t\t...options,\n\t\t\t\tkeypair,\n\t\t\t\tnetwork,\n\t\t\t\thost: `${parsed.protocol}//${parsed.host}`,\n\t\t\t\tpath: parsed.pathname,\n\t\t\t\tisContractLink: false,\n\t\t\t});\n\t\t}\n\n\t\tawait link.loadAssets();\n\n\t\treturn link;\n\t}\n\n\tstatic async fromAddress(\n\t\taddress: string,\n\t\toptions: Omit<ZkSendLinkOptions, 'keypair' | 'address' | 'isContractLink'>,\n\t) {\n\t\tconst link = new ZkSendLink({\n\t\t\t...options,\n\t\t\taddress,\n\t\t\tisContractLink: true,\n\t\t});\n\n\t\tawait link.loadAssets();\n\n\t\treturn link;\n\t}\n\n\tasync loadClaimedStatus() {\n\t\tawait this.#loadBag({ loadAssets: false });\n\t}\n\n\tasync loadAssets(\n\t\toptions: {\n\t\t\ttransaction?: SuiTransactionBlockResponse;\n\t\t\tloadClaimedAssets?: boolean;\n\t\t} = {},\n\t) {\n\t\tif (this.#contract) {\n\t\t\tawait this.#loadBag(options);\n\t\t} else {\n\t\t\tawait this.#loadOwnedObjects(options);\n\t\t}\n\t}\n\n\tasync claimAssets(\n\t\taddress: string,\n\t\t{\n\t\t\treclaim,\n\t\t\tsign,\n\t\t}:\n\t\t\t| { reclaim?: false; sign?: never }\n\t\t\t| {\n\t\t\t\t\treclaim: true;\n\t\t\t\t\tsign: (transaction: Uint8Array) => Promise<string>;\n\t\t\t  } = {},\n\t) {\n\t\tif (!this.keypair && !sign) {\n\t\t\tthrow new Error('Cannot claim assets without links keypair');\n\t\t}\n\n\t\tif (this.claimed) {\n\t\t\tthrow new Error('Assets have already been claimed');\n\t\t}\n\n\t\tif (!this.assets) {\n\t\t\tthrow new Error(\n\t\t\t\t'Link assets could not be loaded.  Link has not been indexed or has already been claimed',\n\t\t\t);\n\t\t}\n\n\t\tif (!this.#contract) {\n\t\t\tconst bytes = await this.createClaimTransaction(address).build({\n\t\t\t\tclient: this.#client,\n\t\t\t});\n\t\t\tconst signature = sign\n\t\t\t\t? await sign(bytes)\n\t\t\t\t: (await this.keypair!.signTransaction(bytes)).signature;\n\n\t\t\treturn this.#client.executeTransactionBlock({\n\t\t\t\ttransactionBlock: bytes,\n\t\t\t\tsignature,\n\t\t\t});\n\t\t}\n\n\t\tif (!this.assets) {\n\t\t\tawait this.#loadBag();\n\t\t}\n\n\t\tconst tx = this.createClaimTransaction(address, { reclaim });\n\n\t\tconst sponsored = await this.#createSponsoredTransaction(\n\t\t\ttx,\n\t\t\taddress,\n\t\t\treclaim ? address : this.keypair!.toSuiAddress(),\n\t\t);\n\n\t\tconst bytes = fromBase64(sponsored.bytes);\n\t\tconst signature = sign\n\t\t\t? await sign(bytes)\n\t\t\t: (await this.keypair!.signTransaction(bytes)).signature;\n\n\t\tconst { digest } = await this.#executeSponsoredTransaction(sponsored, signature);\n\n\t\tconst result = await this.#client.waitForTransaction({\n\t\t\tdigest,\n\t\t\toptions: { showEffects: true },\n\t\t});\n\n\t\tif (result.effects?.status.status !== 'success') {\n\t\t\tthrow new Error(\n\t\t\t\t`Claim transaction failed: ${result.effects?.status.error ?? 'Unknown error'}`,\n\t\t\t);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tcreateClaimTransaction(\n\t\taddress: string,\n\t\t{\n\t\t\treclaim,\n\t\t}: {\n\t\t\treclaim?: boolean;\n\t\t} = {},\n\t) {\n\t\tif (!this.#contract) {\n\t\t\treturn this.#createNonContractClaimTransaction(address);\n\t\t}\n\n\t\tif (!this.keypair && !reclaim) {\n\t\t\tthrow new Error('Cannot claim assets without the links keypair');\n\t\t}\n\n\t\tconst tx = new Transaction();\n\t\tconst sender = reclaim ? address : this.keypair!.toSuiAddress();\n\t\ttx.setSender(sender);\n\n\t\tconst store = tx.object(this.#contract.ids.bagStoreId);\n\t\tconst command = reclaim\n\t\t\t? this.#contract.reclaim({ arguments: [store, this.address] })\n\t\t\t: this.#contract.init_claim({ arguments: [store] });\n\n\t\tconst [bag, proof] = tx.add(command);\n\n\t\tconst objectsToTransfer: TransactionObjectArgument[] = [];\n\n\t\tconst objects = [...(this.assets?.coins ?? []), ...(this.assets?.nfts ?? [])];\n\n\t\tfor (const object of objects) {\n\t\t\tobjectsToTransfer.push(\n\t\t\t\tthis.#contract.claim({\n\t\t\t\t\targuments: [\n\t\t\t\t\t\tbag,\n\t\t\t\t\t\tproof,\n\t\t\t\t\t\ttx.receivingRef({\n\t\t\t\t\t\t\tobjectId: object.objectId,\n\t\t\t\t\t\t\tversion: object.version,\n\t\t\t\t\t\t\tdigest: object.digest,\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\ttypeArguments: [object.type],\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToTransfer.length > 0) {\n\t\t\ttx.transferObjects(objectsToTransfer, address);\n\t\t}\n\n\t\ttx.add(this.#contract.finalize({ arguments: [bag, proof] }));\n\n\t\treturn tx;\n\t}\n\n\tasync createRegenerateTransaction(\n\t\tsender: string,\n\t\toptions: Omit<ZkSendLinkBuilderOptions, 'sender'> = {},\n\t) {\n\t\tif (!this.assets) {\n\t\t\tawait this.#loadBag();\n\t\t}\n\n\t\tif (this.claimed) {\n\t\t\tthrow new Error('Assets have already been claimed');\n\t\t}\n\n\t\tif (!this.#contract) {\n\t\t\tthrow new Error('Regenerating non-contract based links is not supported');\n\t\t}\n\n\t\tconst tx = new Transaction();\n\t\ttx.setSender(sender);\n\n\t\tconst store = tx.object(this.#contract.ids.bagStoreId);\n\n\t\tconst newLinkKp = Ed25519Keypair.generate();\n\n\t\tconst newLink = new ZkSendLinkBuilder({\n\t\t\t...options,\n\t\t\tsender,\n\t\t\tclient: this.#client,\n\t\t\tcontract: this.#contract.ids,\n\t\t\thost: this.#host,\n\t\t\tpath: this.#path,\n\t\t\tkeypair: newLinkKp,\n\t\t});\n\n\t\tconst to = tx.pure.address(newLinkKp.toSuiAddress());\n\n\t\ttx.add(this.#contract.update_receiver({ arguments: [store, this.address, to] }));\n\n\t\treturn {\n\t\t\turl: newLink.getLink(),\n\t\t\ttransaction: tx,\n\t\t};\n\t}\n\n\tasync #loadBagObject() {\n\t\tif (!this.#contract) {\n\t\t\tthrow new Error('Cannot load bag object for non-contract based links');\n\t\t}\n\t\tconst bagField = await this.#client.getDynamicFieldObject({\n\t\t\tparentId: this.#contract.ids.bagStoreTableId,\n\t\t\tname: {\n\t\t\t\ttype: 'address',\n\t\t\t\tvalue: this.address,\n\t\t\t},\n\t\t});\n\n\t\tthis.bagObject = bagField.data;\n\n\t\tif (this.bagObject) {\n\t\t\tthis.claimed = false;\n\t\t}\n\t}\n\n\tasync #loadBag({\n\t\ttransaction,\n\t\tloadAssets = true,\n\t\tloadClaimedAssets = loadAssets,\n\t}: {\n\t\ttransaction?: SuiTransactionBlockResponse;\n\t\tloadAssets?: boolean;\n\t\tloadClaimedAssets?: boolean;\n\t} = {}) {\n\t\tif (!this.#contract) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.bagObject || !this.claimed) {\n\t\t\tawait this.#loadBagObject();\n\t\t}\n\n\t\tif (!loadAssets) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.bagObject) {\n\t\t\tif (loadClaimedAssets) {\n\t\t\t\tawait this.#loadClaimedAssets();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst bagId = (this.bagObject as any).content.fields.value.fields?.id?.id;\n\n\t\tif (bagId && transaction?.balanceChanges && transaction.objectChanges) {\n\t\t\tthis.assets = getAssetsFromTransaction({\n\t\t\t\ttransaction,\n\t\t\t\taddress: bagId,\n\t\t\t\tisSent: false,\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst itemIds: string[] | undefined = (this.bagObject as any)?.content?.fields?.value?.fields\n\t\t\t?.item_ids.fields.contents;\n\n\t\tthis.creatorAddress = (this.bagObject as any)?.content?.fields?.value?.fields?.owner;\n\n\t\tif (!itemIds) {\n\t\t\tthrow new Error('Invalid bag field');\n\t\t}\n\n\t\tconst objectsResponse = await this.#client.multiGetObjects({\n\t\t\tids: itemIds,\n\t\t\toptions: {\n\t\t\t\tshowType: true,\n\t\t\t\tshowContent: true,\n\t\t\t},\n\t\t});\n\n\t\tthis.assets = {\n\t\t\tbalances: [],\n\t\t\tnfts: [],\n\t\t\tcoins: [],\n\t\t};\n\n\t\tconst balances = new Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tcoinType: string;\n\t\t\t\tamount: bigint;\n\t\t\t}\n\t\t>();\n\n\t\tobjectsResponse.forEach((object, i) => {\n\t\t\tif (!object.data || !object.data.type) {\n\t\t\t\tthrow new Error(`Failed to load claimable object ${itemIds[i]}`);\n\t\t\t}\n\n\t\t\tconst type = parseStructTag(normalizeStructTag(object.data.type));\n\n\t\t\tif (\n\t\t\t\ttype.address === normalizeSuiAddress('0x2') &&\n\t\t\t\ttype.module === 'coin' &&\n\t\t\t\ttype.name === 'Coin'\n\t\t\t) {\n\t\t\t\tthis.assets!.coins.push({\n\t\t\t\t\tobjectId: object.data.objectId,\n\t\t\t\t\ttype: object.data.type,\n\t\t\t\t\tversion: object.data.version,\n\t\t\t\t\tdigest: object.data.digest,\n\t\t\t\t});\n\n\t\t\t\tif (object.data.content?.dataType === 'moveObject') {\n\t\t\t\t\tconst amount = BigInt((object.data.content.fields as Record<string, string>).balance);\n\t\t\t\t\tconst coinType = normalizeStructTag(\n\t\t\t\t\t\tparseStructTag(object.data.content.type).typeParams[0],\n\t\t\t\t\t);\n\t\t\t\t\tif (!balances.has(coinType)) {\n\t\t\t\t\t\tbalances.set(coinType, { coinType, amount });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbalances.get(coinType)!.amount += amount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.assets!.nfts.push({\n\t\t\t\t\tobjectId: object.data.objectId,\n\t\t\t\t\ttype: object.data.type,\n\t\t\t\t\tversion: object.data.version,\n\t\t\t\t\tdigest: object.data.digest,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tthis.assets.balances = [...balances.values()];\n\t}\n\n\tasync #loadClaimedAssets() {\n\t\tconst result = await this.#client.queryTransactionBlocks({\n\t\t\tlimit: 1,\n\t\t\tfilter: {\n\t\t\t\tFromAddress: this.address,\n\t\t\t},\n\t\t\toptions: {\n\t\t\t\tshowObjectChanges: true,\n\t\t\t\tshowBalanceChanges: true,\n\t\t\t\tshowInput: true,\n\t\t\t},\n\t\t});\n\n\t\tif (!result?.data[0]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [tx] = result.data;\n\n\t\tif (tx.transaction?.data.transaction.kind !== 'ProgrammableTransaction') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst transfer = tx.transaction.data.transaction.transactions.findLast(\n\t\t\t(tx): tx is Extract<SuiTransaction, { TransferObjects: unknown }> => 'TransferObjects' in tx,\n\t\t);\n\n\t\tif (!transfer) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst receiverArg = transfer.TransferObjects[1];\n\n\t\tif (!(typeof receiverArg === 'object' && 'Input' in receiverArg)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst input = tx.transaction.data.transaction.inputs[receiverArg.Input];\n\n\t\tif (input.type !== 'pure') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst receiver =\n\t\t\ttypeof input.value === 'string'\n\t\t\t\t? input.value\n\t\t\t\t: bcs.Address.parse(new Uint8Array((input.value as { Pure: number[] }).Pure));\n\n\t\tthis.claimed = true;\n\t\tthis.claimedBy = receiver;\n\t\tthis.assets = getAssetsFromTransaction({\n\t\t\ttransaction: tx,\n\t\t\taddress: receiver,\n\t\t\tisSent: false,\n\t\t});\n\t}\n\n\tasync #createSponsoredTransaction(tx: Transaction, claimer: string, sender: string) {\n\t\treturn this.#fetch<{ digest: string; bytes: string }>('transaction-blocks/sponsor', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({\n\t\t\t\tnetwork: this.#network,\n\t\t\t\tsender,\n\t\t\t\tclaimer,\n\t\t\t\ttransactionBlockKindBytes: toBase64(\n\t\t\t\t\tawait tx.build({\n\t\t\t\t\t\tonlyTransactionKind: true,\n\t\t\t\t\t\tclient: this.#client,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t});\n\t}\n\n\tasync #executeSponsoredTransaction(input: { digest: string; bytes: string }, signature: string) {\n\t\treturn this.#fetch<{ digest: string }>(`transaction-blocks/sponsor/${input.digest}`, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({\n\t\t\t\tsignature,\n\t\t\t}),\n\t\t});\n\t}\n\n\tasync #fetch<T = unknown>(path: string, init: RequestInit): Promise<T> {\n\t\tconst res = await fetch(`${this.#claimApi}/v1/${path}`, {\n\t\t\t...init,\n\t\t\theaders: {\n\t\t\t\t...init.headers,\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t});\n\n\t\tif (!res.ok) {\n\t\t\tconsole.error(path, await res.text());\n\t\t\tthrow new Error(`Request to claim API failed with status code ${res.status}`);\n\t\t}\n\n\t\tconst { data } = await res.json();\n\n\t\treturn data as T;\n\t}\n\n\tasync #listNonContractClaimableAssets() {\n\t\tconst balances: {\n\t\t\tcoinType: string;\n\t\t\tamount: bigint;\n\t\t}[] = [];\n\n\t\tconst nfts: {\n\t\t\tobjectId: string;\n\t\t\ttype: string;\n\t\t\tversion: string;\n\t\t\tdigest: string;\n\t\t}[] = [];\n\n\t\tconst coins: {\n\t\t\tobjectId: string;\n\t\t\ttype: string;\n\t\t\tversion: string;\n\t\t\tdigest: string;\n\t\t}[] = [];\n\n\t\tif (this.#ownedObjects.length === 0 && !this.#hasSui) {\n\t\t\treturn {\n\t\t\t\tbalances,\n\t\t\t\tnfts,\n\t\t\t\tcoins,\n\t\t\t};\n\t\t}\n\n\t\tconst address = new Ed25519Keypair().toSuiAddress();\n\t\tconst normalizedAddress = normalizeSuiAddress(address);\n\n\t\tconst tx = this.createClaimTransaction(normalizedAddress);\n\n\t\tif (this.#gasCoin || !this.#hasSui) {\n\t\t\ttx.setGasPayment([]);\n\t\t}\n\n\t\tconst dryRun = await this.#client.dryRunTransactionBlock({\n\t\t\ttransactionBlock: await tx.build({ client: this.#client }),\n\t\t});\n\n\t\tdryRun.balanceChanges.forEach((balanceChange) => {\n\t\t\tif (BigInt(balanceChange.amount) > 0n && isOwner(balanceChange.owner, normalizedAddress)) {\n\t\t\t\tbalances.push({\n\t\t\t\t\tcoinType: normalizeStructTag(balanceChange.coinType),\n\t\t\t\t\tamount: BigInt(balanceChange.amount),\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tdryRun.objectChanges.forEach((objectChange) => {\n\t\t\tif ('objectType' in objectChange) {\n\t\t\t\tconst type = parseStructTag(objectChange.objectType);\n\n\t\t\t\tif (\n\t\t\t\t\ttype.address === normalizeSuiAddress('0x2') &&\n\t\t\t\t\ttype.module === 'coin' &&\n\t\t\t\t\ttype.name === 'Coin'\n\t\t\t\t) {\n\t\t\t\t\tif (ownedAfterChange(objectChange, normalizedAddress)) {\n\t\t\t\t\t\tcoins.push(objectChange);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ownedAfterChange(objectChange, normalizedAddress)) {\n\t\t\t\tnfts.push(objectChange);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tbalances,\n\t\t\tnfts,\n\t\t\tcoins,\n\t\t};\n\t}\n\n\t#createNonContractClaimTransaction(address: string) {\n\t\tif (!this.keypair) {\n\t\t\tthrow new Error('Cannot claim assets without the links keypair');\n\t\t}\n\n\t\tconst tx = new Transaction();\n\t\ttx.setSender(this.keypair.toSuiAddress());\n\n\t\tconst objectsToTransfer: TransactionObjectArgument[] = this.#ownedObjects\n\t\t\t.filter((object) => {\n\t\t\t\tif (this.#gasCoin) {\n\t\t\t\t\tif (object.objectId === this.#gasCoin.coinObjectId) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (object.type === SUI_COIN_OBJECT_TYPE) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t})\n\t\t\t.map((object) => tx.object(object.objectId));\n\n\t\tif (this.#gasCoin && this.creatorAddress) {\n\t\t\ttx.transferObjects([tx.gas], this.creatorAddress);\n\t\t} else {\n\t\t\tobjectsToTransfer.push(tx.gas);\n\t\t}\n\n\t\tif (objectsToTransfer.length > 0) {\n\t\t\ttx.transferObjects(objectsToTransfer, address);\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\tasync #loadOwnedObjects({\n\t\tloadClaimedAssets = true,\n\t}: {\n\t\tloadClaimedAssets?: boolean;\n\t} = {}) {\n\t\tthis.assets = {\n\t\t\tnfts: [],\n\t\t\tbalances: [],\n\t\t\tcoins: [],\n\t\t};\n\n\t\tlet nextCursor: string | null | undefined;\n\t\tdo {\n\t\t\tconst ownedObjects = await this.#client.getOwnedObjects({\n\t\t\t\tcursor: nextCursor,\n\t\t\t\towner: this.address,\n\t\t\t\toptions: {\n\t\t\t\t\tshowType: true,\n\t\t\t\t\tshowContent: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// RPC response returns cursor even if there are no more pages\n\t\t\tnextCursor = ownedObjects.hasNextPage ? ownedObjects.nextCursor : null;\n\t\t\tfor (const object of ownedObjects.data) {\n\t\t\t\tif (object.data) {\n\t\t\t\t\tthis.#ownedObjects.push({\n\t\t\t\t\t\tobjectId: normalizeSuiObjectId(object.data.objectId),\n\t\t\t\t\t\tversion: object.data.version,\n\t\t\t\t\t\tdigest: object.data.digest,\n\t\t\t\t\t\ttype: normalizeStructTag(object.data.type!),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} while (nextCursor);\n\n\t\tconst coins = await this.#client.getCoins({\n\t\t\tcoinType: SUI_COIN_TYPE,\n\t\t\towner: this.address,\n\t\t});\n\n\t\tthis.#hasSui = coins.data.length > 0;\n\t\tthis.#gasCoin = coins.data.find((coin) => BigInt(coin.balance) % 1000n === 987n);\n\n\t\tconst result = await this.#client.queryTransactionBlocks({\n\t\t\tlimit: 1,\n\t\t\torder: 'ascending',\n\t\t\tfilter: {\n\t\t\t\tToAddress: this.address,\n\t\t\t},\n\t\t\toptions: {\n\t\t\t\tshowInput: true,\n\t\t\t\tshowBalanceChanges: true,\n\t\t\t\tshowObjectChanges: true,\n\t\t\t},\n\t\t});\n\n\t\tthis.creatorAddress = result.data[0]?.transaction?.data.sender;\n\n\t\tif (this.#hasSui || this.#ownedObjects.length > 0) {\n\t\t\tthis.claimed = false;\n\t\t\tthis.assets = await this.#listNonContractClaimableAssets();\n\t\t} else if (result.data[0] && loadClaimedAssets) {\n\t\t\tthis.claimed = true;\n\t\t\tawait this.#loadClaimedAssets();\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}