{"ast":null,"code":"import { ulebDecode } from \"./uleb.js\";\nclass BcsReader {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    let value1 = this.read32();\n    let value2 = this.read32();\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let {\n      value,\n      length\n    } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n}\nexport { BcsReader };","map":{"version":3,"names":["ulebDecode","BcsReader","constructor","data","bytePosition","dataView","DataView","buffer","shift","bytes","read8","value","getUint8","read16","getUint16","read32","getUint32","read64","value1","value2","result","toString","padStart","BigInt","read128","read256","readBytes","num","start","byteOffset","Uint8Array","readULEB","length","readVec","cb","i","push"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\bcs\\src\\reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}