{"ast":null,"code":"import { toBase64 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { Argument } from \"./data/internal.js\";\nvar UpgradePolicy = /* @__PURE__ */(UpgradePolicy2 => {\n  UpgradePolicy2[UpgradePolicy2[\"COMPATIBLE\"] = 0] = \"COMPATIBLE\";\n  UpgradePolicy2[UpgradePolicy2[\"ADDITIVE\"] = 128] = \"ADDITIVE\";\n  UpgradePolicy2[UpgradePolicy2[\"DEP_ONLY\"] = 192] = \"DEP_ONLY\";\n  return UpgradePolicy2;\n})(UpgradePolicy || {});\nconst Commands = {\n  MoveCall(input) {\n    const [pkg, mod = \"\", fn = \"\"] = \"target\" in input ? input.target.split(\"::\") : [input.package, input.module, input.function];\n    return {\n      $kind: \"MoveCall\",\n      MoveCall: {\n        package: pkg,\n        module: mod,\n        function: fn,\n        typeArguments: input.typeArguments ?? [],\n        arguments: input.arguments ?? []\n      }\n    };\n  },\n  TransferObjects(objects, address) {\n    return {\n      $kind: \"TransferObjects\",\n      TransferObjects: {\n        objects: objects.map(o => parse(Argument, o)),\n        address: parse(Argument, address)\n      }\n    };\n  },\n  SplitCoins(coin, amounts) {\n    return {\n      $kind: \"SplitCoins\",\n      SplitCoins: {\n        coin: parse(Argument, coin),\n        amounts: amounts.map(o => parse(Argument, o))\n      }\n    };\n  },\n  MergeCoins(destination, sources) {\n    return {\n      $kind: \"MergeCoins\",\n      MergeCoins: {\n        destination: parse(Argument, destination),\n        sources: sources.map(o => parse(Argument, o))\n      }\n    };\n  },\n  Publish({\n    modules,\n    dependencies\n  }) {\n    return {\n      $kind: \"Publish\",\n      Publish: {\n        modules: modules.map(module => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))),\n        dependencies: dependencies.map(dep => normalizeSuiObjectId(dep))\n      }\n    };\n  },\n  Upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return {\n      $kind: \"Upgrade\",\n      Upgrade: {\n        modules: modules.map(module => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))),\n        dependencies: dependencies.map(dep => normalizeSuiObjectId(dep)),\n        package: packageId,\n        ticket: parse(Argument, ticket)\n      }\n    };\n  },\n  MakeMoveVec({\n    type,\n    elements\n  }) {\n    return {\n      $kind: \"MakeMoveVec\",\n      MakeMoveVec: {\n        type: type ?? null,\n        elements: elements.map(o => parse(Argument, o))\n      }\n    };\n  },\n  Intent({\n    name,\n    inputs = {},\n    data = {}\n  }) {\n    return {\n      $kind: \"$Intent\",\n      $Intent: {\n        name,\n        inputs: Object.fromEntries(Object.entries(inputs).map(([key, value]) => [key, Array.isArray(value) ? value.map(o => parse(Argument, o)) : parse(Argument, value)])),\n        data\n      }\n    };\n  }\n};\nexport { Commands, UpgradePolicy };","map":{"version":3,"names":["toBase64","parse","normalizeSuiObjectId","Argument","UpgradePolicy","UpgradePolicy2","Commands","MoveCall","input","pkg","mod","fn","target","split","package","module","function","$kind","typeArguments","arguments","TransferObjects","objects","address","map","o","SplitCoins","coin","amounts","MergeCoins","destination","sources","Publish","modules","dependencies","Uint8Array","dep","Upgrade","packageId","ticket","MakeMoveVec","type","elements","Intent","name","inputs","data","$Intent","Object","fromEntries","entries","key","value","Array","isArray"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\Commands.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n\t| InferInput<typeof Argument>\n\t| ((tx: Transaction) => InferInput<typeof Argument>);\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n\t[K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n\tMoveCall(\n\t\tinput:\n\t\t\t| {\n\t\t\t\t\tpackage: string;\n\t\t\t\t\tmodule: string;\n\t\t\t\t\tfunction: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\ttarget: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  },\n\t): TransactionShape<'MoveCall'> {\n\t\tconst [pkg, mod = '', fn = ''] =\n\t\t\t'target' in input ? input.target.split('::') : [input.package, input.module, input.function];\n\n\t\treturn {\n\t\t\t$kind: 'MoveCall',\n\t\t\tMoveCall: {\n\t\t\t\tpackage: pkg,\n\t\t\t\tmodule: mod,\n\t\t\t\tfunction: fn,\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t},\n\t\t};\n\t},\n\n\tTransferObjects(\n\t\tobjects: InferInput<typeof Argument>[],\n\t\taddress: InferInput<typeof Argument>,\n\t): TransactionShape<'TransferObjects'> {\n\t\treturn {\n\t\t\t$kind: 'TransferObjects',\n\t\t\tTransferObjects: {\n\t\t\t\tobjects: objects.map((o) => parse(Argument, o)),\n\t\t\t\taddress: parse(Argument, address),\n\t\t\t},\n\t\t};\n\t},\n\tSplitCoins(\n\t\tcoin: InferInput<typeof Argument>,\n\t\tamounts: InferInput<typeof Argument>[],\n\t): TransactionShape<'SplitCoins'> {\n\t\treturn {\n\t\t\t$kind: 'SplitCoins',\n\t\t\tSplitCoins: {\n\t\t\t\tcoin: parse(Argument, coin),\n\t\t\t\tamounts: amounts.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tMergeCoins(\n\t\tdestination: InferInput<typeof Argument>,\n\t\tsources: InferInput<typeof Argument>[],\n\t): TransactionShape<'MergeCoins'> {\n\t\treturn {\n\t\t\t$kind: 'MergeCoins',\n\t\t\tMergeCoins: {\n\t\t\t\tdestination: parse(Argument, destination),\n\t\t\t\tsources: sources.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): TransactionShape<'Publish'> {\n\t\treturn {\n\t\t\t$kind: 'Publish',\n\t\t\tPublish: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t};\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: InferInput<typeof Argument>;\n\t}): TransactionShape<'Upgrade'> {\n\t\treturn {\n\t\t\t$kind: 'Upgrade',\n\t\t\tUpgrade: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: parse(Argument, ticket),\n\t\t\t},\n\t\t};\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\ttype?: string;\n\t\telements: InferInput<typeof Argument>[];\n\t}): TransactionShape<'MakeMoveVec'> {\n\t\treturn {\n\t\t\t$kind: 'MakeMoveVec',\n\t\t\tMakeMoveVec: {\n\t\t\t\ttype: type ?? null,\n\t\t\t\telements: elements.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tIntent({\n\t\tname,\n\t\tinputs = {},\n\t\tdata = {},\n\t}: {\n\t\tname: string;\n\t\tinputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n\t\tdata?: Record<string, unknown>;\n\t}): TransactionShape<'$Intent'> {\n\t\treturn {\n\t\t\t$kind: '$Intent',\n\t\t\t$Intent: {\n\t\t\t\tname,\n\t\t\t\tinputs: Object.fromEntries(\n\t\t\t\t\tObject.entries(inputs).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tArray.isArray(value) ? value.map((o) => parse(Argument, o)) : parse(Argument, value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\tdata,\n\t\t\t},\n\t\t};\n\t},\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}