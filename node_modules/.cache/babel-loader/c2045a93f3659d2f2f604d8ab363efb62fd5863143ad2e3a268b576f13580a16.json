{"ast":null,"code":"import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport { secp256r1 } from \"@noble/curves/p256\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { PasskeyAuthenticator } from \"../../bcs/bcs.js\";\nimport { bytesEqual, PublicKey } from \"../../cryptography/publickey.js\";\nimport { SIGNATURE_SCHEME_TO_FLAG } from \"../../cryptography/signature-scheme.js\";\nconst PASSKEY_PUBLIC_KEY_SIZE = 33;\nconst PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nconst PASSKEY_SIGNATURE_SIZE = 64;\nconst SECP256R1_SPKI_HEADER = new Uint8Array([48, 89,\n// SEQUENCE, length 89\n48, 19,\n// SEQUENCE, length 19\n6, 7,\n// OID, length 7\n42, 134, 72, 206, 61, 2, 1,\n// OID: 1.2.840.10045.2.1 (ecPublicKey)\n6, 8,\n// OID, length 8\n42, 134, 72, 206, 61, 3, 1, 7,\n// OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)\n3, 66,\n// BIT STRING, length 66\n0\n// no unused bits\n]);\nclass PasskeyPublicKey extends PublicKey {\n  /**\n   * Create a new PasskeyPublicKey object\n   * @param value passkey public key as buffer or base-64 encoded string\n   */\n  constructor(value) {\n    super();\n    if (typeof value === \"string\") {\n      this.data = fromBase64(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n    if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {\n      throw new Error(`Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`);\n    }\n  }\n  /**\n   * Checks if two passkey public keys are equal\n   */\n  equals(publicKey) {\n    return super.equals(publicKey);\n  }\n  /**\n   * Return the byte array representation of the Secp256r1 public key\n   */\n  toRawBytes() {\n    return this.data;\n  }\n  /**\n   * Return the Sui address associated with this Secp256r1 public key\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"Passkey\"];\n  }\n  /**\n   * Verifies that the signature is valid for for the provided message\n   */\n  async verify(message, signature) {\n    const parsed = parseSerializedPasskeySignature(signature);\n    const clientDataJSON = JSON.parse(parsed.clientDataJson);\n    if (clientDataJSON.type !== \"webauthn.get\") {\n      return false;\n    }\n    const parsedChallenge = fromBase64(clientDataJSON.challenge.replace(/-/g, \"+\").replace(/_/g, \"/\"));\n    if (!bytesEqual(message, parsedChallenge)) {\n      return false;\n    }\n    const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);\n    if (!bytesEqual(this.toRawBytes(), pk)) {\n      return false;\n    }\n    const payload = new Uint8Array([...parsed.authenticatorData, ...sha256(parsed.clientDataJson)]);\n    const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);\n    return secp256r1.verify(sig, sha256(payload), pk);\n  }\n}\nPasskeyPublicKey.SIZE = PASSKEY_PUBLIC_KEY_SIZE;\nfunction parseDerSPKI(derBytes) {\n  if (derBytes.length !== SECP256R1_SPKI_HEADER.length + PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n    throw new Error(\"Invalid DER length\");\n  }\n  for (let i = 0; i < SECP256R1_SPKI_HEADER.length; i++) {\n    if (derBytes[i] !== SECP256R1_SPKI_HEADER[i]) {\n      throw new Error(\"Invalid spki header\");\n    }\n  }\n  if (derBytes[SECP256R1_SPKI_HEADER.length] !== 4) {\n    throw new Error(\"Invalid point marker\");\n  }\n  return derBytes.slice(SECP256R1_SPKI_HEADER.length);\n}\nfunction parseSerializedPasskeySignature(signature) {\n  const bytes = typeof signature === \"string\" ? fromBase64(signature) : signature;\n  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {\n    throw new Error(\"Invalid signature scheme\");\n  }\n  const dec = PasskeyAuthenticator.parse(bytes.slice(1));\n  return {\n    signatureScheme: \"Passkey\",\n    serializedSignature: toBase64(bytes),\n    signature: bytes,\n    authenticatorData: dec.authenticatorData,\n    clientDataJson: dec.clientDataJson,\n    userSignature: new Uint8Array(dec.userSignature),\n    publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE))\n  };\n}\nexport { PASSKEY_PUBLIC_KEY_SIZE, PASSKEY_SIGNATURE_SIZE, PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE, PasskeyPublicKey, SECP256R1_SPKI_HEADER, parseDerSPKI, parseSerializedPasskeySignature };","map":{"version":3,"names":["fromBase64","toBase64","secp256r1","sha256","PasskeyAuthenticator","bytesEqual","PublicKey","SIGNATURE_SCHEME_TO_FLAG","PASSKEY_PUBLIC_KEY_SIZE","PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE","PASSKEY_SIGNATURE_SIZE","SECP256R1_SPKI_HEADER","Uint8Array","PasskeyPublicKey","constructor","value","data","from","length","Error","equals","publicKey","toRawBytes","flag","verify","message","signature","parsed","parseSerializedPasskeySignature","clientDataJSON","JSON","parse","clientDataJson","type","parsedChallenge","challenge","replace","pk","userSignature","slice","payload","authenticatorData","sig","SIZE","parseDerSPKI","derBytes","i","bytes","Passkey","dec","signatureScheme","serializedSignature"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\keypairs\\passkey\\publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { PasskeyAuthenticator } from '../../bcs/bcs.js';\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nexport const PASSKEY_PUBLIC_KEY_SIZE = 33;\nexport const PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nexport const PASSKEY_SIGNATURE_SIZE = 64;\n/** Fixed DER header for secp256r1 SubjectPublicKeyInfo\nDER structure for P-256 SPKI:\n30 -- SEQUENCE\n  59 -- length (89 bytes)\n  30 -- SEQUENCE\n    13 -- length (19 bytes)\n    06 -- OBJECT IDENTIFIER\n      07 -- length\n      2A 86 48 CE 3D 02 01 -- id-ecPublicKey\n    06 -- OBJECT IDENTIFIER\n      08 -- length\n      2A 86 48 CE 3D 03 01 07 -- secp256r1/prime256v1\n  03 -- BIT STRING\n    42 -- length (66 bytes)\n    00 -- padding\n\t===== above bytes are considered header =====\n    04 || x || y -- uncompressed point (65 bytes: 0x04 || 32-byte x || 32-byte y)\n*/\nexport const SECP256R1_SPKI_HEADER = new Uint8Array([\n\t0x30,\n\t0x59, // SEQUENCE, length 89\n\t0x30,\n\t0x13, // SEQUENCE, length 19\n\t0x06,\n\t0x07, // OID, length 7\n\t0x2a,\n\t0x86,\n\t0x48,\n\t0xce,\n\t0x3d,\n\t0x02,\n\t0x01, // OID: 1.2.840.10045.2.1 (ecPublicKey)\n\t0x06,\n\t0x08, // OID, length 8\n\t0x2a,\n\t0x86,\n\t0x48,\n\t0xce,\n\t0x3d,\n\t0x03,\n\t0x01,\n\t0x07, // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)\n\t0x03,\n\t0x42, // BIT STRING, length 66\n\t0x00, // no unused bits\n] as const);\n\n/**\n * A passkey public key\n */\nexport class PasskeyPublicKey extends PublicKey {\n\tstatic SIZE = PASSKEY_PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array;\n\n\t/**\n\t * Create a new PasskeyPublicKey object\n\t * @param value passkey public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two passkey public keys are equal\n\t */\n\toverride equals(publicKey: PasskeyPublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Secp256r1 public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Secp256r1 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['Passkey'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsed = parseSerializedPasskeySignature(signature);\n\t\tconst clientDataJSON = JSON.parse(parsed.clientDataJson);\n\n\t\tif (clientDataJSON.type !== 'webauthn.get') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// parse challenge from base64 url\n\t\tconst parsedChallenge = fromBase64(\n\t\t\tclientDataJSON.challenge.replace(/-/g, '+').replace(/_/g, '/'),\n\t\t);\n\t\tif (!bytesEqual(message, parsedChallenge)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);\n\t\tif (!bytesEqual(this.toRawBytes(), pk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst payload = new Uint8Array([...parsed.authenticatorData, ...sha256(parsed.clientDataJson)]);\n\t\tconst sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);\n\t\treturn secp256r1.verify(sig, sha256(payload), pk);\n\t}\n}\n\n/**\n * Parses a DER SubjectPublicKeyInfo into an uncompressed public key. This also verifies\n * that the curve used is P-256 (secp256r1).\n *\n * @param data: DER SubjectPublicKeyInfo\n * @returns uncompressed public key (`0x04 || x || y`)\n */\nexport function parseDerSPKI(derBytes: Uint8Array): Uint8Array {\n\t// Verify length and header bytes are expected\n\tif (derBytes.length !== SECP256R1_SPKI_HEADER.length + PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n\t\tthrow new Error('Invalid DER length');\n\t}\n\tfor (let i = 0; i < SECP256R1_SPKI_HEADER.length; i++) {\n\t\tif (derBytes[i] !== SECP256R1_SPKI_HEADER[i]) {\n\t\t\tthrow new Error('Invalid spki header');\n\t\t}\n\t}\n\n\tif (derBytes[SECP256R1_SPKI_HEADER.length] !== 0x04) {\n\t\tthrow new Error('Invalid point marker');\n\t}\n\n\t// Returns the last 65 bytes `04 || x || y`\n\treturn derBytes.slice(SECP256R1_SPKI_HEADER.length);\n}\n\n/**\n * Parse signature from bytes or base64 string into the following fields.\n */\nexport function parseSerializedPasskeySignature(signature: Uint8Array | string) {\n\tconst bytes = typeof signature === 'string' ? fromBase64(signature) : signature;\n\n\tif (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {\n\t\tthrow new Error('Invalid signature scheme');\n\t}\n\tconst dec = PasskeyAuthenticator.parse(bytes.slice(1));\n\treturn {\n\t\tsignatureScheme: 'Passkey' as const,\n\t\tserializedSignature: toBase64(bytes),\n\t\tsignature: bytes,\n\t\tauthenticatorData: dec.authenticatorData,\n\t\tclientDataJson: dec.clientDataJson,\n\t\tuserSignature: new Uint8Array(dec.userSignature),\n\t\tpublicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE)),\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}