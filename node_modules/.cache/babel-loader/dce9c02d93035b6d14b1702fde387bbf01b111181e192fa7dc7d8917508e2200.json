{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _host, _path, _client, _redirect, _coinsByType, _contract, _ZkSendLinkBuilder_instances, objectsToTransfer_fn, createSendTransactionWithoutContract_fn, estimateClaimGasFee_fn, getCoinsByType_fn;\nimport { getFullnodeUrl, SuiClient } from \"@mysten/sui/client\";\nimport { decodeSuiPrivateKey } from \"@mysten/sui/cryptography\";\nimport { Ed25519Keypair } from \"@mysten/sui/keypairs/ed25519\";\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { normalizeStructTag, normalizeSuiAddress, SUI_TYPE_ARG, toBase64 } from \"@mysten/sui/utils\";\nimport { getContractIds, ZkBag } from \"./zk-bag.js\";\nconst DEFAULT_ZK_SEND_LINK_OPTIONS = {\n  host: \"https://getstashed.com\",\n  path: \"/claim\",\n  network: \"mainnet\"\n};\nconst SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);\nconst _ZkSendLinkBuilder = class _ZkSendLinkBuilder {\n  constructor({\n    host = DEFAULT_ZK_SEND_LINK_OPTIONS.host,\n    path = DEFAULT_ZK_SEND_LINK_OPTIONS.path,\n    keypair = new Ed25519Keypair(),\n    network = DEFAULT_ZK_SEND_LINK_OPTIONS.network,\n    client = new SuiClient({\n      url: getFullnodeUrl(network)\n    }),\n    sender,\n    redirect,\n    contract = getContractIds(network)\n  }) {\n    __privateAdd(this, _ZkSendLinkBuilder_instances);\n    this.objectIds = /* @__PURE__ */new Set();\n    this.objectRefs = [];\n    this.balances = /* @__PURE__ */new Map();\n    __privateAdd(this, _host);\n    __privateAdd(this, _path);\n    __privateAdd(this, _client);\n    __privateAdd(this, _redirect);\n    __privateAdd(this, _coinsByType, /* @__PURE__ */new Map());\n    __privateAdd(this, _contract);\n    __privateSet(this, _host, host);\n    __privateSet(this, _path, path);\n    __privateSet(this, _redirect, redirect);\n    this.keypair = keypair;\n    __privateSet(this, _client, client);\n    this.sender = normalizeSuiAddress(sender);\n    this.network = network;\n    if (contract) {\n      __privateSet(this, _contract, new ZkBag(contract.packageId, contract));\n    }\n  }\n  addClaimableMist(amount) {\n    this.addClaimableBalance(SUI_COIN_TYPE, amount);\n  }\n  addClaimableBalance(coinType, amount) {\n    const normalizedType = normalizeStructTag(coinType);\n    this.balances.set(normalizedType, (this.balances.get(normalizedType) ?? 0n) + amount);\n  }\n  addClaimableObject(id) {\n    this.objectIds.add(id);\n  }\n  addClaimableObjectRef(ref, type) {\n    this.objectRefs.push({\n      ref,\n      type\n    });\n  }\n  getLink() {\n    const link = new URL(__privateGet(this, _host));\n    link.pathname = __privateGet(this, _path);\n    link.hash = `${__privateGet(this, _contract) ? \"$\" : \"\"}${toBase64(decodeSuiPrivateKey(this.keypair.getSecretKey()).secretKey)}`;\n    if (this.network !== \"mainnet\") {\n      link.searchParams.set(\"network\", this.network);\n    }\n    if (__privateGet(this, _redirect)) {\n      link.searchParams.set(\"redirect_url\", __privateGet(this, _redirect).url);\n      if (__privateGet(this, _redirect).name) {\n        link.searchParams.set(\"name\", __privateGet(this, _redirect).name);\n      }\n    }\n    return link.toString();\n  }\n  async create({\n    signer,\n    ...options\n  }) {\n    const tx = await this.createSendTransaction(options);\n    const result = await __privateGet(this, _client).signAndExecuteTransaction({\n      transaction: await tx.build({\n        client: __privateGet(this, _client)\n      }),\n      signer,\n      options: {\n        showEffects: true\n      }\n    });\n    if (result.effects?.status.status !== \"success\") {\n      throw new Error(`Transaction failed: ${result.effects?.status.error ?? \"Unknown error\"}`);\n    }\n    if (options.waitForTransaction) {\n      await __privateGet(this, _client).waitForTransaction({\n        digest: result.digest\n      });\n    }\n    return result;\n  }\n  async createSendTransaction({\n    transaction = new Transaction(),\n    calculateGas\n  } = {}) {\n    if (!__privateGet(this, _contract)) {\n      return __privateMethod(this, _ZkSendLinkBuilder_instances, createSendTransactionWithoutContract_fn).call(this, {\n        transaction,\n        calculateGas\n      });\n    }\n    transaction.setSenderIfNotSet(this.sender);\n    return _ZkSendLinkBuilder.createLinks({\n      transaction,\n      network: this.network,\n      client: __privateGet(this, _client),\n      contract: __privateGet(this, _contract).ids,\n      links: [this]\n    });\n  }\n  async createSendToAddressTransaction({\n    transaction = new Transaction(),\n    address\n  }) {\n    const objectsToTransfer = (await __privateMethod(this, _ZkSendLinkBuilder_instances, objectsToTransfer_fn).call(this, transaction)).map(obj => obj.ref);\n    transaction.setSenderIfNotSet(this.sender);\n    transaction.transferObjects(objectsToTransfer, address);\n    return transaction;\n  }\n  static async createLinks({\n    links,\n    network = \"mainnet\",\n    client = new SuiClient({\n      url: getFullnodeUrl(network)\n    }),\n    transaction = new Transaction(),\n    contract: contractIds = getContractIds(network)\n  }) {\n    const contract = new ZkBag(contractIds.packageId, contractIds);\n    const store = transaction.object(contract.ids.bagStoreId);\n    const coinsByType = /* @__PURE__ */new Map();\n    const allIds = links.flatMap(link => [...link.objectIds]);\n    const sender = links[0].sender;\n    transaction.setSenderIfNotSet(sender);\n    await Promise.all([...new Set(links.flatMap(link => [...link.balances.keys()]))].map(async coinType => {\n      const coins = await client.getCoins({\n        coinType,\n        owner: sender\n      });\n      coinsByType.set(coinType, coins.data.filter(coin => !allIds.includes(coin.coinObjectId)));\n    }));\n    const objectRefs = /* @__PURE__ */new Map();\n    const pageSize = 50;\n    let offset = 0;\n    while (offset < allIds.length) {\n      let chunk = allIds.slice(offset, offset + pageSize);\n      offset += pageSize;\n      const objects = await client.multiGetObjects({\n        ids: chunk,\n        options: {\n          showType: true\n        }\n      });\n      for (const [i, res] of objects.entries()) {\n        if (!res.data || res.error) {\n          throw new Error(`Failed to load object ${chunk[i]} (${res.error?.code})`);\n        }\n        objectRefs.set(chunk[i], {\n          ref: transaction.objectRef({\n            version: res.data.version,\n            digest: res.data.digest,\n            objectId: res.data.objectId\n          }),\n          type: res.data.type\n        });\n      }\n    }\n    const mergedCoins = /* @__PURE__ */new Map([[SUI_COIN_TYPE, transaction.gas]]);\n    for (const [coinType, coins] of coinsByType) {\n      if (coinType === SUI_COIN_TYPE) {\n        continue;\n      }\n      const [first, ...rest] = coins.map(coin => transaction.objectRef({\n        objectId: coin.coinObjectId,\n        version: coin.version,\n        digest: coin.digest\n      }));\n      if (rest.length > 0) {\n        transaction.mergeCoins(first, rest);\n      }\n      mergedCoins.set(coinType, transaction.object(first));\n    }\n    for (const link of links) {\n      const receiver = link.keypair.toSuiAddress();\n      transaction.add(contract.new({\n        arguments: [store, receiver]\n      }));\n      link.objectRefs.forEach(({\n        ref,\n        type\n      }) => {\n        transaction.add(contract.add({\n          arguments: [store, receiver, ref],\n          typeArguments: [type]\n        }));\n      });\n      link.objectIds.forEach(id => {\n        const object = objectRefs.get(id);\n        if (!object) {\n          throw new Error(`Object ${id} not found`);\n        }\n        transaction.add(contract.add({\n          arguments: [store, receiver, object.ref],\n          typeArguments: [object.type]\n        }));\n      });\n    }\n    for (const [coinType, merged] of mergedCoins) {\n      const linksWithCoin = links.filter(link => link.balances.has(coinType));\n      if (linksWithCoin.length === 0) {\n        continue;\n      }\n      const balances = linksWithCoin.map(link => link.balances.get(coinType));\n      const splits = transaction.splitCoins(merged, balances);\n      for (const [i, link] of linksWithCoin.entries()) {\n        transaction.add(contract.add({\n          arguments: [store, link.keypair.toSuiAddress(), splits[i]],\n          typeArguments: [`0x2::coin::Coin<${coinType}>`]\n        }));\n      }\n    }\n    return transaction;\n  }\n};\n_host = new WeakMap();\n_path = new WeakMap();\n_client = new WeakMap();\n_redirect = new WeakMap();\n_coinsByType = new WeakMap();\n_contract = new WeakMap();\n_ZkSendLinkBuilder_instances = new WeakSet();\nobjectsToTransfer_fn = async function (tx) {\n  const objectIDs = [...this.objectIds];\n  const refsWithType = this.objectRefs.concat((objectIDs.length > 0 ? await __privateGet(this, _client).multiGetObjects({\n    ids: objectIDs,\n    options: {\n      showType: true\n    }\n  }) : []).map((res, i) => {\n    if (!res.data || res.error) {\n      throw new Error(`Failed to load object ${objectIDs[i]} (${res.error?.code})`);\n    }\n    return {\n      ref: tx.objectRef({\n        version: res.data.version,\n        digest: res.data.digest,\n        objectId: res.data.objectId\n      }),\n      type: res.data.type\n    };\n  }));\n  for (const [coinType, amount] of this.balances) {\n    if (coinType === SUI_COIN_TYPE) {\n      const [sui] = tx.splitCoins(tx.gas, [amount]);\n      refsWithType.push({\n        ref: sui,\n        type: `0x2::coin::Coin<${coinType}>`\n      });\n    } else {\n      const coins = (await __privateMethod(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType)).map(coin => coin.coinObjectId);\n      if (coins.length > 1) {\n        tx.mergeCoins(coins[0], coins.slice(1));\n      }\n      const [split] = tx.splitCoins(coins[0], [amount]);\n      refsWithType.push({\n        ref: split,\n        type: `0x2::coin::Coin<${coinType}>`\n      });\n    }\n  }\n  return refsWithType;\n};\ncreateSendTransactionWithoutContract_fn = async function ({\n  transaction: tx = new Transaction(),\n  calculateGas\n} = {}) {\n  const gasEstimateFromDryRun = await __privateMethod(this, _ZkSendLinkBuilder_instances, estimateClaimGasFee_fn).call(this);\n  const baseGasAmount = calculateGas ? await calculateGas({\n    balances: this.balances,\n    objects: [...this.objectIds],\n    gasEstimateFromDryRun\n  }) : gasEstimateFromDryRun * 2n;\n  const gasWithBuffer = baseGasAmount + 1013n;\n  const roundedGasAmount = gasWithBuffer - gasWithBuffer % 1000n - 13n;\n  const address = this.keypair.toSuiAddress();\n  const objectsToTransfer = (await __privateMethod(this, _ZkSendLinkBuilder_instances, objectsToTransfer_fn).call(this, tx)).map(obj => obj.ref);\n  const [gas] = tx.splitCoins(tx.gas, [roundedGasAmount]);\n  objectsToTransfer.push(gas);\n  tx.setSenderIfNotSet(this.sender);\n  tx.transferObjects(objectsToTransfer, address);\n  return tx;\n};\nestimateClaimGasFee_fn = async function () {\n  const tx = new Transaction();\n  tx.setSender(this.sender);\n  tx.setGasPayment([]);\n  tx.transferObjects([tx.gas], this.keypair.toSuiAddress());\n  const idsToTransfer = [...this.objectIds];\n  for (const [coinType] of this.balances) {\n    const coins = await __privateMethod(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType);\n    if (!coins.length) {\n      throw new Error(`Sending account does not contain any coins of type ${coinType}`);\n    }\n    idsToTransfer.push(coins[0].coinObjectId);\n  }\n  if (idsToTransfer.length > 0) {\n    tx.transferObjects(idsToTransfer.map(id => tx.object(id)), this.keypair.toSuiAddress());\n  }\n  const result = await __privateGet(this, _client).dryRunTransactionBlock({\n    transactionBlock: await tx.build({\n      client: __privateGet(this, _client)\n    })\n  });\n  return BigInt(result.effects.gasUsed.computationCost) + BigInt(result.effects.gasUsed.storageCost) - BigInt(result.effects.gasUsed.storageRebate);\n};\ngetCoinsByType_fn = async function (coinType) {\n  if (__privateGet(this, _coinsByType).has(coinType)) {\n    return __privateGet(this, _coinsByType).get(coinType);\n  }\n  const coins = await __privateGet(this, _client).getCoins({\n    coinType,\n    owner: this.sender\n  });\n  __privateGet(this, _coinsByType).set(coinType, coins.data);\n  return coins.data;\n};\nlet ZkSendLinkBuilder = _ZkSendLinkBuilder;\nexport { ZkSendLinkBuilder };","map":{"version":3,"names":["_host","_path","_client","_redirect","_coinsByType","_contract","_ZkSendLinkBuilder_instances","objectsToTransfer_fn","createSendTransactionWithoutContract_fn","estimateClaimGasFee_fn","getCoinsByType_fn","getFullnodeUrl","SuiClient","decodeSuiPrivateKey","Ed25519Keypair","Transaction","normalizeStructTag","normalizeSuiAddress","SUI_TYPE_ARG","toBase64","getContractIds","ZkBag","DEFAULT_ZK_SEND_LINK_OPTIONS","host","path","network","SUI_COIN_TYPE","_ZkSendLinkBuilder","constructor","keypair","client","url","sender","redirect","contract","__privateAdd","objectIds","Set","objectRefs","balances","Map","__privateSet","packageId","addClaimableMist","amount","addClaimableBalance","coinType","normalizedType","set","get","addClaimableObject","id","add","addClaimableObjectRef","ref","type","push","getLink","link","URL","__privateGet","pathname","hash","getSecretKey","secretKey","searchParams","name","toString","create","signer","options","tx","createSendTransaction","result","signAndExecuteTransaction","transaction","build","showEffects","effects","status","Error","error","waitForTransaction","digest","calculateGas","__privateMethod","call","setSenderIfNotSet","createLinks","ids","links","createSendToAddressTransaction","address","objectsToTransfer","map","obj","transferObjects","contractIds","store","object","bagStoreId","coinsByType","allIds","flatMap","Promise","all","keys","coins","getCoins","owner","data","filter","coin","includes","coinObjectId","pageSize","offset","length","chunk","slice","objects","multiGetObjects","showType","i","res","entries","code","objectRef","version","objectId","mergedCoins","gas","first","rest","mergeCoins","receiver","toSuiAddress","new","arguments","forEach","typeArguments","merged","linksWithCoin","has","splits","splitCoins","WeakMap","WeakSet","objectIDs","refsWithType","concat","sui","split","gasEstimateFromDryRun","baseGasAmount","gasWithBuffer","roundedGasAmount","setSender","setGasPayment","idsToTransfer","dryRunTransactionBlock","transactionBlock","BigInt","gasUsed","computationCost","storageCost","storageRebate","ZkSendLinkBuilder"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\zksend\\src\\links\\builder.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getFullnodeUrl, SuiClient } from '@mysten/sui/client';\nimport type { CoinStruct } from '@mysten/sui/client';\nimport { decodeSuiPrivateKey } from '@mysten/sui/cryptography';\nimport type { Keypair, Signer } from '@mysten/sui/cryptography';\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\nimport type { TransactionObjectArgument, TransactionObjectInput } from '@mysten/sui/transactions';\nimport { Transaction } from '@mysten/sui/transactions';\nimport { normalizeStructTag, normalizeSuiAddress, SUI_TYPE_ARG, toBase64 } from '@mysten/sui/utils';\n\nimport type { ZkBagContractOptions } from './zk-bag.js';\nimport { getContractIds, ZkBag } from './zk-bag.js';\n\ninterface ZkSendLinkRedirect {\n\turl: string;\n\tname?: string;\n}\n\nexport interface ZkSendLinkBuilderOptions {\n\thost?: string;\n\tpath?: string;\n\tkeypair?: Keypair;\n\tnetwork?: 'mainnet' | 'testnet';\n\tclient?: SuiClient;\n\tsender: string;\n\tredirect?: ZkSendLinkRedirect;\n\tcontract?: ZkBagContractOptions | null;\n}\n\nconst DEFAULT_ZK_SEND_LINK_OPTIONS = {\n\thost: 'https://getstashed.com',\n\tpath: '/claim',\n\tnetwork: 'mainnet' as const,\n};\n\nconst SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);\n\nexport interface CreateZkSendLinkOptions {\n\ttransaction?: Transaction;\n\tcalculateGas?: (options: {\n\t\tbalances: Map<string, bigint>;\n\t\tobjects: TransactionObjectInput[];\n\t\tgasEstimateFromDryRun: bigint;\n\t}) => Promise<bigint> | bigint;\n}\n\nexport class ZkSendLinkBuilder {\n\tobjectIds = new Set<string>();\n\tobjectRefs: {\n\t\tref: TransactionObjectArgument;\n\t\ttype: string;\n\t}[] = [];\n\tbalances = new Map<string, bigint>();\n\tsender: string;\n\tnetwork: 'mainnet' | 'testnet';\n\t#host: string;\n\t#path: string;\n\tkeypair: Keypair;\n\t#client: SuiClient;\n\t#redirect?: ZkSendLinkRedirect;\n\t#coinsByType = new Map<string, CoinStruct[]>();\n\t#contract?: ZkBag<ZkBagContractOptions>;\n\n\tconstructor({\n\t\thost = DEFAULT_ZK_SEND_LINK_OPTIONS.host,\n\t\tpath = DEFAULT_ZK_SEND_LINK_OPTIONS.path,\n\t\tkeypair = new Ed25519Keypair(),\n\t\tnetwork = DEFAULT_ZK_SEND_LINK_OPTIONS.network,\n\t\tclient = new SuiClient({ url: getFullnodeUrl(network) }),\n\t\tsender,\n\t\tredirect,\n\t\tcontract = getContractIds(network),\n\t}: ZkSendLinkBuilderOptions) {\n\t\tthis.#host = host;\n\t\tthis.#path = path;\n\t\tthis.#redirect = redirect;\n\t\tthis.keypair = keypair;\n\t\tthis.#client = client;\n\t\tthis.sender = normalizeSuiAddress(sender);\n\t\tthis.network = network;\n\n\t\tif (contract) {\n\t\t\tthis.#contract = new ZkBag(contract.packageId, contract);\n\t\t}\n\t}\n\n\taddClaimableMist(amount: bigint) {\n\t\tthis.addClaimableBalance(SUI_COIN_TYPE, amount);\n\t}\n\n\taddClaimableBalance(coinType: string, amount: bigint) {\n\t\tconst normalizedType = normalizeStructTag(coinType);\n\t\tthis.balances.set(normalizedType, (this.balances.get(normalizedType) ?? 0n) + amount);\n\t}\n\n\taddClaimableObject(id: string) {\n\t\tthis.objectIds.add(id);\n\t}\n\n\taddClaimableObjectRef(ref: TransactionObjectArgument, type: string) {\n\t\tthis.objectRefs.push({ ref, type });\n\t}\n\n\tgetLink(): string {\n\t\tconst link = new URL(this.#host);\n\t\tlink.pathname = this.#path;\n\t\tlink.hash = `${this.#contract ? '$' : ''}${toBase64(\n\t\t\tdecodeSuiPrivateKey(this.keypair.getSecretKey()).secretKey,\n\t\t)}`;\n\n\t\tif (this.network !== 'mainnet') {\n\t\t\tlink.searchParams.set('network', this.network);\n\t\t}\n\n\t\tif (this.#redirect) {\n\t\t\tlink.searchParams.set('redirect_url', this.#redirect.url);\n\t\t\tif (this.#redirect.name) {\n\t\t\t\tlink.searchParams.set('name', this.#redirect.name);\n\t\t\t}\n\t\t}\n\n\t\treturn link.toString();\n\t}\n\n\tasync create({\n\t\tsigner,\n\t\t...options\n\t}: CreateZkSendLinkOptions & {\n\t\tsigner: Signer;\n\t\twaitForTransaction?: boolean;\n\t}) {\n\t\tconst tx = await this.createSendTransaction(options);\n\n\t\tconst result = await this.#client.signAndExecuteTransaction({\n\t\t\ttransaction: await tx.build({ client: this.#client }),\n\t\t\tsigner,\n\t\t\toptions: {\n\t\t\t\tshowEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tif (result.effects?.status.status !== 'success') {\n\t\t\tthrow new Error(`Transaction failed: ${result.effects?.status.error ?? 'Unknown error'}`);\n\t\t}\n\n\t\tif (options.waitForTransaction) {\n\t\t\tawait this.#client.waitForTransaction({ digest: result.digest });\n\t\t}\n\n\t\treturn result;\n\t}\n\tasync createSendTransaction({\n\t\ttransaction = new Transaction(),\n\t\tcalculateGas,\n\t}: CreateZkSendLinkOptions = {}) {\n\t\tif (!this.#contract) {\n\t\t\treturn this.#createSendTransactionWithoutContract({ transaction, calculateGas });\n\t\t}\n\n\t\ttransaction.setSenderIfNotSet(this.sender);\n\n\t\treturn ZkSendLinkBuilder.createLinks({\n\t\t\ttransaction,\n\t\t\tnetwork: this.network,\n\t\t\tclient: this.#client,\n\t\t\tcontract: this.#contract.ids,\n\t\t\tlinks: [this],\n\t\t});\n\t}\n\n\tasync createSendToAddressTransaction({\n\t\ttransaction = new Transaction(),\n\t\taddress,\n\t}: CreateZkSendLinkOptions & {\n\t\taddress: string;\n\t}) {\n\t\tconst objectsToTransfer = (await this.#objectsToTransfer(transaction)).map((obj) => obj.ref);\n\n\t\ttransaction.setSenderIfNotSet(this.sender);\n\t\ttransaction.transferObjects(objectsToTransfer, address);\n\n\t\treturn transaction;\n\t}\n\n\tasync #objectsToTransfer(tx: Transaction) {\n\t\tconst objectIDs = [...this.objectIds];\n\t\tconst refsWithType = this.objectRefs.concat(\n\t\t\t(objectIDs.length > 0\n\t\t\t\t? await this.#client.multiGetObjects({\n\t\t\t\t\t\tids: objectIDs,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tshowType: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t: []\n\t\t\t).map((res, i) => {\n\t\t\t\tif (!res.data || res.error) {\n\t\t\t\t\tthrow new Error(`Failed to load object ${objectIDs[i]} (${res.error?.code})`);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tref: tx.objectRef({\n\t\t\t\t\t\tversion: res.data.version,\n\t\t\t\t\t\tdigest: res.data.digest,\n\t\t\t\t\t\tobjectId: res.data.objectId,\n\t\t\t\t\t}),\n\t\t\t\t\ttype: res.data.type!,\n\t\t\t\t};\n\t\t\t}),\n\t\t);\n\n\t\tfor (const [coinType, amount] of this.balances) {\n\t\t\tif (coinType === SUI_COIN_TYPE) {\n\t\t\t\tconst [sui] = tx.splitCoins(tx.gas, [amount]);\n\t\t\t\trefsWithType.push({\n\t\t\t\t\tref: sui,\n\t\t\t\t\ttype: `0x2::coin::Coin<${coinType}>`,\n\t\t\t\t} as never);\n\t\t\t} else {\n\t\t\t\tconst coins = (await this.#getCoinsByType(coinType)).map((coin) => coin.coinObjectId);\n\n\t\t\t\tif (coins.length > 1) {\n\t\t\t\t\ttx.mergeCoins(coins[0], coins.slice(1));\n\t\t\t\t}\n\t\t\t\tconst [split] = tx.splitCoins(coins[0], [amount]);\n\t\t\t\trefsWithType.push({\n\t\t\t\t\tref: split,\n\t\t\t\t\ttype: `0x2::coin::Coin<${coinType}>`,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn refsWithType;\n\t}\n\n\tasync #createSendTransactionWithoutContract({\n\t\ttransaction: tx = new Transaction(),\n\t\tcalculateGas,\n\t}: CreateZkSendLinkOptions = {}) {\n\t\tconst gasEstimateFromDryRun = await this.#estimateClaimGasFee();\n\t\tconst baseGasAmount = calculateGas\n\t\t\t? await calculateGas({\n\t\t\t\t\tbalances: this.balances,\n\t\t\t\t\tobjects: [...this.objectIds],\n\t\t\t\t\tgasEstimateFromDryRun,\n\t\t\t\t})\n\t\t\t: gasEstimateFromDryRun * 2n;\n\n\t\t// Ensure that rounded gas is not less than the calculated gas\n\t\tconst gasWithBuffer = baseGasAmount + 1013n;\n\t\t// Ensure that gas amount ends in 987\n\t\tconst roundedGasAmount = gasWithBuffer - (gasWithBuffer % 1000n) - 13n;\n\n\t\tconst address = this.keypair.toSuiAddress();\n\t\tconst objectsToTransfer = (await this.#objectsToTransfer(tx)).map((obj) => obj.ref);\n\t\tconst [gas] = tx.splitCoins(tx.gas, [roundedGasAmount]);\n\t\tobjectsToTransfer.push(gas);\n\n\t\ttx.setSenderIfNotSet(this.sender);\n\t\ttx.transferObjects(objectsToTransfer, address);\n\n\t\treturn tx;\n\t}\n\n\tasync #estimateClaimGasFee(): Promise<bigint> {\n\t\tconst tx = new Transaction();\n\t\ttx.setSender(this.sender);\n\t\ttx.setGasPayment([]);\n\t\ttx.transferObjects([tx.gas], this.keypair.toSuiAddress());\n\n\t\tconst idsToTransfer = [...this.objectIds];\n\n\t\tfor (const [coinType] of this.balances) {\n\t\t\tconst coins = await this.#getCoinsByType(coinType);\n\n\t\t\tif (!coins.length) {\n\t\t\t\tthrow new Error(`Sending account does not contain any coins of type ${coinType}`);\n\t\t\t}\n\n\t\t\tidsToTransfer.push(coins[0].coinObjectId);\n\t\t}\n\n\t\tif (idsToTransfer.length > 0) {\n\t\t\ttx.transferObjects(\n\t\t\t\tidsToTransfer.map((id) => tx.object(id)),\n\t\t\t\tthis.keypair.toSuiAddress(),\n\t\t\t);\n\t\t}\n\n\t\tconst result = await this.#client.dryRunTransactionBlock({\n\t\t\ttransactionBlock: await tx.build({ client: this.#client }),\n\t\t});\n\n\t\treturn (\n\t\t\tBigInt(result.effects.gasUsed.computationCost) +\n\t\t\tBigInt(result.effects.gasUsed.storageCost) -\n\t\t\tBigInt(result.effects.gasUsed.storageRebate)\n\t\t);\n\t}\n\n\tasync #getCoinsByType(coinType: string) {\n\t\tif (this.#coinsByType.has(coinType)) {\n\t\t\treturn this.#coinsByType.get(coinType)!;\n\t\t}\n\n\t\tconst coins = await this.#client.getCoins({\n\t\t\tcoinType,\n\t\t\towner: this.sender,\n\t\t});\n\n\t\tthis.#coinsByType.set(coinType, coins.data);\n\n\t\treturn coins.data;\n\t}\n\n\tstatic async createLinks({\n\t\tlinks,\n\t\tnetwork = 'mainnet',\n\t\tclient = new SuiClient({ url: getFullnodeUrl(network) }),\n\t\ttransaction = new Transaction(),\n\t\tcontract: contractIds = getContractIds(network),\n\t}: {\n\t\ttransaction?: Transaction;\n\t\tclient?: SuiClient;\n\t\tnetwork?: 'mainnet' | 'testnet';\n\t\tlinks: ZkSendLinkBuilder[];\n\t\tcontract?: ZkBagContractOptions;\n\t}) {\n\t\tconst contract = new ZkBag(contractIds.packageId, contractIds);\n\t\tconst store = transaction.object(contract.ids.bagStoreId);\n\n\t\tconst coinsByType = new Map<string, CoinStruct[]>();\n\t\tconst allIds = links.flatMap((link) => [...link.objectIds]);\n\t\tconst sender = links[0].sender;\n\t\ttransaction.setSenderIfNotSet(sender);\n\n\t\tawait Promise.all(\n\t\t\t[...new Set(links.flatMap((link) => [...link.balances.keys()]))].map(async (coinType) => {\n\t\t\t\tconst coins = await client.getCoins({\n\t\t\t\t\tcoinType,\n\t\t\t\t\towner: sender,\n\t\t\t\t});\n\n\t\t\t\tcoinsByType.set(\n\t\t\t\t\tcoinType,\n\t\t\t\t\tcoins.data.filter((coin) => !allIds.includes(coin.coinObjectId)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\n\t\tconst objectRefs = new Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tref: TransactionObjectArgument;\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t>();\n\n\t\tconst pageSize = 50;\n\t\tlet offset = 0;\n\t\twhile (offset < allIds.length) {\n\t\t\tlet chunk = allIds.slice(offset, offset + pageSize);\n\t\t\toffset += pageSize;\n\n\t\t\tconst objects = await client.multiGetObjects({\n\t\t\t\tids: chunk,\n\t\t\t\toptions: {\n\t\t\t\t\tshowType: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tfor (const [i, res] of objects.entries()) {\n\t\t\t\tif (!res.data || res.error) {\n\t\t\t\t\tthrow new Error(`Failed to load object ${chunk[i]} (${res.error?.code})`);\n\t\t\t\t}\n\t\t\t\tobjectRefs.set(chunk[i], {\n\t\t\t\t\tref: transaction.objectRef({\n\t\t\t\t\t\tversion: res.data.version,\n\t\t\t\t\t\tdigest: res.data.digest,\n\t\t\t\t\t\tobjectId: res.data.objectId,\n\t\t\t\t\t}),\n\t\t\t\t\ttype: res.data.type!,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst mergedCoins = new Map<string, TransactionObjectArgument>([\n\t\t\t[SUI_COIN_TYPE, transaction.gas],\n\t\t]);\n\n\t\tfor (const [coinType, coins] of coinsByType) {\n\t\t\tif (coinType === SUI_COIN_TYPE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst [first, ...rest] = coins.map((coin) =>\n\t\t\t\ttransaction.objectRef({\n\t\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\t\tversion: coin.version,\n\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t}),\n\t\t\t);\n\t\t\tif (rest.length > 0) {\n\t\t\t\ttransaction.mergeCoins(first, rest);\n\t\t\t}\n\t\t\tmergedCoins.set(coinType, transaction.object(first));\n\t\t}\n\n\t\tfor (const link of links) {\n\t\t\tconst receiver = link.keypair.toSuiAddress();\n\t\t\ttransaction.add(contract.new({ arguments: [store, receiver] }));\n\n\t\t\tlink.objectRefs.forEach(({ ref, type }) => {\n\t\t\t\ttransaction.add(\n\t\t\t\t\tcontract.add({\n\t\t\t\t\t\targuments: [store, receiver, ref],\n\t\t\t\t\t\ttypeArguments: [type],\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tlink.objectIds.forEach((id) => {\n\t\t\t\tconst object = objectRefs.get(id);\n\t\t\t\tif (!object) {\n\t\t\t\t\tthrow new Error(`Object ${id} not found`);\n\t\t\t\t}\n\t\t\t\ttransaction.add(\n\t\t\t\t\tcontract.add({\n\t\t\t\t\t\targuments: [store, receiver, object.ref],\n\t\t\t\t\t\ttypeArguments: [object.type],\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\tfor (const [coinType, merged] of mergedCoins) {\n\t\t\tconst linksWithCoin = links.filter((link) => link.balances.has(coinType));\n\t\t\tif (linksWithCoin.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst balances = linksWithCoin.map((link) => link.balances.get(coinType)!);\n\t\t\tconst splits = transaction.splitCoins(merged, balances);\n\t\t\tfor (const [i, link] of linksWithCoin.entries()) {\n\t\t\t\ttransaction.add(\n\t\t\t\t\tcontract.add({\n\t\t\t\t\t\targuments: [store, link.keypair.toSuiAddress(), splits[i]],\n\t\t\t\t\t\ttypeArguments: [`0x2::coin::Coin<${coinType}>`],\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn transaction;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}