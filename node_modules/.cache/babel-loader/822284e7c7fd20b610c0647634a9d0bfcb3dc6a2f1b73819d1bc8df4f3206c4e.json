{"ast":null,"code":"import { splitGenericParameters } from \"@mysten/bcs\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\nclass TypeTagSerializer {\n  static parseFromStr(str, normalizeAddress = false) {\n    if (str === \"address\") {\n      return {\n        address: null\n      };\n    } else if (str === \"bool\") {\n      return {\n        bool: null\n      };\n    } else if (str === \"u8\") {\n      return {\n        u8: null\n      };\n    } else if (str === \"u16\") {\n      return {\n        u16: null\n      };\n    } else if (str === \"u32\") {\n      return {\n        u32: null\n      };\n    } else if (str === \"u64\") {\n      return {\n        u64: null\n      };\n    } else if (str === \"u128\") {\n      return {\n        u128: null\n      };\n    } else if (str === \"u256\") {\n      return {\n        u256: null\n      };\n    } else if (str === \"signer\") {\n      return {\n        signer: null\n      };\n    }\n    const vectorMatch = str.match(VECTOR_REGEX);\n    if (vectorMatch) {\n      return {\n        vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)\n      };\n    }\n    const structMatch = str.match(STRUCT_REGEX);\n    if (structMatch) {\n      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n      return {\n        struct: {\n          address,\n          module: structMatch[2],\n          name: structMatch[3],\n          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)\n        }\n      };\n    }\n    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n  }\n  static parseStructTypeArgs(str, normalizeAddress = false) {\n    return splitGenericParameters(str).map(tok => TypeTagSerializer.parseFromStr(tok, normalizeAddress));\n  }\n  static tagToString(tag) {\n    if (\"bool\" in tag) {\n      return \"bool\";\n    }\n    if (\"u8\" in tag) {\n      return \"u8\";\n    }\n    if (\"u16\" in tag) {\n      return \"u16\";\n    }\n    if (\"u32\" in tag) {\n      return \"u32\";\n    }\n    if (\"u64\" in tag) {\n      return \"u64\";\n    }\n    if (\"u128\" in tag) {\n      return \"u128\";\n    }\n    if (\"u256\" in tag) {\n      return \"u256\";\n    }\n    if (\"address\" in tag) {\n      return \"address\";\n    }\n    if (\"signer\" in tag) {\n      return \"signer\";\n    }\n    if (\"vector\" in tag) {\n      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n    }\n    if (\"struct\" in tag) {\n      const struct = tag.struct;\n      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(\", \");\n      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : \"\"}`;\n    }\n    throw new Error(\"Invalid TypeTag\");\n  }\n}\nexport { TypeTagSerializer };","map":{"version":3,"names":["splitGenericParameters","normalizeSuiAddress","VECTOR_REGEX","STRUCT_REGEX","TypeTagSerializer","parseFromStr","str","normalizeAddress","address","bool","u8","u16","u32","u64","u128","u256","signer","vectorMatch","match","vector","structMatch","struct","module","name","typeParams","parseStructTypeArgs","Error","map","tok","tagToString","tag","join"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\bcs\\type-tag-serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}