{"ast":null,"code":"import { toBase58 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { TransactionData } from \"./data/internal.js\";\nimport { transactionDataFromV1 } from \"./data/v1.js\";\nimport { hashTypedData } from \"./hash.js\";\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionDataBuilder {\n  constructor(clone) {\n    this.version = 2;\n    this.sender = clone?.sender ?? null;\n    this.expiration = clone?.expiration ?? null;\n    this.inputs = clone?.inputs ?? [];\n    this.commands = clone?.commands ?? [];\n    this.gasData = clone?.gasData ?? {\n      budget: null,\n      price: null,\n      owner: null,\n      payment: null\n    };\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = kind.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: null,\n      expiration: null,\n      gasData: {\n        budget: null,\n        owner: null,\n        payment: null,\n        price: null\n      },\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData?.V1;\n    const programmableTx = data.kind.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasData: data.gasData,\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static restore(data) {\n    if (data.version === 2) {\n      return new TransactionDataBuilder(parse(TransactionData, data));\n    } else {\n      return new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n    }\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toBase58(hash);\n  }\n  // @deprecated use gasData instead\n  get gasConfig() {\n    return this.gasData;\n  }\n  // @deprecated use gasData instead\n  set gasConfig(value) {\n    this.gasData = value;\n  }\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind\n  } = {}) {\n    const inputs = this.inputs;\n    const commands = this.commands;\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        commands\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, {\n        maxSize: maxSizeBytes\n      }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasData = {\n      ...this.gasData,\n      ...overrides?.gasConfig,\n      ...overrides?.gasData\n    };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasData.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasData.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasData.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : {\n        None: true\n      },\n      gasData: {\n        payment: gasData.payment,\n        owner: prepareSuiAddress(this.gasData.owner ?? sender),\n        price: BigInt(gasData.price),\n        budget: BigInt(gasData.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          commands\n        }\n      }\n    };\n    return bcs.TransactionData.serialize({\n      V1: transactionData\n    }, {\n      maxSize: maxSizeBytes\n    }).toBytes();\n  }\n  addInput(type, arg) {\n    const index = this.inputs.length;\n    this.inputs.push(arg);\n    return {\n      Input: index,\n      type,\n      $kind: \"Input\"\n    };\n  }\n  getInputUses(index, fn) {\n    this.mapArguments((arg, command) => {\n      if (arg.$kind === \"Input\" && arg.Input === index) {\n        fn(arg, command);\n      }\n      return arg;\n    });\n  }\n  mapArguments(fn) {\n    for (const command of this.commands) {\n      switch (command.$kind) {\n        case \"MoveCall\":\n          command.MoveCall.arguments = command.MoveCall.arguments.map(arg => fn(arg, command));\n          break;\n        case \"TransferObjects\":\n          command.TransferObjects.objects = command.TransferObjects.objects.map(arg => fn(arg, command));\n          command.TransferObjects.address = fn(command.TransferObjects.address, command);\n          break;\n        case \"SplitCoins\":\n          command.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n          command.SplitCoins.amounts = command.SplitCoins.amounts.map(arg => fn(arg, command));\n          break;\n        case \"MergeCoins\":\n          command.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n          command.MergeCoins.sources = command.MergeCoins.sources.map(arg => fn(arg, command));\n          break;\n        case \"MakeMoveVec\":\n          command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(arg => fn(arg, command));\n          break;\n        case \"Upgrade\":\n          command.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n          break;\n        case \"$Intent\":\n          const inputs = command.$Intent.inputs;\n          command.$Intent.inputs = {};\n          for (const [key, value] of Object.entries(inputs)) {\n            command.$Intent.inputs[key] = Array.isArray(value) ? value.map(arg => fn(arg, command)) : fn(value, command);\n          }\n          break;\n        case \"Publish\":\n          break;\n        default:\n          throw new Error(`Unexpected transaction kind: ${command.$kind}`);\n      }\n    }\n  }\n  replaceCommand(index, replacement) {\n    if (!Array.isArray(replacement)) {\n      this.commands[index] = replacement;\n      return;\n    }\n    const sizeDiff = replacement.length - 1;\n    this.commands.splice(index, 1, ...replacement);\n    if (sizeDiff !== 0) {\n      this.mapArguments(arg => {\n        switch (arg.$kind) {\n          case \"Result\":\n            if (arg.Result > index) {\n              arg.Result += sizeDiff;\n            }\n            break;\n          case \"NestedResult\":\n            if (arg.NestedResult[0] > index) {\n              arg.NestedResult[0] += sizeDiff;\n            }\n            break;\n        }\n        return arg;\n      });\n    }\n  }\n  getDigest() {\n    const bytes = this.build({\n      onlyTransactionKind: false\n    });\n    return TransactionDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return parse(TransactionData, this);\n  }\n}\nexport { TransactionDataBuilder };","map":{"version":3,"names":["toBase58","parse","bcs","normalizeSuiAddress","TransactionData","transactionDataFromV1","hashTypedData","prepareSuiAddress","address","replace","TransactionDataBuilder","constructor","clone","version","sender","expiration","inputs","commands","gasData","budget","price","owner","payment","fromKindBytes","bytes","kind","TransactionKind","programmableTx","ProgrammableTransaction","Error","restore","fromBytes","rawData","data","V1","getDigestFromBytes","hash","gasConfig","value","build","maxSizeBytes","Infinity","overrides","onlyTransactionKind","serialize","maxSize","toBytes","transactionData","None","BigInt","addInput","type","arg","index","length","push","Input","$kind","getInputUses","fn","mapArguments","command","MoveCall","arguments","map","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","destination","sources","MakeMoveVec","elements","Upgrade","ticket","$Intent","key","Object","entries","Array","isArray","replaceCommand","replacement","sizeDiff","splice","Result","NestedResult","getDigest","snapshot"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\TransactionData.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command) => Argument) {\n\t\tfor (const command of this.commands) {\n\t\t\tswitch (command.$kind) {\n\t\t\t\tcase 'MoveCall':\n\t\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn(arg, command));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'TransferObjects':\n\t\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tfn(arg, command),\n\t\t\t\t\t);\n\t\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'SplitCoins':\n\t\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n\t\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn(arg, command));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'MergeCoins':\n\t\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n\t\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn(arg, command));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tfn(arg, command),\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Upgrade':\n\t\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$Intent':\n\t\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t\t? value.map((arg) => fn(arg, command))\n\t\t\t\t\t\t\t: fn(value, command);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Publish':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t\t}\n\t\t}\n\t}\n\n\treplaceCommand(index: number, replacement: Command | Command[]) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\t\tthis.commands.splice(index, 1, ...replacement);\n\n\t\tif (sizeDiff !== 0) {\n\t\t\tthis.mapArguments((arg) => {\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionData, this);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}