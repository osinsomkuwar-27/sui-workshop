{"ast":null,"code":"import { findTransactionBlockNames, listToRequests, replaceNames } from \"./utils.js\";\nconst namedPackagesPlugin = ({\n  suiGraphQLClient,\n  pageSize = 10,\n  overrides = {\n    packages: {},\n    types: {}\n  }\n}) => {\n  const cache = {\n    packages: {\n      ...overrides.packages\n    },\n    types: {\n      ...overrides.types\n    }\n  };\n  return async (transactionData, _buildOptions, next) => {\n    const names = findTransactionBlockNames(transactionData);\n    const batches = listToRequests({\n      packages: names.packages.filter(x => !cache.packages[x]),\n      types: names.types.filter(x => !cache.types[x])\n    }, pageSize);\n    (await Promise.all(batches.map(batch => query(suiGraphQLClient, batch)))).forEach(res => {\n      Object.assign(cache.types, res.types);\n      Object.assign(cache.packages, res.packages);\n    });\n    replaceNames(transactionData, cache);\n    await next();\n  };\n  async function query(client, requests) {\n    const results = {\n      packages: {},\n      types: {}\n    };\n    if (requests.length === 0) return results;\n    const gqlQuery = `{\n        ${requests.map(req => {\n      const request = req.type === \"package\" ? \"packageByName\" : \"typeByName\";\n      const fields = req.type === \"package\" ? \"address\" : \"repr\";\n      return `${gqlQueryKey(req.id)}: ${request}(name:\"${req.name}\") {\n                    ${fields}\n                }`;\n    })}\n    }`;\n    const result = await client.query({\n      query: gqlQuery,\n      variables: void 0\n    });\n    if (result.errors) throw new Error(JSON.stringify({\n      query: gqlQuery,\n      errors: result.errors\n    }));\n    for (const req of requests) {\n      const key = gqlQueryKey(req.id);\n      if (!result.data || !result.data[key]) throw new Error(`No result found for: ${req.name}`);\n      const data = result.data[key];\n      if (req.type === \"package\") results.packages[req.name] = data.address;\n      if (req.type === \"moveType\") results.types[req.name] = data.repr;\n    }\n    return results;\n  }\n};\nconst gqlQueryKey = idx => `key_${idx}`;\nexport { namedPackagesPlugin };","map":{"version":3,"names":["findTransactionBlockNames","listToRequests","replaceNames","namedPackagesPlugin","suiGraphQLClient","pageSize","overrides","packages","types","cache","transactionData","_buildOptions","next","names","batches","filter","x","Promise","all","map","batch","query","forEach","res","Object","assign","client","requests","results","length","gqlQuery","req","request","type","fields","gqlQueryKey","id","name","result","variables","errors","Error","JSON","stringify","key","data","address","repr","idx"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\plugins\\NamedPackagesPlugin.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiGraphQLClient } from '../../graphql/client.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\nimport type { NamedPackagesPluginCache, NameResolutionRequest } from './utils.js';\nimport { findTransactionBlockNames, listToRequests, replaceNames } from './utils.js';\n\nexport type NamedPackagesPluginOptions = {\n\t/**\n\t * The SuiGraphQLClient to use for resolving names.\n\t * The endpoint should be the GraphQL endpoint of the network you are targeting.\n\t * For non-mainnet networks, if the plugin doesn't work as expected, you need to validate that the\n\t * RPC provider has support for the `packageByName` and `typeByName` queries (using external resolver).\n\t */\n\tsuiGraphQLClient: SuiGraphQLClient;\n\t/**\n\t * The number of names to resolve in each batch request.\n\t * Needs to be calculated based on the GraphQL query limits.\n\t */\n\tpageSize?: number;\n\t/**\n\t * Local overrides for the resolution plugin. Pass this to pre-populate\n\t * the cache with known packages / types (especially useful for local or CI testing).\n\t *\n\t * \tExpected format example:\n\t *  {\n\t * \t\tpackages: {\n\t * \t\t\t'@framework/std': '0x1234',\n\t * \t\t},\n\t * \t\ttypes: {\n\t * \t\t\t'@framework/std::string::String': '0x1234::string::String',\n\t * \t\t},\n\t * \t}\n\t *\n\t */\n\toverrides?: NamedPackagesPluginCache;\n};\n\n/**\n * @experimental This plugin is in experimental phase and there might be breaking changes in the future\n *\n * Adds named resolution so that you can use .move names in your transactions.\n * e.g. `@org/app::type::Type` will be resolved to `0x1234::type::Type`.\n * This plugin will resolve all names & types in the transaction block.\n *\n * To install this plugin globally in your app, use:\n * ```\n * Transaction.registerGlobalSerializationPlugin(\"namedPackagesPlugin\", namedPackagesPlugin({ suiGraphQLClient }));\n * ```\n *\n * You can also define `overrides` to pre-populate name resolutions locally (removes the GraphQL request).\n */\nexport const namedPackagesPlugin = ({\n\tsuiGraphQLClient,\n\tpageSize = 10,\n\toverrides = { packages: {}, types: {} },\n}: NamedPackagesPluginOptions) => {\n\tconst cache = {\n\t\tpackages: { ...overrides.packages },\n\t\ttypes: { ...overrides.types },\n\t};\n\n\treturn async (\n\t\ttransactionData: TransactionDataBuilder,\n\t\t_buildOptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) => {\n\t\tconst names = findTransactionBlockNames(transactionData);\n\t\tconst batches = listToRequests(\n\t\t\t{\n\t\t\t\tpackages: names.packages.filter((x) => !cache.packages[x]),\n\t\t\t\ttypes: names.types.filter((x) => !cache.types[x]),\n\t\t\t},\n\t\t\tpageSize,\n\t\t);\n\n\t\t// now we need to bulk resolve all the names + types, and replace them in the transaction data.\n\t\t(await Promise.all(batches.map((batch) => query(suiGraphQLClient, batch)))).forEach((res) => {\n\t\t\tObject.assign(cache.types, res.types);\n\t\t\tObject.assign(cache.packages, res.packages);\n\t\t});\n\n\t\treplaceNames(transactionData, cache);\n\n\t\tawait next();\n\t};\n\n\tasync function query(client: SuiGraphQLClient, requests: NameResolutionRequest[]) {\n\t\tconst results: NamedPackagesPluginCache = { packages: {}, types: {} };\n\t\t// avoid making a request if there are no names to resolve.\n\t\tif (requests.length === 0) return results;\n\n\t\t// Create multiple queries for each name / type we need to resolve\n\t\t// TODO: Replace with bulk APIs when available.\n\t\tconst gqlQuery = `{\n        ${requests.map((req) => {\n\t\t\t\t\tconst request = req.type === 'package' ? 'packageByName' : 'typeByName';\n\t\t\t\t\tconst fields = req.type === 'package' ? 'address' : 'repr';\n\n\t\t\t\t\treturn `${gqlQueryKey(req.id)}: ${request}(name:\"${req.name}\") {\n                    ${fields}\n                }`;\n\t\t\t\t})}\n    }`;\n\n\t\tconst result = await client.query({\n\t\t\tquery: gqlQuery,\n\t\t\tvariables: undefined,\n\t\t});\n\n\t\tif (result.errors) throw new Error(JSON.stringify({ query: gqlQuery, errors: result.errors }));\n\n\t\t// Parse the results and create a map of `<name|type> -> <address|repr>`\n\t\tfor (const req of requests) {\n\t\t\tconst key = gqlQueryKey(req.id);\n\t\t\tif (!result.data || !result.data[key]) throw new Error(`No result found for: ${req.name}`);\n\t\t\tconst data = result.data[key] as { address?: string; repr?: string };\n\n\t\t\tif (req.type === 'package') results.packages[req.name] = data.address!;\n\t\t\tif (req.type === 'moveType') results.types[req.name] = data.repr!;\n\t\t}\n\n\t\treturn results;\n\t}\n};\n\nconst gqlQueryKey = (idx: number) => `key_${idx}`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}