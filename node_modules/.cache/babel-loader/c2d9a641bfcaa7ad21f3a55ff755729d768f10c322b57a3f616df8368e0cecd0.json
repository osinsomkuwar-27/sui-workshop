{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _write, _serialize, _schema, _bytes;\nimport { fromBase58, toBase58 } from \"./b58.js\";\nimport { fromBase64, toBase64 } from \"./b64.js\";\nimport { fromHex, toHex } from \"./hex.js\";\nimport { BcsReader } from \"./reader.js\";\nimport { ulebEncode } from \"./uleb.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst _BcsType = class _BcsType {\n  constructor(options) {\n    __privateAdd(this, _write);\n    __privateAdd(this, _serialize);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = options.serializedSize ?? (() => null);\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {\n      const writer = new BcsWriter({\n        initialSize: this.serializedSize(value) ?? void 0,\n        ...options2\n      });\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    }));\n    this.validate = options.validate ?? (() => {});\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  fromHex(hex) {\n    return this.parse(fromHex(hex));\n  }\n  fromBase58(b64) {\n    return this.parse(fromBase58(b64));\n  }\n  fromBase64(b64) {\n    return this.parse(fromBase64(b64));\n  }\n  transform({\n    name,\n    input,\n    output,\n    validate\n  }) {\n    return new _BcsType({\n      name: name ?? this.name,\n      read: reader => output ? output(this.read(reader)) : this.read(reader),\n      write: (value, writer) => __privateGet(this, _write).call(this, input ? input(value) : value, writer),\n      serializedSize: value => this.serializedSize(input ? input(value) : value),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input ? input(value) : value, options),\n      validate: value => {\n        validate?.(value);\n        this.validate(input ? input(value) : value);\n      }\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nlet BcsType = _BcsType;\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n  constructor(type, schema) {\n    __privateAdd(this, _schema);\n    __privateAdd(this, _bytes);\n    __privateSet(this, _schema, type);\n    __privateSet(this, _bytes, schema);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHex(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toBase64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toBase58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({\n  size,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    serializedSize: () => size\n  });\n}\nfunction uIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: value => {\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction bigUIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: reader => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: val => {\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction dynamicSizeBcsType({\n  serialize,\n  ...options\n}) {\n  const type = new BcsType({\n    ...options,\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  });\n  return type;\n}\nfunction stringLikeBcsType({\n  toBytes,\n  fromBytes,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    read: reader => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: value => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: value => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: data => getType().read(data),\n    serializedSize: value => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\nexport { BcsType, SerializedBcs, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, isSerializedBcs, lazyBcsType, stringLikeBcsType, uIntBcsType };","map":{"version":3,"names":["_write","_serialize","_schema","_bytes","fromBase58","toBase58","fromBase64","toBase64","fromHex","toHex","BcsReader","ulebEncode","BcsWriter","_BcsType","constructor","options","__privateAdd","name","read","serializedSize","__privateSet","write","serialize","value","options2","writer","initialSize","__privateGet","call","toBytes","validate","SerializedBcs","parse","bytes","reader","hex","b64","transform","input","output","WeakMap","BcsType","SERIALIZED_BCS_BRAND","Symbol","for","isSerializedBcs","obj","type","schema","fixedSizeBcsType","size","uIntBcsType","readMethod","writeMethod","maxValue","TypeError","bigUIntBcsType","BigInt","val","dynamicSizeBcsType","byte","write8","stringLikeBcsType","fromBytes","length","readULEB","readBytes","writeULEB","i","result","Uint8Array","set","lazyBcsType","cb","lazyType","getType","data"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\bcs\\src\\bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}