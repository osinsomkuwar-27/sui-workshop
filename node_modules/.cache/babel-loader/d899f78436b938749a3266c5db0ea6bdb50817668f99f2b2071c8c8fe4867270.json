{"ast":null,"code":"import { ed25519 } from \"@noble/curves/ed25519\";\nimport { decodeSuiPrivateKey, encodeSuiPrivateKey, Keypair, PRIVATE_KEY_SIZE } from \"../../cryptography/keypair.js\";\nimport { isValidHardenedPath, mnemonicToSeedHex } from \"../../cryptography/mnemonics.js\";\nimport { derivePath } from \"./ed25519-hd-key.js\";\nimport { Ed25519PublicKey } from \"./publickey.js\";\nconst DEFAULT_ED25519_DERIVATION_PATH = \"m/44'/784'/0'/0'/0'\";\nclass Ed25519Keypair extends Keypair {\n  /**\n   * Create a new Ed25519 keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param keypair Ed25519 keypair\n   */\n  constructor(keypair) {\n    super();\n    if (keypair) {\n      this.keypair = {\n        publicKey: keypair.publicKey,\n        secretKey: keypair.secretKey.slice(0, 32)\n      };\n    } else {\n      const privateKey = ed25519.utils.randomPrivateKey();\n      this.keypair = {\n        publicKey: ed25519.getPublicKey(privateKey),\n        secretKey: privateKey\n      };\n    }\n  }\n  /**\n   * Get the key scheme of the keypair ED25519\n   */\n  getKeyScheme() {\n    return \"ED25519\";\n  }\n  /**\n   * Generate a new random Ed25519 keypair\n   */\n  static generate() {\n    const secretKey = ed25519.utils.randomPrivateKey();\n    return new Ed25519Keypair({\n      publicKey: ed25519.getPublicKey(secretKey),\n      secretKey\n    });\n  }\n  /**\n   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.\n   * This is NOT the private scalar which is result of hashing and bit clamping of\n   * the raw secret key.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key as a byte array or Bech32 secret key string\n   * @param options: skip secret key validation\n   */\n  static fromSecretKey(secretKey, options) {\n    if (typeof secretKey === \"string\") {\n      const decoded = decodeSuiPrivateKey(secretKey);\n      if (decoded.schema !== \"ED25519\") {\n        throw new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);\n      }\n      return this.fromSecretKey(decoded.secretKey, options);\n    }\n    const secretKeyLength = secretKey.length;\n    if (secretKeyLength !== PRIVATE_KEY_SIZE) {\n      throw new Error(`Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`);\n    }\n    const keypair = {\n      publicKey: ed25519.getPublicKey(secretKey),\n      secretKey\n    };\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode(\"sui validation\");\n      const signature = ed25519.sign(signData, secretKey);\n      if (!ed25519.verify(signature, signData, keypair.publicKey)) {\n        throw new Error(\"provided secretKey is invalid\");\n      }\n    }\n    return new Ed25519Keypair(keypair);\n  }\n  /**\n   * The public key for this Ed25519 keypair\n   */\n  getPublicKey() {\n    return new Ed25519PublicKey(this.keypair.publicKey);\n  }\n  /**\n   * The Bech32 secret key string for this Ed25519 keypair\n   */\n  getSecretKey() {\n    return encodeSuiPrivateKey(this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE), this.getKeyScheme());\n  }\n  /**\n   * Return the signature for the provided data using Ed25519.\n   */\n  async sign(data) {\n    return ed25519.sign(data, this.keypair.secretKey);\n  }\n  /**\n   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n   */\n  static deriveKeypair(mnemonics, path) {\n    if (path == null) {\n      path = DEFAULT_ED25519_DERIVATION_PATH;\n    }\n    if (!isValidHardenedPath(path)) {\n      throw new Error(\"Invalid derivation path\");\n    }\n    const {\n      key\n    } = derivePath(path, mnemonicToSeedHex(mnemonics));\n    return Ed25519Keypair.fromSecretKey(key);\n  }\n  /**\n   * Derive Ed25519 keypair from mnemonicSeed and path.\n   *\n   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n   */\n  static deriveKeypairFromSeed(seedHex, path) {\n    if (path == null) {\n      path = DEFAULT_ED25519_DERIVATION_PATH;\n    }\n    if (!isValidHardenedPath(path)) {\n      throw new Error(\"Invalid derivation path\");\n    }\n    const {\n      key\n    } = derivePath(path, seedHex);\n    return Ed25519Keypair.fromSecretKey(key);\n  }\n}\nexport { DEFAULT_ED25519_DERIVATION_PATH, Ed25519Keypair };","map":{"version":3,"names":["ed25519","decodeSuiPrivateKey","encodeSuiPrivateKey","Keypair","PRIVATE_KEY_SIZE","isValidHardenedPath","mnemonicToSeedHex","derivePath","Ed25519PublicKey","DEFAULT_ED25519_DERIVATION_PATH","Ed25519Keypair","constructor","keypair","publicKey","secretKey","slice","privateKey","utils","randomPrivateKey","getPublicKey","getKeyScheme","generate","fromSecretKey","options","decoded","schema","Error","secretKeyLength","length","skipValidation","encoder","TextEncoder","signData","encode","signature","sign","verify","getSecretKey","data","deriveKeypair","mnemonics","path","key","deriveKeypairFromSeed","seedHex"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\keypairs\\ed25519\\keypair.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ed25519 } from '@noble/curves/ed25519';\n\nimport {\n\tdecodeSuiPrivateKey,\n\tencodeSuiPrivateKey,\n\tKeypair,\n\tPRIVATE_KEY_SIZE,\n} from '../../cryptography/keypair.js';\nimport { isValidHardenedPath, mnemonicToSeedHex } from '../../cryptography/mnemonics.js';\nimport type { SignatureScheme } from '../../cryptography/signature-scheme.js';\nimport { derivePath } from './ed25519-hd-key.js';\nimport { Ed25519PublicKey } from './publickey.js';\n\nexport const DEFAULT_ED25519_DERIVATION_PATH = \"m/44'/784'/0'/0'/0'\";\n\n/**\n * Ed25519 Keypair data. The publickey is the 32-byte public key and\n * the secretkey is 64-byte, where the first 32 bytes is the secret\n * key and the last 32 bytes is the public key.\n */\nexport interface Ed25519KeypairData {\n\tpublicKey: Uint8Array;\n\tsecretKey: Uint8Array;\n}\n\n/**\n * An Ed25519 Keypair used for signing transactions.\n */\nexport class Ed25519Keypair extends Keypair {\n\tprivate keypair: Ed25519KeypairData;\n\n\t/**\n\t * Create a new Ed25519 keypair instance.\n\t * Generate random keypair if no {@link Ed25519Keypair} is provided.\n\t *\n\t * @param keypair Ed25519 keypair\n\t */\n\tconstructor(keypair?: Ed25519KeypairData) {\n\t\tsuper();\n\t\tif (keypair) {\n\t\t\tthis.keypair = {\n\t\t\t\tpublicKey: keypair.publicKey,\n\t\t\t\tsecretKey: keypair.secretKey.slice(0, 32),\n\t\t\t};\n\t\t} else {\n\t\t\tconst privateKey = ed25519.utils.randomPrivateKey();\n\t\t\tthis.keypair = {\n\t\t\t\tpublicKey: ed25519.getPublicKey(privateKey),\n\t\t\t\tsecretKey: privateKey,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Get the key scheme of the keypair ED25519\n\t */\n\tgetKeyScheme(): SignatureScheme {\n\t\treturn 'ED25519';\n\t}\n\n\t/**\n\t * Generate a new random Ed25519 keypair\n\t */\n\tstatic generate(): Ed25519Keypair {\n\t\tconst secretKey = ed25519.utils.randomPrivateKey();\n\t\treturn new Ed25519Keypair({\n\t\t\tpublicKey: ed25519.getPublicKey(secretKey),\n\t\t\tsecretKey,\n\t\t});\n\t}\n\n\t/**\n\t * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.\n\t * This is NOT the private scalar which is result of hashing and bit clamping of\n\t * the raw secret key.\n\t *\n\t * @throws error if the provided secret key is invalid and validation is not skipped.\n\t *\n\t * @param secretKey secret key as a byte array or Bech32 secret key string\n\t * @param options: skip secret key validation\n\t */\n\tstatic fromSecretKey(\n\t\tsecretKey: Uint8Array | string,\n\t\toptions?: { skipValidation?: boolean },\n\t): Ed25519Keypair {\n\t\tif (typeof secretKey === 'string') {\n\t\t\tconst decoded = decodeSuiPrivateKey(secretKey);\n\n\t\t\tif (decoded.schema !== 'ED25519') {\n\t\t\t\tthrow new Error(`Expected a ED25519 keypair, got ${decoded.schema}`);\n\t\t\t}\n\n\t\t\treturn this.fromSecretKey(decoded.secretKey, options);\n\t\t}\n\n\t\tconst secretKeyLength = secretKey.length;\n\t\tif (secretKeyLength !== PRIVATE_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`,\n\t\t\t);\n\t\t}\n\t\tconst keypair = {\n\t\t\tpublicKey: ed25519.getPublicKey(secretKey),\n\t\t\tsecretKey,\n\t\t};\n\n\t\tif (!options || !options.skipValidation) {\n\t\t\tconst encoder = new TextEncoder();\n\t\t\tconst signData = encoder.encode('sui validation');\n\t\t\tconst signature = ed25519.sign(signData, secretKey);\n\t\t\tif (!ed25519.verify(signature, signData, keypair.publicKey)) {\n\t\t\t\tthrow new Error('provided secretKey is invalid');\n\t\t\t}\n\t\t}\n\t\treturn new Ed25519Keypair(keypair);\n\t}\n\n\t/**\n\t * The public key for this Ed25519 keypair\n\t */\n\tgetPublicKey(): Ed25519PublicKey {\n\t\treturn new Ed25519PublicKey(this.keypair.publicKey);\n\t}\n\n\t/**\n\t * The Bech32 secret key string for this Ed25519 keypair\n\t */\n\tgetSecretKey(): string {\n\t\treturn encodeSuiPrivateKey(\n\t\t\tthis.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE),\n\t\t\tthis.getKeyScheme(),\n\t\t);\n\t}\n\n\t/**\n\t * Return the signature for the provided data using Ed25519.\n\t */\n\tasync sign(data: Uint8Array) {\n\t\treturn ed25519.sign(data, this.keypair.secretKey);\n\t}\n\n\t/**\n\t * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized\n\t * and validated against the english wordlist.\n\t *\n\t * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n\t * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n\t */\n\tstatic deriveKeypair(mnemonics: string, path?: string): Ed25519Keypair {\n\t\tif (path == null) {\n\t\t\tpath = DEFAULT_ED25519_DERIVATION_PATH;\n\t\t}\n\t\tif (!isValidHardenedPath(path)) {\n\t\t\tthrow new Error('Invalid derivation path');\n\t\t}\n\t\tconst { key } = derivePath(path, mnemonicToSeedHex(mnemonics));\n\n\t\treturn Ed25519Keypair.fromSecretKey(key);\n\t}\n\n\t/**\n\t * Derive Ed25519 keypair from mnemonicSeed and path.\n\t *\n\t * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n\t * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n\t */\n\tstatic deriveKeypairFromSeed(seedHex: string, path?: string): Ed25519Keypair {\n\t\tif (path == null) {\n\t\t\tpath = DEFAULT_ED25519_DERIVATION_PATH;\n\t\t}\n\t\tif (!isValidHardenedPath(path)) {\n\t\t\tthrow new Error('Invalid derivation path');\n\t\t}\n\t\tconst { key } = derivePath(path, seedHex);\n\n\t\treturn Ed25519Keypair.fromSecretKey(key);\n\t}\n}\n"],"mappings":"AAGA,SAASA,OAAA,QAAe;AAExB,SACCC,mBAAA,EACAC,mBAAA,EACAC,OAAA,EACAC,gBAAA,QACM;AACP,SAASC,mBAAA,EAAqBC,iBAAA,QAAyB;AAEvD,SAASC,UAAA,QAAkB;AAC3B,SAASC,gBAAA,QAAwB;AAE1B,MAAMC,+BAAA,GAAkC;AAexC,MAAMC,cAAA,SAAuBP,OAAA,CAAQ;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAS3CQ,YAAYC,OAAA,EAA8B;IACzC,MAAM;IACN,IAAIA,OAAA,EAAS;MACZ,KAAKA,OAAA,GAAU;QACdC,SAAA,EAAWD,OAAA,CAAQC,SAAA;QACnBC,SAAA,EAAWF,OAAA,CAAQE,SAAA,CAAUC,KAAA,CAAM,GAAG,EAAE;MACzC;IACD,OAAO;MACN,MAAMC,UAAA,GAAahB,OAAA,CAAQiB,KAAA,CAAMC,gBAAA,CAAiB;MAClD,KAAKN,OAAA,GAAU;QACdC,SAAA,EAAWb,OAAA,CAAQmB,YAAA,CAAaH,UAAU;QAC1CF,SAAA,EAAWE;MACZ;IACD;EACD;EAAA;AAAA;AAAA;EAKAI,aAAA,EAAgC;IAC/B,OAAO;EACR;EAAA;AAAA;AAAA;EAKA,OAAOC,SAAA,EAA2B;IACjC,MAAMP,SAAA,GAAYd,OAAA,CAAQiB,KAAA,CAAMC,gBAAA,CAAiB;IACjD,OAAO,IAAIR,cAAA,CAAe;MACzBG,SAAA,EAAWb,OAAA,CAAQmB,YAAA,CAAaL,SAAS;MACzCA;IACD,CAAC;EACF;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYA,OAAOQ,cACNR,SAAA,EACAS,OAAA,EACiB;IACjB,IAAI,OAAOT,SAAA,KAAc,UAAU;MAClC,MAAMU,OAAA,GAAUvB,mBAAA,CAAoBa,SAAS;MAE7C,IAAIU,OAAA,CAAQC,MAAA,KAAW,WAAW;QACjC,MAAM,IAAIC,KAAA,CAAM,mCAAmCF,OAAA,CAAQC,MAAM,EAAE;MACpE;MAEA,OAAO,KAAKH,aAAA,CAAcE,OAAA,CAAQV,SAAA,EAAWS,OAAO;IACrD;IAEA,MAAMI,eAAA,GAAkBb,SAAA,CAAUc,MAAA;IAClC,IAAID,eAAA,KAAoBvB,gBAAA,EAAkB;MACzC,MAAM,IAAIsB,KAAA,CACT,kCAAkCtB,gBAAgB,eAAeuB,eAAe,GACjF;IACD;IACA,MAAMf,OAAA,GAAU;MACfC,SAAA,EAAWb,OAAA,CAAQmB,YAAA,CAAaL,SAAS;MACzCA;IACD;IAEA,IAAI,CAACS,OAAA,IAAW,CAACA,OAAA,CAAQM,cAAA,EAAgB;MACxC,MAAMC,OAAA,GAAU,IAAIC,WAAA,CAAY;MAChC,MAAMC,QAAA,GAAWF,OAAA,CAAQG,MAAA,CAAO,gBAAgB;MAChD,MAAMC,SAAA,GAAYlC,OAAA,CAAQmC,IAAA,CAAKH,QAAA,EAAUlB,SAAS;MAClD,IAAI,CAACd,OAAA,CAAQoC,MAAA,CAAOF,SAAA,EAAWF,QAAA,EAAUpB,OAAA,CAAQC,SAAS,GAAG;QAC5D,MAAM,IAAIa,KAAA,CAAM,+BAA+B;MAChD;IACD;IACA,OAAO,IAAIhB,cAAA,CAAeE,OAAO;EAClC;EAAA;AAAA;AAAA;EAKAO,aAAA,EAAiC;IAChC,OAAO,IAAIX,gBAAA,CAAiB,KAAKI,OAAA,CAAQC,SAAS;EACnD;EAAA;AAAA;AAAA;EAKAwB,aAAA,EAAuB;IACtB,OAAOnC,mBAAA,CACN,KAAKU,OAAA,CAAQE,SAAA,CAAUC,KAAA,CAAM,GAAGX,gBAAgB,GAChD,KAAKgB,YAAA,CAAa,CACnB;EACD;EAAA;AAAA;AAAA;EAKA,MAAMe,KAAKG,IAAA,EAAkB;IAC5B,OAAOtC,OAAA,CAAQmC,IAAA,CAAKG,IAAA,EAAM,KAAK1B,OAAA,CAAQE,SAAS;EACjD;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EASA,OAAOyB,cAAcC,SAAA,EAAmBC,IAAA,EAA+B;IACtE,IAAIA,IAAA,IAAQ,MAAM;MACjBA,IAAA,GAAOhC,+BAAA;IACR;IACA,IAAI,CAACJ,mBAAA,CAAoBoC,IAAI,GAAG;MAC/B,MAAM,IAAIf,KAAA,CAAM,yBAAyB;IAC1C;IACA,MAAM;MAAEgB;IAAI,IAAInC,UAAA,CAAWkC,IAAA,EAAMnC,iBAAA,CAAkBkC,SAAS,CAAC;IAE7D,OAAO9B,cAAA,CAAeY,aAAA,CAAcoB,GAAG;EACxC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,OAAOC,sBAAsBC,OAAA,EAAiBH,IAAA,EAA+B;IAC5E,IAAIA,IAAA,IAAQ,MAAM;MACjBA,IAAA,GAAOhC,+BAAA;IACR;IACA,IAAI,CAACJ,mBAAA,CAAoBoC,IAAI,GAAG;MAC/B,MAAM,IAAIf,KAAA,CAAM,yBAAyB;IAC1C;IACA,MAAM;MAAEgB;IAAI,IAAInC,UAAA,CAAWkC,IAAA,EAAMG,OAAO;IAExC,OAAOlC,cAAA,CAAeY,aAAA,CAAcoB,GAAG;EACxC;AACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}