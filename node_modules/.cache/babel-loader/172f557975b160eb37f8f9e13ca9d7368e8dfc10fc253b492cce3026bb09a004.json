{"ast":null,"code":"import { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from \"@mysten/bcs\";\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nfunction unsafe_u64(options) {\n  return bcs.u64({\n    name: \"unsafe_u64\",\n    ...options\n  }).transform({\n    input: val => val,\n    output: val => Number(val)\n  });\n}\nfunction optionEnum(type) {\n  return bcs.enum(\"Option\", {\n    None: null,\n    Some: type\n  });\n}\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n  validate: val => {\n    const address = typeof val === \"string\" ? val : toHex(val);\n    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n      throw new Error(`Invalid Sui address ${address}`);\n    }\n  },\n  input: val => typeof val === \"string\" ? fromHex(normalizeSuiAddress(val)) : val,\n  output: val => normalizeSuiAddress(toHex(val))\n});\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n  name: \"ObjectDigest\",\n  input: value => fromBase58(value),\n  output: value => toBase58(new Uint8Array(value)),\n  validate: value => {\n    if (fromBase58(value).length !== 32) {\n      throw new Error(\"ObjectDigest must be 32 bytes\");\n    }\n  }\n});\nconst SuiObjectRef = bcs.struct(\"SuiObjectRef\", {\n  objectId: Address,\n  version: bcs.u64(),\n  digest: ObjectDigest\n});\nconst SharedObjectRef = bcs.struct(\"SharedObjectRef\", {\n  objectId: Address,\n  initialSharedVersion: bcs.u64(),\n  mutable: bcs.bool()\n});\nconst ObjectArg = bcs.enum(\"ObjectArg\", {\n  ImmOrOwnedObject: SuiObjectRef,\n  SharedObject: SharedObjectRef,\n  Receiving: SuiObjectRef\n});\nconst CallArg = bcs.enum(\"CallArg\", {\n  Pure: bcs.struct(\"Pure\", {\n    bytes: bcs.vector(bcs.u8()).transform({\n      input: val => typeof val === \"string\" ? fromBase64(val) : val,\n      output: val => toBase64(new Uint8Array(val))\n    })\n  }),\n  Object: ObjectArg\n});\nconst InnerTypeTag = bcs.enum(\"TypeTag\", {\n  bool: null,\n  u8: null,\n  u64: null,\n  u128: null,\n  address: null,\n  signer: null,\n  vector: bcs.lazy(() => InnerTypeTag),\n  struct: bcs.lazy(() => StructTag),\n  u16: null,\n  u32: null,\n  u256: null\n});\nconst TypeTag = InnerTypeTag.transform({\n  input: typeTag => typeof typeTag === \"string\" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n  output: typeTag => TypeTagSerializer.tagToString(typeTag)\n});\nconst Argument = bcs.enum(\"Argument\", {\n  GasCoin: null,\n  Input: bcs.u16(),\n  Result: bcs.u16(),\n  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])\n});\nconst ProgrammableMoveCall = bcs.struct(\"ProgrammableMoveCall\", {\n  package: Address,\n  module: bcs.string(),\n  function: bcs.string(),\n  typeArguments: bcs.vector(TypeTag),\n  arguments: bcs.vector(Argument)\n});\nconst Command = bcs.enum(\"Command\", {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: ProgrammableMoveCall,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: bcs.struct(\"TransferObjects\", {\n    objects: bcs.vector(Argument),\n    address: Argument\n  }),\n  // /**\n  //  * Split `amount` from a `coin`.\n  //  */\n  SplitCoins: bcs.struct(\"SplitCoins\", {\n    coin: Argument,\n    amounts: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Merge Vector of Coins (`sources`) into a `destination`.\n  //  */\n  MergeCoins: bcs.struct(\"MergeCoins\", {\n    destination: Argument,\n    sources: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Publish a Move module.\n  //  */\n  Publish: bcs.struct(\"Publish\", {\n    modules: bcs.vector(bcs.vector(bcs.u8()).transform({\n      input: val => typeof val === \"string\" ? fromBase64(val) : val,\n      output: val => toBase64(new Uint8Array(val))\n    })),\n    dependencies: bcs.vector(Address)\n  }),\n  // /**\n  //  * Build a vector of objects using the input arguments.\n  //  * It is impossible to export construct a `vector<T: key>` otherwise,\n  //  * so this call serves a utility function.\n  //  */\n  MakeMoveVec: bcs.struct(\"MakeMoveVec\", {\n    type: optionEnum(TypeTag).transform({\n      input: val => val === null ? {\n        None: true\n      } : {\n        Some: val\n      },\n      output: val => val.Some ?? null\n    }),\n    elements: bcs.vector(Argument)\n  }),\n  Upgrade: bcs.struct(\"Upgrade\", {\n    modules: bcs.vector(bcs.vector(bcs.u8()).transform({\n      input: val => typeof val === \"string\" ? fromBase64(val) : val,\n      output: val => toBase64(new Uint8Array(val))\n    })),\n    dependencies: bcs.vector(Address),\n    package: Address,\n    ticket: Argument\n  })\n});\nconst ProgrammableTransaction = bcs.struct(\"ProgrammableTransaction\", {\n  inputs: bcs.vector(CallArg),\n  commands: bcs.vector(Command)\n});\nconst TransactionKind = bcs.enum(\"TransactionKind\", {\n  ProgrammableTransaction,\n  ChangeEpoch: null,\n  Genesis: null,\n  ConsensusCommitPrologue: null\n});\nconst TransactionExpiration = bcs.enum(\"TransactionExpiration\", {\n  None: null,\n  Epoch: unsafe_u64()\n});\nconst StructTag = bcs.struct(\"StructTag\", {\n  address: Address,\n  module: bcs.string(),\n  name: bcs.string(),\n  typeParams: bcs.vector(InnerTypeTag)\n});\nconst GasData = bcs.struct(\"GasData\", {\n  payment: bcs.vector(SuiObjectRef),\n  owner: Address,\n  price: bcs.u64(),\n  budget: bcs.u64()\n});\nconst TransactionDataV1 = bcs.struct(\"TransactionDataV1\", {\n  kind: TransactionKind,\n  sender: Address,\n  gasData: GasData,\n  expiration: TransactionExpiration\n});\nconst TransactionData = bcs.enum(\"TransactionData\", {\n  V1: TransactionDataV1\n});\nconst IntentScope = bcs.enum(\"IntentScope\", {\n  TransactionData: null,\n  TransactionEffects: null,\n  CheckpointSummary: null,\n  PersonalMessage: null\n});\nconst IntentVersion = bcs.enum(\"IntentVersion\", {\n  V0: null\n});\nconst AppId = bcs.enum(\"AppId\", {\n  Sui: null\n});\nconst Intent = bcs.struct(\"Intent\", {\n  scope: IntentScope,\n  version: IntentVersion,\n  appId: AppId\n});\nfunction IntentMessage(T) {\n  return bcs.struct(`IntentMessage<${T.name}>`, {\n    intent: Intent,\n    value: T\n  });\n}\nconst CompressedSignature = bcs.enum(\"CompressedSignature\", {\n  ED25519: bcs.fixedArray(64, bcs.u8()),\n  Secp256k1: bcs.fixedArray(64, bcs.u8()),\n  Secp256r1: bcs.fixedArray(64, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst PublicKey = bcs.enum(\"PublicKey\", {\n  ED25519: bcs.fixedArray(32, bcs.u8()),\n  Secp256k1: bcs.fixedArray(33, bcs.u8()),\n  Secp256r1: bcs.fixedArray(33, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst MultiSigPkMap = bcs.struct(\"MultiSigPkMap\", {\n  pubKey: PublicKey,\n  weight: bcs.u8()\n});\nconst MultiSigPublicKey = bcs.struct(\"MultiSigPublicKey\", {\n  pk_map: bcs.vector(MultiSigPkMap),\n  threshold: bcs.u16()\n});\nconst MultiSig = bcs.struct(\"MultiSig\", {\n  sigs: bcs.vector(CompressedSignature),\n  bitmap: bcs.u16(),\n  multisig_pk: MultiSigPublicKey\n});\nconst base64String = bcs.vector(bcs.u8()).transform({\n  input: val => typeof val === \"string\" ? fromBase64(val) : val,\n  output: val => toBase64(new Uint8Array(val))\n});\nconst SenderSignedTransaction = bcs.struct(\"SenderSignedTransaction\", {\n  intentMessage: IntentMessage(TransactionData),\n  txSignatures: bcs.vector(base64String)\n});\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n  name: \"SenderSignedData\"\n});\nconst PasskeyAuthenticator = bcs.struct(\"PasskeyAuthenticator\", {\n  authenticatorData: bcs.vector(bcs.u8()),\n  clientDataJson: bcs.string(),\n  userSignature: bcs.vector(bcs.u8())\n});\nexport { Address, AppId, Argument, CallArg, Command, CompressedSignature, GasData, Intent, IntentMessage, IntentScope, IntentVersion, MultiSig, MultiSigPkMap, MultiSigPublicKey, ObjectArg, ObjectDigest, PasskeyAuthenticator, ProgrammableMoveCall, ProgrammableTransaction, PublicKey, SenderSignedData, SenderSignedTransaction, SharedObjectRef, StructTag, SuiObjectRef, TransactionData, TransactionDataV1, TransactionExpiration, TransactionKind, TypeTag, base64String };","map":{"version":3,"names":["bcs","fromBase58","fromBase64","fromHex","toBase58","toBase64","toHex","isValidSuiAddress","normalizeSuiAddress","SUI_ADDRESS_LENGTH","TypeTagSerializer","unsafe_u64","options","u64","name","transform","input","val","output","Number","optionEnum","type","enum","None","Some","Address","bytes","validate","address","Error","ObjectDigest","vector","u8","value","Uint8Array","length","SuiObjectRef","struct","objectId","version","digest","SharedObjectRef","initialSharedVersion","mutable","bool","ObjectArg","ImmOrOwnedObject","SharedObject","Receiving","CallArg","Pure","Object","InnerTypeTag","u128","signer","lazy","StructTag","u16","u32","u256","TypeTag","typeTag","parseFromStr","tagToString","Argument","GasCoin","Input","Result","NestedResult","tuple","ProgrammableMoveCall","package","module","string","function","typeArguments","arguments","Command","MoveCall","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","destination","sources","Publish","modules","dependencies","MakeMoveVec","elements","Upgrade","ticket","ProgrammableTransaction","inputs","commands","TransactionKind","ChangeEpoch","Genesis","ConsensusCommitPrologue","TransactionExpiration","Epoch","typeParams","GasData","payment","owner","price","budget","TransactionDataV1","kind","sender","gasData","expiration","TransactionData","V1","IntentScope","TransactionEffects","CheckpointSummary","PersonalMessage","IntentVersion","V0","AppId","Sui","Intent","scope","appId","IntentMessage","T","intent","CompressedSignature","ED25519","fixedArray","Secp256k1","Secp256r1","ZkLogin","PublicKey","MultiSigPkMap","pubKey","weight","MultiSigPublicKey","pk_map","threshold","MultiSig","sigs","bitmap","multisig_pk","base64String","SenderSignedTransaction","intentMessage","txSignatures","SenderSignedData","PasskeyAuthenticator","authenticatorData","clientDataJson","userSignature"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\bcs\\bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.vector(bcs.u8()).transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.vector(bcs.u8()),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.vector(bcs.u8()),\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}