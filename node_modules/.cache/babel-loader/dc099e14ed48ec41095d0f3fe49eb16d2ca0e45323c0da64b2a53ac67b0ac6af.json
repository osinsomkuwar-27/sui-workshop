{"ast":null,"code":"import { ulebEncode } from \"./uleb.js\";\nimport { encodeStr } from \"./utils.js\";\nclass BcsWriter {\n  constructor({\n    initialSize = 1024,\n    maxSize = Infinity,\n    allocateSize = 1024\n  } = {}) {\n    this.bytePosition = 0;\n    this.size = initialSize;\n    this.maxSize = maxSize;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(initialSize));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n}\nfunction toLittleEndian(bigint, size) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\nexport { BcsWriter };","map":{"version":3,"names":["ulebEncode","encodeStr","BcsWriter","constructor","initialSize","maxSize","Infinity","allocateSize","bytePosition","size","dataView","DataView","ArrayBuffer","ensureSizeOrGrow","bytes","requiredSize","nextSize","Math","min","Error","nextBuffer","Uint8Array","set","buffer","shift","write8","value","setUint8","Number","write16","setUint16","write32","setUint32","write64","toLittleEndian","BigInt","forEach","el","write128","write256","writeULEB","writeVec","vector","cb","length","Array","from","i","Symbol","iterator","getUint8","toBytes","slice","toString","encoding","bigint","result"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\bcs\\src\\writer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}