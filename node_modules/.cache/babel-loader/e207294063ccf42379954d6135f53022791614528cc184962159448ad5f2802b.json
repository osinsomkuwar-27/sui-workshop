{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _data, _client, _legacyAddress, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn;\nimport { fromBase64, toBase64, toHex } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { PublicKey } from \"../cryptography/publickey.js\";\nimport { SIGNATURE_SCHEME_TO_FLAG } from \"../cryptography/signature-scheme.js\";\nimport { SuiGraphQLClient } from \"../graphql/client.js\";\nimport { graphql } from \"../graphql/schemas/latest/index.js\";\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { extractClaimValue } from \"./jwt-utils.js\";\nimport { parseZkLoginSignature } from \"./signature.js\";\nimport { normalizeZkLoginIssuer, toBigEndianBytes, toPaddedBigEndianBytes } from \"./utils.js\";\nconst _ZkLoginPublicIdentifier = class _ZkLoginPublicIdentifier extends PublicKey {\n  /**\n   * Create a new ZkLoginPublicIdentifier object\n   * @param value zkLogin public identifier as buffer or base-64 encoded string\n   */\n  constructor(value, {\n    client\n  } = {}) {\n    super();\n    __privateAdd(this, _ZkLoginPublicIdentifier_instances);\n    __privateAdd(this, _data);\n    __privateAdd(this, _client);\n    __privateAdd(this, _legacyAddress);\n    __privateSet(this, _client, client);\n    if (typeof value === \"string\") {\n      __privateSet(this, _data, fromBase64(value));\n    } else if (value instanceof Uint8Array) {\n      __privateSet(this, _data, value);\n    } else {\n      __privateSet(this, _data, Uint8Array.from(value));\n    }\n    __privateSet(this, _legacyAddress, __privateGet(this, _data).length !== __privateGet(this, _data)[0] + 1 + 32);\n    if (__privateGet(this, _legacyAddress)) {\n      __privateSet(this, _data, normalizeZkLoginPublicKeyBytes(__privateGet(this, _data)));\n    }\n  }\n  static fromProof(address, proof) {\n    const {\n      issBase64Details,\n      addressSeed\n    } = proof;\n    const iss = extractClaimValue(issBase64Details, \"iss\");\n    const legacyPublicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {\n      legacyAddress: true\n    });\n    if (legacyPublicKey.toSuiAddress() === address) {\n      return legacyPublicKey;\n    }\n    const publicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {\n      legacyAddress: false\n    });\n    if (publicKey.toSuiAddress() !== address) {\n      throw new Error(\"Proof does not match address\");\n    }\n    return publicKey;\n  }\n  /**\n   * Checks if two zkLogin public identifiers are equal\n   */\n  equals(publicKey) {\n    return super.equals(publicKey);\n  }\n  toSuiAddress() {\n    if (__privateGet(this, _legacyAddress)) {\n      return __privateMethod(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);\n    }\n    return super.toSuiAddress();\n  }\n  /**\n   * Return the byte array representation of the zkLogin public identifier\n   */\n  toRawBytes() {\n    return __privateGet(this, _data);\n  }\n  /**\n   * Return the Sui address associated with this ZkLogin public identifier\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"ZkLogin\"];\n  }\n  /**\n   * Verifies that the signature is valid for for the provided message\n   */\n  async verify(_message, _signature) {\n    throw Error(\"does not support\");\n  }\n  /**\n   * Verifies that the signature is valid for for the provided PersonalMessage\n   */\n  verifyPersonalMessage(message, signature) {\n    const parsedSignature = parseSerializedZkLoginSignature(signature);\n    const address = new _ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n    return graphqlVerifyZkLoginSignature({\n      address,\n      bytes: toBase64(message),\n      signature: parsedSignature.serializedSignature,\n      intentScope: \"PERSONAL_MESSAGE\",\n      client: __privateGet(this, _client)\n    });\n  }\n  /**\n   * Verifies that the signature is valid for for the provided Transaction\n   */\n  verifyTransaction(transaction, signature) {\n    const parsedSignature = parseSerializedZkLoginSignature(signature);\n    const address = new _ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n    return graphqlVerifyZkLoginSignature({\n      address,\n      bytes: toBase64(transaction),\n      signature: parsedSignature.serializedSignature,\n      intentScope: \"TRANSACTION_DATA\",\n      client: __privateGet(this, _client)\n    });\n  }\n  /**\n   * Verifies that the public key is associated with the provided address\n   */\n  verifyAddress(address) {\n    return address === super.toSuiAddress() || address === __privateMethod(this, _ZkLoginPublicIdentifier_instances, toLegacyAddress_fn).call(this);\n  }\n};\n_data = new WeakMap();\n_client = new WeakMap();\n_legacyAddress = new WeakMap();\n_ZkLoginPublicIdentifier_instances = new WeakSet();\ntoLegacyAddress_fn = function () {\n  const legacyBytes = normalizeZkLoginPublicKeyBytes(__privateGet(this, _data), true);\n  const addressBytes = new Uint8Array(legacyBytes.length + 1);\n  addressBytes[0] = this.flag();\n  addressBytes.set(legacyBytes, 1);\n  return normalizeSuiAddress(bytesToHex(blake2b(addressBytes, {\n    dkLen: 32\n  })).slice(0, SUI_ADDRESS_LENGTH * 2));\n};\nlet ZkLoginPublicIdentifier = _ZkLoginPublicIdentifier;\nfunction toZkLoginPublicIdentifier(addressSeed, iss, options) {\n  const addressSeedBytesBigEndian = options?.legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);\n  const issBytes = new TextEncoder().encode(normalizeZkLoginIssuer(iss));\n  const tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);\n  tmp.set([issBytes.length], 0);\n  tmp.set(issBytes, 1);\n  tmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);\n  return new ZkLoginPublicIdentifier(tmp, options);\n}\nconst VerifyZkLoginSignatureQuery = graphql(`\n\tquery Zklogin(\n\t\t$bytes: Base64!\n\t\t$signature: Base64!\n\t\t$intentScope: ZkLoginIntentScope!\n\t\t$author: SuiAddress!\n\t) {\n\t\tverifyZkloginSignature(\n\t\t\tbytes: $bytes\n\t\t\tsignature: $signature\n\t\t\tintentScope: $intentScope\n\t\t\tauthor: $author\n\t\t) {\n\t\t\tsuccess\n\t\t\terrors\n\t\t}\n\t}\n`);\nfunction normalizeZkLoginPublicKeyBytes(bytes, legacyAddress = false) {\n  const issByteLength = bytes[0] + 1;\n  const addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);\n  const seedBytes = legacyAddress ? toBigEndianBytes(addressSeed, 32) : toPaddedBigEndianBytes(addressSeed, 32);\n  const data = new Uint8Array(issByteLength + seedBytes.length);\n  data.set(bytes.slice(0, issByteLength), 0);\n  data.set(seedBytes, issByteLength);\n  return data;\n}\nasync function graphqlVerifyZkLoginSignature({\n  address,\n  bytes,\n  signature,\n  intentScope,\n  client = new SuiGraphQLClient({\n    url: \"https://sui-mainnet.mystenlabs.com/graphql\"\n  })\n}) {\n  const resp = await client.query({\n    query: VerifyZkLoginSignatureQuery,\n    variables: {\n      bytes,\n      signature,\n      intentScope,\n      author: address\n    }\n  });\n  return resp.data?.verifyZkloginSignature.success === true && resp.data?.verifyZkloginSignature.errors.length === 0;\n}\nfunction parseSerializedZkLoginSignature(signature) {\n  const bytes = typeof signature === \"string\" ? fromBase64(signature) : signature;\n  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {\n    throw new Error(\"Invalid signature scheme\");\n  }\n  const signatureBytes = bytes.slice(1);\n  const {\n    inputs,\n    maxEpoch,\n    userSignature\n  } = parseZkLoginSignature(signatureBytes);\n  const {\n    issBase64Details,\n    addressSeed\n  } = inputs;\n  const iss = extractClaimValue(issBase64Details, \"iss\");\n  const publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);\n  return {\n    serializedSignature: toBase64(bytes),\n    signatureScheme: \"ZkLogin\",\n    zkLogin: {\n      inputs,\n      maxEpoch,\n      userSignature,\n      iss,\n      addressSeed: BigInt(addressSeed)\n    },\n    signature: bytes,\n    publicKey: publicIdentifer.toRawBytes()\n  };\n}\nexport { ZkLoginPublicIdentifier, parseSerializedZkLoginSignature, toZkLoginPublicIdentifier };","map":{"version":3,"names":["_data","_client","_legacyAddress","_ZkLoginPublicIdentifier_instances","toLegacyAddress_fn","fromBase64","toBase64","toHex","blake2b","bytesToHex","PublicKey","SIGNATURE_SCHEME_TO_FLAG","SuiGraphQLClient","graphql","normalizeSuiAddress","SUI_ADDRESS_LENGTH","extractClaimValue","parseZkLoginSignature","normalizeZkLoginIssuer","toBigEndianBytes","toPaddedBigEndianBytes","_ZkLoginPublicIdentifier","constructor","value","client","__privateAdd","__privateSet","Uint8Array","from","__privateGet","length","normalizeZkLoginPublicKeyBytes","fromProof","address","proof","issBase64Details","addressSeed","iss","legacyPublicKey","toZkLoginPublicIdentifier","BigInt","legacyAddress","toSuiAddress","publicKey","Error","equals","__privateMethod","call","toRawBytes","flag","verify","_message","_signature","verifyPersonalMessage","message","signature","parsedSignature","parseSerializedZkLoginSignature","graphqlVerifyZkLoginSignature","bytes","serializedSignature","intentScope","verifyTransaction","transaction","verifyAddress","WeakMap","WeakSet","legacyBytes","addressBytes","set","dkLen","slice","ZkLoginPublicIdentifier","options","addressSeedBytesBigEndian","issBytes","TextEncoder","encode","tmp","VerifyZkLoginSignatureQuery","issByteLength","seedBytes","data","url","resp","query","variables","author","verifyZkloginSignature","success","errors","ZkLogin","signatureBytes","inputs","maxEpoch","userSignature","publicIdentifer","signatureScheme","zkLogin"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\zklogin\\publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64, toHex } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { PublicKey } from '../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../cryptography/signature-scheme.js';\nimport { SuiGraphQLClient } from '../graphql/client.js';\nimport { graphql } from '../graphql/schemas/latest/index.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport type { ZkLoginSignatureInputs } from './bcs.js';\nimport { extractClaimValue } from './jwt-utils.js';\nimport { parseZkLoginSignature } from './signature.js';\nimport { normalizeZkLoginIssuer, toBigEndianBytes, toPaddedBigEndianBytes } from './utils.js';\n\n/**\n * A zkLogin public identifier\n */\nexport class ZkLoginPublicIdentifier extends PublicKey {\n\t#data: Uint8Array;\n\t#client?: SuiGraphQLClient;\n\t#legacyAddress: boolean;\n\n\t/**\n\t * Create a new ZkLoginPublicIdentifier object\n\t * @param value zkLogin public identifier as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData, { client }: { client?: SuiGraphQLClient } = {}) {\n\t\tsuper();\n\n\t\tthis.#client = client;\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.#data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.#data = value;\n\t\t} else {\n\t\t\tthis.#data = Uint8Array.from(value);\n\t\t}\n\t\tthis.#legacyAddress = this.#data.length !== this.#data[0] + 1 + 32;\n\n\t\tif (this.#legacyAddress) {\n\t\t\tthis.#data = normalizeZkLoginPublicKeyBytes(this.#data);\n\t\t}\n\t}\n\n\tstatic fromProof(address: string, proof: ZkLoginSignatureInputs) {\n\t\tconst { issBase64Details, addressSeed } = proof;\n\t\tconst iss = extractClaimValue<string>(issBase64Details, 'iss');\n\n\t\tconst legacyPublicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {\n\t\t\tlegacyAddress: true,\n\t\t});\n\n\t\tif (legacyPublicKey.toSuiAddress() === address) {\n\t\t\treturn legacyPublicKey;\n\t\t}\n\n\t\tconst publicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {\n\t\t\tlegacyAddress: false,\n\t\t});\n\n\t\tif (publicKey.toSuiAddress() !== address) {\n\t\t\tthrow new Error('Proof does not match address');\n\t\t}\n\n\t\treturn publicKey;\n\t}\n\n\t/**\n\t * Checks if two zkLogin public identifiers are equal\n\t */\n\toverride equals(publicKey: ZkLoginPublicIdentifier): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\toverride toSuiAddress(): string {\n\t\tif (this.#legacyAddress) {\n\t\t\treturn this.#toLegacyAddress();\n\t\t}\n\n\t\treturn super.toSuiAddress();\n\t}\n\n\t#toLegacyAddress() {\n\t\tconst legacyBytes = normalizeZkLoginPublicKeyBytes(this.#data, true);\n\t\tconst addressBytes = new Uint8Array(legacyBytes.length + 1);\n\t\taddressBytes[0] = this.flag();\n\t\taddressBytes.set(legacyBytes, 1);\n\t\treturn normalizeSuiAddress(\n\t\t\tbytesToHex(blake2b(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n\t\t);\n\t}\n\n\t/**\n\t * Return the byte array representation of the zkLogin public identifier\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this ZkLogin public identifier\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['ZkLogin'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(_message: Uint8Array, _signature: Uint8Array | string): Promise<boolean> {\n\t\tthrow Error('does not support');\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(message),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'PERSONAL_MESSAGE',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided Transaction\n\t */\n\tverifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(transaction),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'TRANSACTION_DATA',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n\n\t/**\n\t * Verifies that the public key is associated with the provided address\n\t */\n\toverride verifyAddress(address: string): boolean {\n\t\treturn address === super.toSuiAddress() || address === this.#toLegacyAddress();\n\t}\n}\n\n// Derive the public identifier for zklogin based on address seed and iss.\nexport function toZkLoginPublicIdentifier(\n\taddressSeed: bigint,\n\tiss: string,\n\toptions?: { client?: SuiGraphQLClient; legacyAddress?: boolean },\n): ZkLoginPublicIdentifier {\n\t// Consists of iss_bytes_len || iss_bytes || padded_32_byte_address_seed.\n\tconst addressSeedBytesBigEndian = options?.legacyAddress\n\t\t? toBigEndianBytes(addressSeed, 32)\n\t\t: toPaddedBigEndianBytes(addressSeed, 32);\n\n\tconst issBytes = new TextEncoder().encode(normalizeZkLoginIssuer(iss));\n\tconst tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);\n\ttmp.set([issBytes.length], 0);\n\ttmp.set(issBytes, 1);\n\ttmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);\n\treturn new ZkLoginPublicIdentifier(tmp, options);\n}\n\nconst VerifyZkLoginSignatureQuery = graphql(`\n\tquery Zklogin(\n\t\t$bytes: Base64!\n\t\t$signature: Base64!\n\t\t$intentScope: ZkLoginIntentScope!\n\t\t$author: SuiAddress!\n\t) {\n\t\tverifyZkloginSignature(\n\t\t\tbytes: $bytes\n\t\t\tsignature: $signature\n\t\t\tintentScope: $intentScope\n\t\t\tauthor: $author\n\t\t) {\n\t\t\tsuccess\n\t\t\terrors\n\t\t}\n\t}\n`);\n\nfunction normalizeZkLoginPublicKeyBytes(bytes: Uint8Array, legacyAddress = false) {\n\tconst issByteLength = bytes[0] + 1;\n\tconst addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);\n\tconst seedBytes = legacyAddress\n\t\t? toBigEndianBytes(addressSeed, 32)\n\t\t: toPaddedBigEndianBytes(addressSeed, 32);\n\tconst data = new Uint8Array(issByteLength + seedBytes.length);\n\tdata.set(bytes.slice(0, issByteLength), 0);\n\tdata.set(seedBytes, issByteLength);\n\treturn data;\n}\n\nasync function graphqlVerifyZkLoginSignature({\n\taddress,\n\tbytes,\n\tsignature,\n\tintentScope,\n\tclient = new SuiGraphQLClient({\n\t\turl: 'https://sui-mainnet.mystenlabs.com/graphql',\n\t}),\n}: {\n\taddress: string;\n\tbytes: string;\n\tsignature: string;\n\tintentScope: 'PERSONAL_MESSAGE' | 'TRANSACTION_DATA';\n\tclient?: SuiGraphQLClient;\n}) {\n\tconst resp = await client.query({\n\t\tquery: VerifyZkLoginSignatureQuery,\n\t\tvariables: {\n\t\t\tbytes,\n\t\t\tsignature,\n\t\t\tintentScope,\n\t\t\tauthor: address,\n\t\t},\n\t});\n\n\treturn (\n\t\tresp.data?.verifyZkloginSignature.success === true &&\n\t\tresp.data?.verifyZkloginSignature.errors.length === 0\n\t);\n}\n\nexport function parseSerializedZkLoginSignature(signature: Uint8Array | string) {\n\tconst bytes = typeof signature === 'string' ? fromBase64(signature) : signature;\n\n\tif (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {\n\t\tthrow new Error('Invalid signature scheme');\n\t}\n\n\tconst signatureBytes = bytes.slice(1);\n\tconst { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);\n\tconst { issBase64Details, addressSeed } = inputs;\n\tconst iss = extractClaimValue<string>(issBase64Details, 'iss');\n\tconst publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);\n\treturn {\n\t\tserializedSignature: toBase64(bytes),\n\t\tsignatureScheme: 'ZkLogin' as const,\n\t\tzkLogin: {\n\t\t\tinputs,\n\t\t\tmaxEpoch,\n\t\t\tuserSignature,\n\t\t\tiss,\n\t\t\taddressSeed: BigInt(addressSeed),\n\t\t},\n\t\tsignature: bytes,\n\t\tpublicKey: publicIdentifer.toRawBytes(),\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}