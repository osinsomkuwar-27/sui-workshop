{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _caches, _cache, _onEffects;\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nclass AsyncCache {\n  async getObject(id) {\n    const [owned, shared] = await Promise.all([this.get(\"OwnedObject\", id), this.get(\"SharedOrImmutableObject\", id)]);\n    return owned ?? shared ?? null;\n  }\n  async getObjects(ids) {\n    return Promise.all([...ids.map(id => this.getObject(id))]);\n  }\n  async addObject(object) {\n    if (object.owner) {\n      await this.set(\"OwnedObject\", object.objectId, object);\n    } else {\n      await this.set(\"SharedOrImmutableObject\", object.objectId, object);\n    }\n    return object;\n  }\n  async addObjects(objects) {\n    await Promise.all(objects.map(async object => this.addObject(object)));\n  }\n  async deleteObject(id) {\n    await Promise.all([this.delete(\"OwnedObject\", id), this.delete(\"SharedOrImmutableObject\", id)]);\n  }\n  async deleteObjects(ids) {\n    await Promise.all(ids.map(id => this.deleteObject(id)));\n  }\n  async getMoveFunctionDefinition(ref) {\n    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n    return this.get(\"MoveFunction\", functionName);\n  }\n  async addMoveFunctionDefinition(functionEntry) {\n    const pkg = normalizeSuiAddress(functionEntry.package);\n    const functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n    const entry = {\n      ...functionEntry,\n      package: pkg\n    };\n    await this.set(\"MoveFunction\", functionName, entry);\n    return entry;\n  }\n  async deleteMoveFunctionDefinition(ref) {\n    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n    await this.delete(\"MoveFunction\", functionName);\n  }\n  async getCustom(key) {\n    return this.get(\"Custom\", key);\n  }\n  async setCustom(key, value) {\n    return this.set(\"Custom\", key, value);\n  }\n  async deleteCustom(key) {\n    return this.delete(\"Custom\", key);\n  }\n}\nclass InMemoryCache extends AsyncCache {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _caches, {\n      OwnedObject: /* @__PURE__ */new Map(),\n      SharedOrImmutableObject: /* @__PURE__ */new Map(),\n      MoveFunction: /* @__PURE__ */new Map(),\n      Custom: /* @__PURE__ */new Map()\n    });\n  }\n  async get(type, key) {\n    return __privateGet(this, _caches)[type].get(key) ?? null;\n  }\n  async set(type, key, value) {\n    __privateGet(this, _caches)[type].set(key, value);\n  }\n  async delete(type, key) {\n    __privateGet(this, _caches)[type].delete(key);\n  }\n  async clear(type) {\n    if (type) {\n      __privateGet(this, _caches)[type].clear();\n    } else {\n      for (const cache of Object.values(__privateGet(this, _caches))) {\n        cache.clear();\n      }\n    }\n  }\n}\n_caches = new WeakMap();\nclass ObjectCache {\n  constructor({\n    cache = new InMemoryCache(),\n    onEffects\n  }) {\n    __privateAdd(this, _cache);\n    __privateAdd(this, _onEffects);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _onEffects, onEffects);\n  }\n  asPlugin() {\n    return async (transactionData, _options, next) => {\n      const unresolvedObjects = transactionData.inputs.filter(input => input.UnresolvedObject).map(input => input.UnresolvedObject.objectId);\n      const cached = (await __privateGet(this, _cache).getObjects(unresolvedObjects)).filter(obj => obj !== null);\n      const byId = new Map(cached.map(obj => [obj.objectId, obj]));\n      for (const input of transactionData.inputs) {\n        if (!input.UnresolvedObject) {\n          continue;\n        }\n        const cached2 = byId.get(input.UnresolvedObject.objectId);\n        if (!cached2) {\n          continue;\n        }\n        if (cached2.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n          input.UnresolvedObject.initialSharedVersion = cached2.initialSharedVersion;\n        } else {\n          if (cached2.version && !input.UnresolvedObject.version) {\n            input.UnresolvedObject.version = cached2.version;\n          }\n          if (cached2.digest && !input.UnresolvedObject.digest) {\n            input.UnresolvedObject.digest = cached2.digest;\n          }\n        }\n      }\n      await Promise.all(transactionData.commands.map(async commands => {\n        if (commands.MoveCall) {\n          const def = await this.getMoveFunctionDefinition({\n            package: commands.MoveCall.package,\n            module: commands.MoveCall.module,\n            function: commands.MoveCall.function\n          });\n          if (def) {\n            commands.MoveCall._argumentTypes = def.parameters;\n          }\n        }\n      }));\n      await next();\n      await Promise.all(transactionData.commands.map(async commands => {\n        if (commands.MoveCall?._argumentTypes) {\n          await __privateGet(this, _cache).addMoveFunctionDefinition({\n            package: commands.MoveCall.package,\n            module: commands.MoveCall.module,\n            function: commands.MoveCall.function,\n            parameters: commands.MoveCall._argumentTypes\n          });\n        }\n      }));\n    };\n  }\n  async clear() {\n    await __privateGet(this, _cache).clear();\n  }\n  async getMoveFunctionDefinition(ref) {\n    return __privateGet(this, _cache).getMoveFunctionDefinition(ref);\n  }\n  async getObjects(ids) {\n    return __privateGet(this, _cache).getObjects(ids);\n  }\n  async deleteObjects(ids) {\n    return __privateGet(this, _cache).deleteObjects(ids);\n  }\n  async clearOwnedObjects() {\n    await __privateGet(this, _cache).clear(\"OwnedObject\");\n  }\n  async clearCustom() {\n    await __privateGet(this, _cache).clear(\"Custom\");\n  }\n  async getCustom(key) {\n    return __privateGet(this, _cache).getCustom(key);\n  }\n  async setCustom(key, value) {\n    return __privateGet(this, _cache).setCustom(key, value);\n  }\n  async deleteCustom(key) {\n    return __privateGet(this, _cache).deleteCustom(key);\n  }\n  async applyEffects(effects) {\n    var _a;\n    if (!effects.V2) {\n      throw new Error(`Unsupported transaction effects version ${effects.$kind}`);\n    }\n    const {\n      lamportVersion,\n      changedObjects\n    } = effects.V2;\n    const deletedIds = [];\n    const addedObjects = [];\n    changedObjects.forEach(([id, change]) => {\n      if (change.outputState.NotExist) {\n        deletedIds.push(id);\n      } else if (change.outputState.ObjectWrite) {\n        const [digest, owner] = change.outputState.ObjectWrite;\n        addedObjects.push({\n          objectId: id,\n          digest,\n          version: lamportVersion,\n          owner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n          initialSharedVersion: owner.Shared?.initialSharedVersion ?? null\n        });\n      }\n    });\n    await Promise.all([__privateGet(this, _cache).addObjects(addedObjects), __privateGet(this, _cache).deleteObjects(deletedIds), (_a = __privateGet(this, _onEffects)) == null ? void 0 : _a.call(this, effects)]);\n  }\n}\n_cache = new WeakMap();\n_onEffects = new WeakMap();\nexport { AsyncCache, InMemoryCache, ObjectCache };","map":{"version":3,"names":["_caches","_cache","_onEffects","normalizeSuiAddress","AsyncCache","getObject","id","owned","shared","Promise","all","get","getObjects","ids","map","addObject","object","owner","set","objectId","addObjects","objects","deleteObject","delete","deleteObjects","getMoveFunctionDefinition","ref","functionName","package","module","function","addMoveFunctionDefinition","functionEntry","pkg","entry","deleteMoveFunctionDefinition","getCustom","key","setCustom","value","deleteCustom","InMemoryCache","constructor","arguments","__privateAdd","OwnedObject","Map","SharedOrImmutableObject","MoveFunction","Custom","type","__privateGet","clear","cache","Object","values","WeakMap","ObjectCache","onEffects","__privateSet","asPlugin","transactionData","_options","next","unresolvedObjects","inputs","filter","input","UnresolvedObject","cached","obj","byId","cached2","initialSharedVersion","version","digest","commands","MoveCall","def","_argumentTypes","parameters","clearOwnedObjects","clearCustom","applyEffects","effects","_a","V2","Error","$kind","lamportVersion","changedObjects","deletedIds","addedObjects","forEach","change","outputState","NotExist","push","ObjectWrite","AddressOwner","ObjectOwner","Shared","call"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\ObjectCache.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature } from './data/internal.js';\nimport type { TransactionPlugin } from './json-rpc-resolver.js';\n\nexport interface ObjectCacheEntry {\n\tobjectId: string;\n\tversion: string;\n\tdigest: string;\n\towner: string | null;\n\tinitialSharedVersion: string | null;\n}\n\nexport interface MoveFunctionCacheEntry {\n\tpackage: string;\n\tmodule: string;\n\tfunction: string;\n\tparameters: OpenMoveTypeSignature[];\n}\n\nexport interface CacheEntryTypes {\n\tOwnedObject: ObjectCacheEntry;\n\tSharedOrImmutableObject: ObjectCacheEntry;\n\tMoveFunction: MoveFunctionCacheEntry;\n\tCustom: unknown;\n}\nexport abstract class AsyncCache {\n\tprotected abstract get<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t): Promise<CacheEntryTypes[T] | null>;\n\tprotected abstract set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t): Promise<void>;\n\tprotected abstract delete<T extends keyof CacheEntryTypes>(type: T, key: string): Promise<void>;\n\tabstract clear<T extends keyof CacheEntryTypes>(type?: T): Promise<void>;\n\n\tasync getObject(id: string) {\n\t\tconst [owned, shared] = await Promise.all([\n\t\t\tthis.get('OwnedObject', id),\n\t\t\tthis.get('SharedOrImmutableObject', id),\n\t\t]);\n\n\t\treturn owned ?? shared ?? null;\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn Promise.all([...ids.map((id) => this.getObject(id))]);\n\t}\n\n\tasync addObject(object: ObjectCacheEntry) {\n\t\tif (object.owner) {\n\t\t\tawait this.set('OwnedObject', object.objectId, object);\n\t\t} else {\n\t\t\tawait this.set('SharedOrImmutableObject', object.objectId, object);\n\t\t}\n\n\t\treturn object;\n\t}\n\n\tasync addObjects(objects: ObjectCacheEntry[]) {\n\t\tawait Promise.all(objects.map(async (object) => this.addObject(object)));\n\t}\n\n\tasync deleteObject(id: string) {\n\t\tawait Promise.all([this.delete('OwnedObject', id), this.delete('SharedOrImmutableObject', id)]);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\tawait Promise.all(ids.map((id) => this.deleteObject(id)));\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\treturn this.get('MoveFunction', functionName);\n\t}\n\n\tasync addMoveFunctionDefinition(functionEntry: MoveFunctionCacheEntry) {\n\t\tconst pkg = normalizeSuiAddress(functionEntry.package);\n\t\tconst functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n\t\tconst entry = {\n\t\t\t...functionEntry,\n\t\t\tpackage: pkg,\n\t\t};\n\n\t\tawait this.set('MoveFunction', functionName, entry);\n\n\t\treturn entry;\n\t}\n\n\tasync deleteMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\tawait this.delete('MoveFunction', functionName);\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.get('Custom', key) as Promise<T | null>;\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.set('Custom', key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.delete('Custom', key);\n\t}\n}\n\nexport class InMemoryCache extends AsyncCache {\n\t#caches = {\n\t\tOwnedObject: new Map<string, ObjectCacheEntry>(),\n\t\tSharedOrImmutableObject: new Map<string, ObjectCacheEntry>(),\n\t\tMoveFunction: new Map<string, MoveFunctionCacheEntry>(),\n\t\tCustom: new Map<string, unknown>(),\n\t};\n\n\tprotected async get<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\treturn (this.#caches[type].get(key) as CacheEntryTypes[T]) ?? null;\n\t}\n\n\tprotected async set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t) {\n\t\t(this.#caches[type] as Map<string, typeof value>).set(key, value as never);\n\t}\n\n\tprotected async delete<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\tthis.#caches[type].delete(key);\n\t}\n\n\tasync clear<T extends keyof CacheEntryTypes>(type?: T) {\n\t\tif (type) {\n\t\t\tthis.#caches[type].clear();\n\t\t} else {\n\t\t\tfor (const cache of Object.values(this.#caches)) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface ObjectCacheOptions {\n\tcache?: AsyncCache;\n\tonEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n}\n\nexport class ObjectCache {\n\t#cache: AsyncCache;\n\t#onEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n\n\tconstructor({ cache = new InMemoryCache(), onEffects }: ObjectCacheOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#onEffects = onEffects;\n\t}\n\n\tasPlugin(): TransactionPlugin {\n\t\treturn async (transactionData, _options, next) => {\n\t\t\tconst unresolvedObjects = transactionData.inputs\n\t\t\t\t.filter((input) => input.UnresolvedObject)\n\t\t\t\t.map((input) => input.UnresolvedObject!.objectId);\n\n\t\t\tconst cached = (await this.#cache.getObjects(unresolvedObjects)).filter(\n\t\t\t\t(obj) => obj !== null,\n\t\t\t);\n\n\t\t\tconst byId = new Map(cached.map((obj) => [obj!.objectId, obj]));\n\n\t\t\tfor (const input of transactionData.inputs) {\n\t\t\t\tif (!input.UnresolvedObject) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst cached = byId.get(input.UnresolvedObject.objectId);\n\n\t\t\t\tif (!cached) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cached.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion = cached.initialSharedVersion;\n\t\t\t\t} else {\n\t\t\t\t\tif (cached.version && !input.UnresolvedObject.version) {\n\t\t\t\t\t\tinput.UnresolvedObject.version = cached.version;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cached.digest && !input.UnresolvedObject.digest) {\n\t\t\t\t\t\tinput.UnresolvedObject.digest = cached.digest;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall) {\n\t\t\t\t\t\tconst def = await this.getMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (def) {\n\t\t\t\t\t\t\tcommands.MoveCall._argumentTypes = def.parameters;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tawait next();\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall?._argumentTypes) {\n\t\t\t\t\t\tawait this.#cache.addMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t\tparameters: commands.MoveCall._argumentTypes,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\tasync clear() {\n\t\tawait this.#cache.clear();\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\treturn this.#cache.getMoveFunctionDefinition(ref);\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn this.#cache.getObjects(ids);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\treturn this.#cache.deleteObjects(ids);\n\t}\n\n\tasync clearOwnedObjects() {\n\t\tawait this.#cache.clear('OwnedObject');\n\t}\n\n\tasync clearCustom() {\n\t\tawait this.#cache.clear('Custom');\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.#cache.getCustom<T>(key);\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.#cache.setCustom(key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.#cache.deleteCustom(key);\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tif (!effects.V2) {\n\t\t\tthrow new Error(`Unsupported transaction effects version ${effects.$kind}`);\n\t\t}\n\n\t\tconst { lamportVersion, changedObjects } = effects.V2;\n\n\t\tconst deletedIds: string[] = [];\n\t\tconst addedObjects: ObjectCacheEntry[] = [];\n\n\t\tchangedObjects.forEach(([id, change]) => {\n\t\t\tif (change.outputState.NotExist) {\n\t\t\t\tdeletedIds.push(id);\n\t\t\t} else if (change.outputState.ObjectWrite) {\n\t\t\t\tconst [digest, owner] = change.outputState.ObjectWrite;\n\n\t\t\t\taddedObjects.push({\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion: lamportVersion,\n\t\t\t\t\towner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n\t\t\t\t\tinitialSharedVersion: owner.Shared?.initialSharedVersion ?? null,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all([\n\t\t\tthis.#cache.addObjects(addedObjects),\n\t\t\tthis.#cache.deleteObjects(deletedIds),\n\t\t\tthis.#onEffects?.(effects),\n\t\t]);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}