{"ast":null,"code":"import { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { ObjectRef } from \"./data/internal.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from \"./serializer.js\";\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 5e10;\nasync function resolveTransactionData(transactionData, options, next) {\n  await normalizeInputs(transactionData, options);\n  await resolveObjectReferences(transactionData, options);\n  if (!options.onlyTransactionKind) {\n    await setGasPrice(transactionData, options);\n    await setGasBudget(transactionData, options);\n    await setGasPayment(transactionData, options);\n  }\n  await validate(transactionData);\n  return await next();\n}\nasync function setGasPrice(transactionData, options) {\n  if (!transactionData.gasConfig.price) {\n    transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n  }\n}\nasync function setGasBudget(transactionData, options) {\n  if (transactionData.gasConfig.budget) {\n    return;\n  }\n  const dryRunResult = await getClient(options).dryRunTransactionBlock({\n    transactionBlock: transactionData.build({\n      overrides: {\n        gasData: {\n          budget: String(MAX_GAS),\n          payment: []\n        }\n      }\n    })\n  });\n  if (dryRunResult.effects.status.status !== \"success\") {\n    throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, {\n      cause: dryRunResult\n    });\n  }\n  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n  transactionData.gasConfig.budget = String(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);\n}\nasync function setGasPayment(transactionData, options) {\n  if (!transactionData.gasConfig.payment) {\n    const coins = await getClient(options).getCoins({\n      owner: transactionData.gasConfig.owner || transactionData.sender,\n      coinType: SUI_TYPE_ARG\n    });\n    const paymentCoins = coins.data.filter(coin => {\n      const matchingInput = transactionData.inputs.find(input => {\n        if (input.Object?.ImmOrOwnedObject) {\n          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n        }\n        return false;\n      });\n      return !matchingInput;\n    }).map(coin => ({\n      objectId: coin.coinObjectId,\n      digest: coin.digest,\n      version: coin.version\n    }));\n    if (!paymentCoins.length) {\n      throw new Error(\"No valid gas coins found for the transaction.\");\n    }\n    transactionData.gasConfig.payment = paymentCoins.map(payment => parse(ObjectRef, payment));\n  }\n}\nasync function resolveObjectReferences(transactionData, options) {\n  const objectsToResolve = transactionData.inputs.filter(input => {\n    return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);\n  });\n  const dedupedIds = [...new Set(objectsToResolve.map(input => normalizeSuiObjectId(input.UnresolvedObject.objectId)))];\n  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n  const resolved = (await Promise.all(objectChunks.map(chunk2 => getClient(options).multiGetObjects({\n    ids: chunk2,\n    options: {\n      showOwner: true\n    }\n  })))).flat();\n  const responsesById = new Map(dedupedIds.map((id, index) => {\n    return [id, resolved[index]];\n  }));\n  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));\n  if (invalidObjects.length) {\n    throw new Error(`The following input objects are invalid: ${invalidObjects.join(\", \")}`);\n  }\n  const objects = resolved.map(object => {\n    if (object.error || !object.data) {\n      throw new Error(`Failed to fetch object: ${object.error}`);\n    }\n    const owner = object.data.owner;\n    const initialSharedVersion = owner && typeof owner === \"object\" && \"Shared\" in owner ? owner.Shared.initial_shared_version : null;\n    return {\n      objectId: object.data.objectId,\n      digest: object.data.digest,\n      version: object.data.version,\n      initialSharedVersion\n    };\n  });\n  const objectsById = new Map(dedupedIds.map((id, index) => {\n    return [id, objects[index]];\n  }));\n  for (const [index, input] of transactionData.inputs.entries()) {\n    if (!input.UnresolvedObject) {\n      continue;\n    }\n    let updated;\n    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n    const object = objectsById.get(id);\n    if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n      updated = Inputs.SharedObjectRef({\n        objectId: id,\n        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion,\n        mutable: isUsedAsMutable(transactionData, index)\n      });\n    } else if (isUsedAsReceiving(transactionData, index)) {\n      updated = Inputs.ReceivingRef({\n        objectId: id,\n        digest: input.UnresolvedObject.digest ?? object?.digest,\n        version: input.UnresolvedObject.version ?? object?.version\n      });\n    }\n    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({\n      objectId: id,\n      digest: input.UnresolvedObject.digest ?? object?.digest,\n      version: input.UnresolvedObject.version ?? object?.version\n    });\n  }\n}\nasync function normalizeInputs(transactionData, options) {\n  const {\n    inputs,\n    commands\n  } = transactionData;\n  const moveCallsToResolve = [];\n  const moveFunctionsToResolve = /* @__PURE__ */new Set();\n  commands.forEach(command => {\n    if (command.MoveCall) {\n      if (command.MoveCall._argumentTypes) {\n        return;\n      }\n      const inputs2 = command.MoveCall.arguments.map(arg => {\n        if (arg.$kind === \"Input\") {\n          return transactionData.inputs[arg.Input];\n        }\n        return null;\n      });\n      const needsResolution = inputs2.some(input => input?.UnresolvedPure || input?.UnresolvedObject);\n      if (needsResolution) {\n        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n        moveFunctionsToResolve.add(functionName);\n        moveCallsToResolve.push(command.MoveCall);\n      }\n    }\n    switch (command.$kind) {\n      case \"SplitCoins\":\n        command.SplitCoins.amounts.forEach(amount => {\n          normalizeRawArgument(amount, bcs.U64, transactionData);\n        });\n        break;\n      case \"TransferObjects\":\n        normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n        break;\n    }\n  });\n  const moveFunctionParameters = /* @__PURE__ */new Map();\n  if (moveFunctionsToResolve.size > 0) {\n    const client = getClient(options);\n    await Promise.all([...moveFunctionsToResolve].map(async functionName => {\n      const [packageId, moduleId, functionId] = functionName.split(\"::\");\n      const def = await client.getNormalizedMoveFunction({\n        package: packageId,\n        module: moduleId,\n        function: functionId\n      });\n      moveFunctionParameters.set(functionName, def.parameters.map(param => normalizedTypeToMoveTypeSignature(param)));\n    }));\n  }\n  if (moveCallsToResolve.length) {\n    await Promise.all(moveCallsToResolve.map(async moveCall => {\n      const parameters = moveFunctionParameters.get(`${moveCall.package}::${moveCall.module}::${moveCall.function}`);\n      if (!parameters) {\n        return;\n      }\n      const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));\n      const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n      moveCall._argumentTypes = params;\n    }));\n  }\n  commands.forEach(command => {\n    if (!command.MoveCall) {\n      return;\n    }\n    const moveCall = command.MoveCall;\n    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n    const params = moveCall._argumentTypes;\n    if (!params) {\n      return;\n    }\n    if (params.length !== command.MoveCall.arguments.length) {\n      throw new Error(`Incorrect number of arguments for ${fnName}`);\n    }\n    params.forEach((param, i) => {\n      const arg = moveCall.arguments[i];\n      if (arg.$kind !== \"Input\") return;\n      const input = inputs[arg.Input];\n      if (!input.UnresolvedPure && !input.UnresolvedObject) {\n        return;\n      }\n      const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;\n      const schema = getPureBcsSchema(param.body);\n      if (schema) {\n        arg.type = \"pure\";\n        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n        return;\n      }\n      if (typeof inputValue !== \"string\") {\n        throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);\n      }\n      arg.type = \"object\";\n      const unresolvedObject = input.UnresolvedPure ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: inputValue\n        }\n      } : input;\n      inputs[arg.Input] = unresolvedObject;\n    });\n  });\n}\nfunction validate(transactionData) {\n  transactionData.inputs.forEach((input, index) => {\n    if (input.$kind !== \"Object\" && input.$kind !== \"Pure\") {\n      throw new Error(`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(input)}`);\n    }\n  });\n}\nfunction normalizeRawArgument(arg, schema, transactionData) {\n  if (arg.$kind !== \"Input\") {\n    return;\n  }\n  const input = transactionData.inputs[arg.Input];\n  if (input.$kind !== \"UnresolvedPure\") {\n    return;\n  }\n  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\nfunction isUsedAsMutable(transactionData, index) {\n  let usedAsMutable = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== \"&\" || usedAsMutable;\n    }\n    if (tx.$kind === \"MakeMoveVec\" || tx.$kind === \"MergeCoins\" || tx.$kind === \"SplitCoins\") {\n      usedAsMutable = true;\n    }\n  });\n  return usedAsMutable;\n}\nfunction isUsedAsReceiving(transactionData, index) {\n  let usedAsReceiving = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n    }\n  });\n  return usedAsReceiving;\n}\nfunction isReceivingType(type) {\n  if (typeof type.body !== \"object\" || !(\"datatype\" in type.body)) {\n    return false;\n  }\n  return type.body.datatype.package === \"0x2\" && type.body.datatype.module === \"transfer\" && type.body.datatype.type === \"Receiving\";\n}\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`);\n  }\n  return options.client;\n}\nfunction chunk(arr, size) {\n  return Array.from({\n    length: Math.ceil(arr.length / size)\n  }, (_, i) => arr.slice(i * size, i * size + size));\n}\nexport { getClient, resolveTransactionData };","map":{"version":3,"names":["parse","bcs","normalizeSuiAddress","normalizeSuiObjectId","SUI_TYPE_ARG","ObjectRef","Inputs","getPureBcsSchema","isTxContext","normalizedTypeToMoveTypeSignature","MAX_OBJECTS_PER_FETCH","GAS_SAFE_OVERHEAD","MAX_GAS","resolveTransactionData","transactionData","options","next","normalizeInputs","resolveObjectReferences","onlyTransactionKind","setGasPrice","setGasBudget","setGasPayment","validate","gasConfig","price","String","getClient","getReferenceGasPrice","budget","dryRunResult","dryRunTransactionBlock","transactionBlock","build","overrides","gasData","payment","effects","status","Error","error","cause","safeOverhead","BigInt","baseComputationCostWithOverhead","gasUsed","computationCost","gasBudget","storageCost","storageRebate","coins","getCoins","owner","sender","coinType","paymentCoins","data","filter","coin","matchingInput","inputs","find","input","Object","ImmOrOwnedObject","coinObjectId","objectId","map","digest","version","length","objectsToResolve","UnresolvedObject","initialSharedVersion","dedupedIds","Set","objectChunks","chunk","resolved","Promise","all","chunk2","multiGetObjects","ids","showOwner","flat","responsesById","Map","id","index","invalidObjects","Array","from","_","obj","JSON","stringify","join","objects","object","Shared","initial_shared_version","objectsById","entries","updated","get","SharedObjectRef","mutable","isUsedAsMutable","isUsedAsReceiving","ReceivingRef","indexOf","commands","moveCallsToResolve","moveFunctionsToResolve","forEach","command","MoveCall","_argumentTypes","inputs2","arguments","arg","$kind","Input","needsResolution","some","UnresolvedPure","functionName","package","module","function","add","push","SplitCoins","amounts","amount","normalizeRawArgument","U64","TransferObjects","address","Address","moveFunctionParameters","size","client","packageId","moduleId","functionId","split","def","getNormalizedMoveFunction","set","parameters","param","moveCall","hasTxContext","at","params","slice","fnName","i","inputValue","value","schema","body","type","Pure","serialize","unresolvedObject","usedAsMutable","getInputUses","tx","argIndex","ref","usedAsReceiving","isReceivingType","datatype","arr","Math","ceil"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\json-rpc-resolver.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport type { BcsType } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport type { SuiClient } from '../client/client.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRef } from './data/internal.js';\nimport type { Argument, CallArg, Command, OpenMoveTypeSignature } from './data/internal.js';\nimport { Inputs } from './Inputs.js';\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from './serializer.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport interface BuildTransactionOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport async function resolveTransactionData(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tawait normalizeInputs(transactionData, options);\n\tawait resolveObjectReferences(transactionData, options);\n\n\tif (!options.onlyTransactionKind) {\n\t\tawait setGasPrice(transactionData, options);\n\t\tawait setGasBudget(transactionData, options);\n\t\tawait setGasPayment(transactionData, options);\n\t}\n\tawait validate(transactionData);\n\treturn await next();\n}\n\nasync function setGasPrice(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await getClient(options).dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await getClient(options).getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));\n\t}\n}\n\nasync function resolveObjectReferences(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tgetClient(options).multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) => input?.UnresolvedPure || input?.UnresolvedObject,\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\n\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t// This should only happen when transaction data was hydrated from an old version of the SDK\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tconst client = getClient(options);\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n\nexport function getClient(options: BuildTransactionOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n\treturn Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}