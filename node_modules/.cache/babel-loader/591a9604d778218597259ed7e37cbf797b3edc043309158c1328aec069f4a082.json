{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _serializationPlugins, _buildPlugins, _intentResolvers, _data, _Transaction_instances, normalizeTransactionArgument_fn, resolveArgument_fn, prepareBuild_fn, runPlugins_fn;\nimport { fromBase64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, parse } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { Commands } from \"./Commands.js\";\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from \"./data/internal.js\";\nimport { serializeV1TransactionData } from \"./data/v1.js\";\nimport { SerializedTransactionDataV2 } from \"./data/v2.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { resolveTransactionData } from \"./json-rpc-resolver.js\";\nimport { createObjectMethods } from \"./object.js\";\nimport { createPure } from \"./pure.js\";\nimport { TransactionDataBuilder } from \"./TransactionData.js\";\nimport { getIdFromCallArg } from \"./utils.js\";\nfunction createTransactionResult(index, length = Infinity) {\n  const baseResult = {\n    $kind: \"Result\",\n    Result: index\n  };\n  const nestedResults = [];\n  const nestedResultFor = resultIndex => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    $kind: \"NestedResult\",\n    NestedResult: [index, resultIndex]\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\"The transaction result is a proxy, and does not support setting properties directly\");\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (i < length) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nfunction isTransaction(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst modulePluginRegistry = {\n  buildPlugins: /* @__PURE__ */new Map(),\n  serializationPlugins: /* @__PURE__ */new Map()\n};\nconst TRANSACTION_REGISTRY_KEY = Symbol.for(\"@mysten/transaction/registry\");\nfunction getGlobalPluginRegistry() {\n  try {\n    const target = globalThis;\n    if (!target[TRANSACTION_REGISTRY_KEY]) {\n      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n    }\n    return target[TRANSACTION_REGISTRY_KEY];\n  } catch (e) {\n    return modulePluginRegistry;\n  }\n}\nconst _Transaction = class _Transaction {\n  constructor() {\n    __privateAdd(this, _Transaction_instances);\n    __privateAdd(this, _serializationPlugins);\n    __privateAdd(this, _buildPlugins);\n    __privateAdd(this, _intentResolvers, /* @__PURE__ */new Map());\n    __privateAdd(this, _data);\n    /**\n     * Add a new object input to the transaction.\n     */\n    this.object = createObjectMethods(value => {\n      if (typeof value === \"function\") {\n        return this.object(value(this));\n      }\n      if (typeof value === \"object\" && is(Argument, value)) {\n        return value;\n      }\n      const id = getIdFromCallArg(value);\n      const inserted = __privateGet(this, _data).inputs.find(i => id === getIdFromCallArg(i));\n      if (inserted?.Object?.SharedObject && typeof value === \"object\" && value.Object?.SharedObject) {\n        inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n      }\n      return inserted ? {\n        $kind: \"Input\",\n        Input: __privateGet(this, _data).inputs.indexOf(inserted),\n        type: \"object\"\n      } : __privateGet(this, _data).addInput(\"object\", typeof value === \"string\" ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: normalizeSuiAddress(value)\n        }\n      } : value);\n    });\n    const globalPlugins = getGlobalPluginRegistry();\n    __privateSet(this, _data, new TransactionDataBuilder());\n    __privateSet(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);\n    __privateSet(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _Transaction();\n    __privateSet(tx, _data, TransactionDataBuilder.fromKindBytes(typeof serialized === \"string\" ? fromBase64(serialized) : serialized));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(transaction) {\n    const newTransaction = new _Transaction();\n    if (isTransaction(transaction)) {\n      __privateSet(newTransaction, _data, new TransactionDataBuilder(transaction.getData()));\n    } else if (typeof transaction !== \"string\" || !transaction.startsWith(\"{\")) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.fromBytes(typeof transaction === \"string\" ? fromBase64(transaction) : transaction));\n    } else {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));\n    }\n    return newTransaction;\n  }\n  static registerGlobalSerializationPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().serializationPlugins.set(stepOrStep, step ?? stepOrStep);\n  }\n  static unregisterGlobalSerializationPlugin(name) {\n    getGlobalPluginRegistry().serializationPlugins.delete(name);\n  }\n  static registerGlobalBuildPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().buildPlugins.set(stepOrStep, step ?? stepOrStep);\n  }\n  static unregisterGlobalBuildPlugin(name) {\n    getGlobalPluginRegistry().buildPlugins.delete(name);\n  }\n  addSerializationPlugin(step) {\n    __privateGet(this, _serializationPlugins).push(step);\n  }\n  addBuildPlugin(step) {\n    __privateGet(this, _buildPlugins).push(step);\n  }\n  addIntentResolver(intent, resolver) {\n    if (__privateGet(this, _intentResolvers).has(intent) && __privateGet(this, _intentResolvers).get(intent) !== resolver) {\n      throw new Error(`Intent resolver for ${intent} already exists`);\n    }\n    __privateGet(this, _intentResolvers).set(intent, resolver);\n  }\n  setSender(sender) {\n    __privateGet(this, _data).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _data).sender) {\n      __privateGet(this, _data).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _data).expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _data).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _data).gasConfig.budget = String(budget);\n  }\n  setGasBudgetIfNotSet(budget) {\n    if (__privateGet(this, _data).gasData.budget == null) {\n      __privateGet(this, _data).gasConfig.budget = String(budget);\n    }\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _data).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _data).gasConfig.payment = payments.map(payment => parse(ObjectRef, payment));\n  }\n  /** @deprecated Use `getData()` instead. */\n  get blockData() {\n    return serializeV1TransactionData(__privateGet(this, _data).snapshot());\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  getData() {\n    return __privateGet(this, _data).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure(value => {\n        if (isSerializedBcs(value)) {\n          return __privateGet(this, _data).addInput(\"pure\", {\n            $kind: \"Pure\",\n            Pure: {\n              bytes: value.toBase64()\n            }\n          });\n        }\n        return __privateGet(this, _data).addInput(\"pure\", is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : {\n          $kind: \"UnresolvedPure\",\n          UnresolvedPure: {\n            value\n          }\n        });\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return {\n      $kind: \"GasCoin\",\n      GasCoin: true\n    };\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  /** Add a transaction to the transaction */\n  add(command) {\n    if (typeof command === \"function\") {\n      return command(this);\n    }\n    const index = __privateGet(this, _data).commands.push(command);\n    return createTransactionResult(index - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    const command = Commands.SplitCoins(typeof coin === \"string\" ? this.object(coin) : __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, coin), amounts.map(amount => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)));\n    const index = __privateGet(this, _data).commands.push(command);\n    return createTransactionResult(index - 1, amounts.length);\n  }\n  mergeCoins(destination, sources) {\n    return this.add(Commands.MergeCoins(this.object(destination), sources.map(src => this.object(src))));\n  }\n  publish({\n    modules,\n    dependencies\n  }) {\n    return this.add(Commands.Publish({\n      modules,\n      dependencies\n    }));\n  }\n  upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return this.add(Commands.Upgrade({\n      modules,\n      dependencies,\n      package: packageId,\n      ticket: this.object(ticket)\n    }));\n  }\n  moveCall({\n    arguments: args,\n    ...input\n  }) {\n    return this.add(Commands.MoveCall({\n      ...input,\n      arguments: args?.map(arg => __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))\n    }));\n  }\n  transferObjects(objects, address) {\n    return this.add(Commands.TransferObjects(objects.map(obj => this.object(obj)), typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)));\n  }\n  makeMoveVec({\n    type,\n    elements\n  }) {\n    return this.add(Commands.MakeMoveVec({\n      type,\n      elements: elements.map(obj => this.object(obj))\n    }));\n  }\n  /**\n   * @deprecated Use toJSON instead.\n   * For synchronous serialization, you can use `getData()`\n   * */\n  serialize() {\n    return JSON.stringify(serializeV1TransactionData(__privateGet(this, _data).snapshot()));\n  }\n  async toJSON(options = {}) {\n    await this.prepareForSerialization(options);\n    return JSON.stringify(parse(SerializedTransactionDataV2, __privateGet(this, _data).snapshot()), (_key, value) => typeof value === \"bigint\" ? value.toString() : value, 2);\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const {\n      signer,\n      ...buildOptions\n    } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransaction(bytes);\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).build({\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).getDigest();\n  }\n  async prepareForSerialization(options) {\n    const intents = /* @__PURE__ */new Set();\n    for (const command of __privateGet(this, _data).commands) {\n      if (command.$Intent) {\n        intents.add(command.$Intent.name);\n      }\n    }\n    const steps = [...__privateGet(this, _serializationPlugins)];\n    for (const intent of intents) {\n      if (options.supportedIntents?.includes(intent)) {\n        continue;\n      }\n      if (!__privateGet(this, _intentResolvers).has(intent)) {\n        throw new Error(`Missing intent resolver for ${intent}`);\n      }\n      steps.push(__privateGet(this, _intentResolvers).get(intent));\n    }\n    await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);\n  }\n};\n_serializationPlugins = new WeakMap();\n_buildPlugins = new WeakMap();\n_intentResolvers = new WeakMap();\n_data = new WeakMap();\n_Transaction_instances = new WeakSet();\nnormalizeTransactionArgument_fn = function (arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, arg);\n};\nresolveArgument_fn = function (arg) {\n  if (typeof arg === \"function\") {\n    return parse(Argument, arg(this));\n  }\n  return parse(Argument, arg);\n};\nprepareBuild_fn = async function (options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _data).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet(this, _buildPlugins), resolveTransactionData], options);\n};\nrunPlugins_fn = async function (plugins, options) {\n  const createNext = i => {\n    if (i >= plugins.length) {\n      return () => {};\n    }\n    const plugin = plugins[i];\n    return async () => {\n      const next = createNext(i + 1);\n      let calledNext = false;\n      let nextResolved = false;\n      await plugin(__privateGet(this, _data), options, async () => {\n        if (calledNext) {\n          throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n        }\n        calledNext = true;\n        await next();\n        nextResolved = true;\n      });\n      if (!calledNext) {\n        throw new Error(`next() was not called in TransactionPlugin ${i}`);\n      }\n      if (!nextResolved) {\n        throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n      }\n    };\n  };\n  await createNext(0)();\n};\nlet Transaction = _Transaction;\nexport { Transaction, isTransaction };","map":{"version":3,"names":["_serializationPlugins","_buildPlugins","_intentResolvers","_data","_Transaction_instances","normalizeTransactionArgument_fn","resolveArgument_fn","prepareBuild_fn","runPlugins_fn","fromBase64","isSerializedBcs","is","parse","normalizeSuiAddress","Commands","Argument","NormalizedCallArg","ObjectRef","TransactionExpiration","serializeV1TransactionData","SerializedTransactionDataV2","Inputs","resolveTransactionData","createObjectMethods","createPure","TransactionDataBuilder","getIdFromCallArg","createTransactionResult","index","length","Infinity","baseResult","$kind","Result","nestedResults","nestedResultFor","resultIndex","NestedResult","Proxy","set","Error","get","target","property","Reflect","Symbol","iterator","i","parseInt","Number","isNaN","TRANSACTION_BRAND","for","isTransaction","obj","modulePluginRegistry","buildPlugins","Map","serializationPlugins","TRANSACTION_REGISTRY_KEY","getGlobalPluginRegistry","globalThis","e","_Transaction","constructor","__privateAdd","object","value","id","inserted","__privateGet","inputs","find","Object","SharedObject","mutable","Input","indexOf","type","addInput","UnresolvedObject","objectId","globalPlugins","__privateSet","values","fromKind","serialized","tx","fromKindBytes","from","transaction","newTransaction","getData","startsWith","fromBytes","restore","JSON","registerGlobalSerializationPlugin","stepOrStep","step","unregisterGlobalSerializationPlugin","name","delete","registerGlobalBuildPlugin","unregisterGlobalBuildPlugin","addSerializationPlugin","push","addBuildPlugin","addIntentResolver","intent","resolver","has","setSender","sender","setSenderIfNotSet","setExpiration","expiration","setGasPrice","price","gasConfig","String","setGasBudget","budget","setGasBudgetIfNotSet","gasData","setGasOwner","owner","setGasPayment","payments","payment","map","blockData","snapshot","pure","defineProperty","enumerable","Pure","bytes","toBase64","Uint8Array","UnresolvedPure","gas","GasCoin","objectRef","args","receivingRef","ReceivingRef","sharedObjectRef","SharedObjectRef","add","command","commands","splitCoins","coin","amounts","SplitCoins","__privateMethod","call","amount","u64","mergeCoins","destination","sources","MergeCoins","src","publish","modules","dependencies","Publish","upgrade","package","packageId","ticket","Upgrade","moveCall","arguments","input","MoveCall","arg","transferObjects","objects","address","TransferObjects","makeMoveVec","elements","MakeMoveVec","serialize","stringify","toJSON","options","prepareForSerialization","_key","toString","sign","signer","buildOptions","build","signTransaction","onlyTransactionKind","getDigest","intents","Set","$Intent","steps","supportedIntents","includes","WeakMap","WeakSet","plugins","createNext","plugin","next","calledNext","nextResolved","Transaction"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\Transaction.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SuiClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n\t| ((tx: Transaction) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number, length = Infinity): TransactionResult {\n\tconst baseResult = { $kind: 'Result' as const, Result: index };\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tNestedResult: [index, resultIndex],\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch (e) {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | Transaction) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = new TransactionDataBuilder(transaction.getData());\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#data.addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#data.addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(value(this));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(Argument, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#data.addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction */\n\tadd<T = TransactionResult>(command: Command | ((tx: Transaction) => T)): T {\n\t\tif (typeof command === 'function') {\n\t\t\treturn command(this);\n\t\t}\n\n\t\tconst index = this.#data.commands.push(command);\n\n\t\treturn createTransactionResult(index - 1) as T;\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\treturn parse(Argument, arg(this));\n\t\t}\n\n\t\treturn parse(Argument, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tconst index = this.#data.commands.push(command);\n\t\treturn createTransactionResult(index - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\treturn JSON.stringify(\n\t\t\tparse(SerializedTransactionDataV2, this.#data.snapshot()),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\tconst createNext = (i: number) => {\n\t\t\tif (i >= plugins.length) {\n\t\t\t\treturn () => {};\n\t\t\t}\n\t\t\tconst plugin = plugins[i];\n\n\t\t\treturn async () => {\n\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\tlet calledNext = false;\n\t\t\t\tlet nextResolved = false;\n\n\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\tawait next();\n\n\t\t\t\t\tnextResolved = true;\n\t\t\t\t});\n\n\t\t\t\tif (!calledNext) {\n\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t}\n\n\t\t\t\tif (!nextResolved) {\n\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tawait createNext(0)();\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}