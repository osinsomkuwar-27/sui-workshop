{"ast":null,"code":"import { fromBase58, splitGenericParameters } from \"@mysten/bcs\";\nconst TX_DIGEST_LENGTH = 32;\nfunction isValidTransactionDigest(value) {\n  try {\n    const buffer = fromBase58(value);\n    return buffer.length === TX_DIGEST_LENGTH;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUI_ADDRESS_LENGTH = 32;\nfunction isValidSuiAddress(value) {\n  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\nfunction isValidSuiObjectId(value) {\n  return isValidSuiAddress(value);\n}\nfunction parseTypeTag(type) {\n  if (!type.includes(\"::\")) return type;\n  return parseStructTag(type);\n}\nfunction parseStructTag(type) {\n  const [address, module] = type.split(\"::\");\n  const rest = type.slice(address.length + module.length + 4);\n  const name = rest.includes(\"<\") ? rest.slice(0, rest.indexOf(\"<\")) : rest;\n  const typeParams = rest.includes(\"<\") ? splitGenericParameters(rest.slice(rest.indexOf(\"<\") + 1, rest.lastIndexOf(\">\"))).map(typeParam => parseTypeTag(typeParam.trim())) : [];\n  return {\n    address: normalizeSuiAddress(address),\n    module,\n    name,\n    typeParams\n  };\n}\nfunction normalizeStructTag(type) {\n  const {\n    address,\n    module,\n    name,\n    typeParams\n  } = typeof type === \"string\" ? parseStructTag(type) : type;\n  const formattedTypeParams = typeParams?.length > 0 ? `<${typeParams.map(typeParam => typeof typeParam === \"string\" ? typeParam : normalizeStructTag(typeParam)).join(\",\")}>` : \"\";\n  return `${address}::${module}::${name}${formattedTypeParams}`;\n}\nfunction normalizeSuiAddress(value, forceAdd0x = false) {\n  let address = value.toLowerCase();\n  if (!forceAdd0x && address.startsWith(\"0x\")) {\n    address = address.slice(2);\n  }\n  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, \"0\")}`;\n}\nfunction normalizeSuiObjectId(value, forceAdd0x = false) {\n  return normalizeSuiAddress(value, forceAdd0x);\n}\nfunction isHex(value) {\n  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\nfunction getHexByteLength(value) {\n  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\nexport { SUI_ADDRESS_LENGTH, isValidSuiAddress, isValidSuiObjectId, isValidTransactionDigest, normalizeStructTag, normalizeSuiAddress, normalizeSuiObjectId, parseStructTag };","map":{"version":3,"names":["fromBase58","splitGenericParameters","TX_DIGEST_LENGTH","isValidTransactionDigest","value","buffer","length","e","SUI_ADDRESS_LENGTH","isValidSuiAddress","isHex","getHexByteLength","isValidSuiObjectId","parseTypeTag","type","includes","parseStructTag","address","module","split","rest","slice","name","indexOf","typeParams","lastIndexOf","map","typeParam","trim","normalizeSuiAddress","normalizeStructTag","formattedTypeParams","join","forceAdd0x","toLowerCase","startsWith","padStart","normalizeSuiObjectId","test"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\utils\\sui-types.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\ntype StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}