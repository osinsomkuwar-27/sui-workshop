{"ast":null,"code":"import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { messageWithIntent } from \"./intent.js\";\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_SIZE } from \"./signature-scheme.js\";\nfunction bytesEqual(a, b) {\n  if (a === b) return true;\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nclass PublicKey {\n  /**\n   * Checks if two public keys are equal\n   */\n  equals(publicKey) {\n    return bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n  }\n  /**\n   * Return the base-64 representation of the public key\n   */\n  toBase64() {\n    return toBase64(this.toRawBytes());\n  }\n  toString() {\n    throw new Error(\"`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.\");\n  }\n  /**\n   * Return the Sui representation of the public key encoded in\n   * base-64. A Sui public key is formed by the concatenation\n   * of the scheme flag with the raw bytes of the public key\n   */\n  toSuiPublicKey() {\n    const bytes = this.toSuiBytes();\n    return toBase64(bytes);\n  }\n  verifyWithIntent(bytes, signature, intent) {\n    const intentMessage = messageWithIntent(intent, bytes);\n    const digest = blake2b(intentMessage, {\n      dkLen: 32\n    });\n    return this.verify(digest, signature);\n  }\n  /**\n   * Verifies that the signature is valid for for the provided PersonalMessage\n   */\n  verifyPersonalMessage(message, signature) {\n    return this.verifyWithIntent(bcs.vector(bcs.u8()).serialize(message).toBytes(), signature, \"PersonalMessage\");\n  }\n  /**\n   * Verifies that the signature is valid for for the provided Transaction\n   */\n  verifyTransaction(transaction, signature) {\n    return this.verifyWithIntent(transaction, signature, \"TransactionData\");\n  }\n  /**\n   * Verifies that the public key is associated with the provided address\n   */\n  verifyAddress(address) {\n    return this.toSuiAddress() === address;\n  }\n  /**\n   * Returns the bytes representation of the public key\n   * prefixed with the signature scheme flag\n   */\n  toSuiBytes() {\n    const rawBytes = this.toRawBytes();\n    const suiBytes = new Uint8Array(rawBytes.length + 1);\n    suiBytes.set([this.flag()]);\n    suiBytes.set(rawBytes, 1);\n    return suiBytes;\n  }\n  /**\n   * Return the Sui address associated with this Ed25519 public key\n   */\n  toSuiAddress() {\n    return normalizeSuiAddress(bytesToHex(blake2b(this.toSuiBytes(), {\n      dkLen: 32\n    })).slice(0, SUI_ADDRESS_LENGTH * 2));\n  }\n}\nfunction parseSerializedKeypairSignature(serializedSignature) {\n  const bytes = fromBase64(serializedSignature);\n  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];\n  switch (signatureScheme) {\n    case \"ED25519\":\n    case \"Secp256k1\":\n    case \"Secp256r1\":\n      const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];\n      const signature = bytes.slice(1, bytes.length - size);\n      const publicKey = bytes.slice(1 + signature.length);\n      return {\n        serializedSignature,\n        signatureScheme,\n        signature,\n        publicKey,\n        bytes\n      };\n    default:\n      throw new Error(\"Unsupported signature scheme\");\n  }\n}\nexport { PublicKey, bytesEqual, parseSerializedKeypairSignature };","map":{"version":3,"names":["fromBase64","toBase64","blake2b","bytesToHex","bcs","normalizeSuiAddress","SUI_ADDRESS_LENGTH","messageWithIntent","SIGNATURE_FLAG_TO_SCHEME","SIGNATURE_SCHEME_TO_SIZE","bytesEqual","a","b","length","i","PublicKey","equals","publicKey","toRawBytes","toString","Error","toSuiPublicKey","bytes","toSuiBytes","verifyWithIntent","signature","intent","intentMessage","digest","dkLen","verify","verifyPersonalMessage","message","vector","u8","serialize","toBytes","verifyTransaction","transaction","verifyAddress","address","toSuiAddress","rawBytes","suiBytes","Uint8Array","set","flag","slice","parseSerializedKeypairSignature","serializedSignature","signatureScheme","size"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\cryptography\\publickey.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_SIZE } from './signature-scheme.js';\n\n/**\n * Value to be converted into public key.\n */\nexport type PublicKeyInitData = string | Uint8Array | Iterable<number>;\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n\tif (a === b) return true;\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * A public key\n */\nexport abstract class PublicKey {\n\t/**\n\t * Checks if two public keys are equal\n\t */\n\tequals(publicKey: PublicKey) {\n\t\treturn bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n\t}\n\n\t/**\n\t * Return the base-64 representation of the public key\n\t */\n\ttoBase64() {\n\t\treturn toBase64(this.toRawBytes());\n\t}\n\n\ttoString(): never {\n\t\tthrow new Error(\n\t\t\t'`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.',\n\t\t);\n\t}\n\n\t/**\n\t * Return the Sui representation of the public key encoded in\n\t * base-64. A Sui public key is formed by the concatenation\n\t * of the scheme flag with the raw bytes of the public key\n\t */\n\ttoSuiPublicKey(): string {\n\t\tconst bytes = this.toSuiBytes();\n\t\treturn toBase64(bytes);\n\t}\n\n\tverifyWithIntent(\n\t\tbytes: Uint8Array,\n\t\tsignature: Uint8Array | string,\n\t\tintent: IntentScope,\n\t): Promise<boolean> {\n\t\tconst intentMessage = messageWithIntent(intent, bytes);\n\t\tconst digest = blake2b(intentMessage, { dkLen: 32 });\n\n\t\treturn this.verify(digest, signature);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\treturn this.verifyWithIntent(\n\t\t\tbcs.vector(bcs.u8()).serialize(message).toBytes(),\n\t\t\tsignature,\n\t\t\t'PersonalMessage',\n\t\t);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided Transaction\n\t */\n\tverifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\treturn this.verifyWithIntent(transaction, signature, 'TransactionData');\n\t}\n\n\t/**\n\t * Verifies that the public key is associated with the provided address\n\t */\n\tverifyAddress(address: string): boolean {\n\t\treturn this.toSuiAddress() === address;\n\t}\n\n\t/**\n\t * Returns the bytes representation of the public key\n\t * prefixed with the signature scheme flag\n\t */\n\ttoSuiBytes(): Uint8Array {\n\t\tconst rawBytes = this.toRawBytes();\n\t\tconst suiBytes = new Uint8Array(rawBytes.length + 1);\n\t\tsuiBytes.set([this.flag()]);\n\t\tsuiBytes.set(rawBytes, 1);\n\n\t\treturn suiBytes;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Ed25519 public key\n\t */\n\ttoSuiAddress(): string {\n\t\t// Each hex char represents half a byte, hence hex address doubles the length\n\t\treturn normalizeSuiAddress(\n\t\t\tbytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n\t\t);\n\t}\n\n\t/**\n\t * Return the byte array representation of the public key\n\t */\n\tabstract toRawBytes(): Uint8Array;\n\n\t/**\n\t * Return signature scheme flag of the public key\n\t */\n\tabstract flag(): number;\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tabstract verify(data: Uint8Array, signature: Uint8Array | string): Promise<boolean>;\n}\n\nexport function parseSerializedKeypairSignature(serializedSignature: string) {\n\tconst bytes = fromBase64(serializedSignature);\n\n\tconst signatureScheme =\n\t\tSIGNATURE_FLAG_TO_SCHEME[bytes[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n\n\tswitch (signatureScheme) {\n\t\tcase 'ED25519':\n\t\tcase 'Secp256k1':\n\t\tcase 'Secp256r1':\n\t\t\tconst size =\n\t\t\t\tSIGNATURE_SCHEME_TO_SIZE[signatureScheme as keyof typeof SIGNATURE_SCHEME_TO_SIZE];\n\t\t\tconst signature = bytes.slice(1, bytes.length - size);\n\t\t\tconst publicKey = bytes.slice(1 + signature.length);\n\n\t\t\treturn {\n\t\t\t\tserializedSignature,\n\t\t\t\tsignatureScheme,\n\t\t\t\tsignature,\n\t\t\t\tpublicKey,\n\t\t\t\tbytes,\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported signature scheme');\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}