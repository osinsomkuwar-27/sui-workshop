{"ast":null,"code":"import { bcs, toBase64 } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bech32 } from \"@scure/base\";\nimport { messageWithIntent } from \"./intent.js\";\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from \"./signature-scheme.js\";\nimport { toSerializedSignature } from \"./signature.js\";\nconst PRIVATE_KEY_SIZE = 32;\nconst LEGACY_PRIVATE_KEY_SIZE = 64;\nconst SUI_PRIVATE_KEY_PREFIX = \"suiprivkey\";\nclass Signer {\n  /**\n   * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,\n   * it ensures that a signed message is tied to a specific purpose and domain separator is provided\n   */\n  async signWithIntent(bytes, intent) {\n    const intentMessage = messageWithIntent(intent, bytes);\n    const digest = blake2b(intentMessage, {\n      dkLen: 32\n    });\n    const signature = toSerializedSignature({\n      signature: await this.sign(digest),\n      signatureScheme: this.getKeyScheme(),\n      publicKey: this.getPublicKey()\n    });\n    return {\n      signature,\n      bytes: toBase64(bytes)\n    };\n  }\n  /**\n   * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope\n   */\n  async signTransaction(bytes) {\n    return this.signWithIntent(bytes, \"TransactionData\");\n  }\n  /**\n   * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope\n   */\n  async signPersonalMessage(bytes) {\n    const {\n      signature\n    } = await this.signWithIntent(bcs.vector(bcs.u8()).serialize(bytes).toBytes(), \"PersonalMessage\");\n    return {\n      bytes: toBase64(bytes),\n      signature\n    };\n  }\n  toSuiAddress() {\n    return this.getPublicKey().toSuiAddress();\n  }\n}\nclass Keypair extends Signer {}\nfunction decodeSuiPrivateKey(value) {\n  const {\n    prefix,\n    words\n  } = bech32.decode(value);\n  if (prefix !== SUI_PRIVATE_KEY_PREFIX) {\n    throw new Error(\"invalid private key prefix\");\n  }\n  const extendedSecretKey = new Uint8Array(bech32.fromWords(words));\n  const secretKey = extendedSecretKey.slice(1);\n  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0]];\n  return {\n    schema: signatureScheme,\n    secretKey\n  };\n}\nfunction encodeSuiPrivateKey(bytes, scheme) {\n  if (bytes.length !== PRIVATE_KEY_SIZE) {\n    throw new Error(\"Invalid bytes length\");\n  }\n  const flag = SIGNATURE_SCHEME_TO_FLAG[scheme];\n  const privKeyBytes = new Uint8Array(bytes.length + 1);\n  privKeyBytes.set([flag]);\n  privKeyBytes.set(bytes, 1);\n  return bech32.encode(SUI_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));\n}\nexport { Keypair, LEGACY_PRIVATE_KEY_SIZE, PRIVATE_KEY_SIZE, SUI_PRIVATE_KEY_PREFIX, Signer, decodeSuiPrivateKey, encodeSuiPrivateKey };","map":{"version":3,"names":["bcs","toBase64","blake2b","bech32","messageWithIntent","SIGNATURE_FLAG_TO_SCHEME","SIGNATURE_SCHEME_TO_FLAG","toSerializedSignature","PRIVATE_KEY_SIZE","LEGACY_PRIVATE_KEY_SIZE","SUI_PRIVATE_KEY_PREFIX","Signer","signWithIntent","bytes","intent","intentMessage","digest","dkLen","signature","sign","signatureScheme","getKeyScheme","publicKey","getPublicKey","signTransaction","signPersonalMessage","vector","u8","serialize","toBytes","toSuiAddress","Keypair","decodeSuiPrivateKey","value","prefix","words","decode","Error","extendedSecretKey","Uint8Array","fromWords","secretKey","slice","schema","encodeSuiPrivateKey","scheme","length","flag","privKeyBytes","set","encode","toWords"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\cryptography\\keypair.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs, toBase64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bech32 } from '@scure/base';\n\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport type { PublicKey } from './publickey.js';\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from './signature-scheme.js';\nimport type { SignatureScheme } from './signature-scheme.js';\nimport { toSerializedSignature } from './signature.js';\n\nexport const PRIVATE_KEY_SIZE = 32;\nexport const LEGACY_PRIVATE_KEY_SIZE = 64;\nexport const SUI_PRIVATE_KEY_PREFIX = 'suiprivkey';\n\nexport type ParsedKeypair = {\n\tschema: SignatureScheme;\n\tsecretKey: Uint8Array;\n};\n\nexport interface SignatureWithBytes {\n\tbytes: string;\n\tsignature: string;\n}\n\n/**\n * TODO: Document\n */\nexport abstract class Signer {\n\tabstract sign(bytes: Uint8Array): Promise<Uint8Array>;\n\t/**\n\t * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,\n\t * it ensures that a signed message is tied to a specific purpose and domain separator is provided\n\t */\n\tasync signWithIntent(bytes: Uint8Array, intent: IntentScope): Promise<SignatureWithBytes> {\n\t\tconst intentMessage = messageWithIntent(intent, bytes);\n\t\tconst digest = blake2b(intentMessage, { dkLen: 32 });\n\n\t\tconst signature = toSerializedSignature({\n\t\t\tsignature: await this.sign(digest),\n\t\t\tsignatureScheme: this.getKeyScheme(),\n\t\t\tpublicKey: this.getPublicKey(),\n\t\t});\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toBase64(bytes),\n\t\t};\n\t}\n\t/**\n\t * Signs provided transaction by calling `signWithIntent()` with a `TransactionData` provided as intent scope\n\t */\n\tasync signTransaction(bytes: Uint8Array) {\n\t\treturn this.signWithIntent(bytes, 'TransactionData');\n\t}\n\t/**\n\t * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope\n\t */\n\tasync signPersonalMessage(bytes: Uint8Array) {\n\t\tconst { signature } = await this.signWithIntent(\n\t\t\tbcs.vector(bcs.u8()).serialize(bytes).toBytes(),\n\t\t\t'PersonalMessage',\n\t\t);\n\n\t\treturn {\n\t\t\tbytes: toBase64(bytes),\n\t\t\tsignature,\n\t\t};\n\t}\n\n\ttoSuiAddress(): string {\n\t\treturn this.getPublicKey().toSuiAddress();\n\t}\n\n\t/**\n\t * Get the key scheme of the keypair: Secp256k1 or ED25519\n\t */\n\tabstract getKeyScheme(): SignatureScheme;\n\n\t/**\n\t * The public key for this keypair\n\t */\n\tabstract getPublicKey(): PublicKey;\n}\n\nexport abstract class Keypair extends Signer {\n\t/**\n\t * This returns the Bech32 secret key string for this keypair.\n\t */\n\tabstract getSecretKey(): string;\n}\n\n/**\n * This returns an ParsedKeypair object based by validating the\n * 33-byte Bech32 encoded string starting with `suiprivkey`, and\n * parse out the signature scheme and the private key in bytes.\n */\nexport function decodeSuiPrivateKey(value: string): ParsedKeypair {\n\tconst { prefix, words } = bech32.decode(value as `${string}1${string}`);\n\tif (prefix !== SUI_PRIVATE_KEY_PREFIX) {\n\t\tthrow new Error('invalid private key prefix');\n\t}\n\tconst extendedSecretKey = new Uint8Array(bech32.fromWords(words));\n\tconst secretKey = extendedSecretKey.slice(1);\n\tconst signatureScheme =\n\t\tSIGNATURE_FLAG_TO_SCHEME[extendedSecretKey[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n\treturn {\n\t\tschema: signatureScheme,\n\t\tsecretKey: secretKey,\n\t};\n}\n\n/**\n * This returns a Bech32 encoded string starting with `suiprivkey`,\n * encoding 33-byte `flag || bytes` for the given the 32-byte private\n * key and its signature scheme.\n */\nexport function encodeSuiPrivateKey(bytes: Uint8Array, scheme: SignatureScheme): string {\n\tif (bytes.length !== PRIVATE_KEY_SIZE) {\n\t\tthrow new Error('Invalid bytes length');\n\t}\n\tconst flag = SIGNATURE_SCHEME_TO_FLAG[scheme];\n\tconst privKeyBytes = new Uint8Array(bytes.length + 1);\n\tprivKeyBytes.set([flag]);\n\tprivKeyBytes.set(bytes, 1);\n\treturn bech32.encode(SUI_PRIVATE_KEY_PREFIX, bech32.toWords(privKeyBytes));\n}\n"],"mappings":"AAGA,SAASA,GAAA,EAAKC,QAAA,QAAgB;AAC9B,SAASC,OAAA,QAAe;AACxB,SAASC,MAAA,QAAc;AAGvB,SAASC,iBAAA,QAAyB;AAElC,SAASC,wBAAA,EAA0BC,wBAAA,QAAgC;AAEnE,SAASC,qBAAA,QAA6B;AAE/B,MAAMC,gBAAA,GAAmB;AACzB,MAAMC,uBAAA,GAA0B;AAChC,MAAMC,sBAAA,GAAyB;AAe/B,MAAeC,MAAA,CAAO;EAAA;AAAA;AAAA;AAAA;EAM5B,MAAMC,eAAeC,KAAA,EAAmBC,MAAA,EAAkD;IACzF,MAAMC,aAAA,GAAgBX,iBAAA,CAAkBU,MAAA,EAAQD,KAAK;IACrD,MAAMG,MAAA,GAASd,OAAA,CAAQa,aAAA,EAAe;MAAEE,KAAA,EAAO;IAAG,CAAC;IAEnD,MAAMC,SAAA,GAAYX,qBAAA,CAAsB;MACvCW,SAAA,EAAW,MAAM,KAAKC,IAAA,CAAKH,MAAM;MACjCI,eAAA,EAAiB,KAAKC,YAAA,CAAa;MACnCC,SAAA,EAAW,KAAKC,YAAA,CAAa;IAC9B,CAAC;IAED,OAAO;MACNL,SAAA;MACAL,KAAA,EAAOZ,QAAA,CAASY,KAAK;IACtB;EACD;EAAA;AAAA;AAAA;EAIA,MAAMW,gBAAgBX,KAAA,EAAmB;IACxC,OAAO,KAAKD,cAAA,CAAeC,KAAA,EAAO,iBAAiB;EACpD;EAAA;AAAA;AAAA;EAIA,MAAMY,oBAAoBZ,KAAA,EAAmB;IAC5C,MAAM;MAAEK;IAAU,IAAI,MAAM,KAAKN,cAAA,CAChCZ,GAAA,CAAI0B,MAAA,CAAO1B,GAAA,CAAI2B,EAAA,CAAG,CAAC,EAAEC,SAAA,CAAUf,KAAK,EAAEgB,OAAA,CAAQ,GAC9C,iBACD;IAEA,OAAO;MACNhB,KAAA,EAAOZ,QAAA,CAASY,KAAK;MACrBK;IACD;EACD;EAEAY,aAAA,EAAuB;IACtB,OAAO,KAAKP,YAAA,CAAa,EAAEO,YAAA,CAAa;EACzC;AAWD;AAEO,MAAeC,OAAA,SAAgBpB,MAAA,CAAO;AAYtC,SAASqB,oBAAoBC,KAAA,EAA8B;EACjE,MAAM;IAAEC,MAAA;IAAQC;EAAM,IAAIhC,MAAA,CAAOiC,MAAA,CAAOH,KAA8B;EACtE,IAAIC,MAAA,KAAWxB,sBAAA,EAAwB;IACtC,MAAM,IAAI2B,KAAA,CAAM,4BAA4B;EAC7C;EACA,MAAMC,iBAAA,GAAoB,IAAIC,UAAA,CAAWpC,MAAA,CAAOqC,SAAA,CAAUL,KAAK,CAAC;EAChE,MAAMM,SAAA,GAAYH,iBAAA,CAAkBI,KAAA,CAAM,CAAC;EAC3C,MAAMtB,eAAA,GACLf,wBAAA,CAAyBiC,iBAAA,CAAkB,CAAC,CAA0C;EACvF,OAAO;IACNK,MAAA,EAAQvB,eAAA;IACRqB;EACD;AACD;AAOO,SAASG,oBAAoB/B,KAAA,EAAmBgC,MAAA,EAAiC;EACvF,IAAIhC,KAAA,CAAMiC,MAAA,KAAWtC,gBAAA,EAAkB;IACtC,MAAM,IAAI6B,KAAA,CAAM,sBAAsB;EACvC;EACA,MAAMU,IAAA,GAAOzC,wBAAA,CAAyBuC,MAAM;EAC5C,MAAMG,YAAA,GAAe,IAAIT,UAAA,CAAW1B,KAAA,CAAMiC,MAAA,GAAS,CAAC;EACpDE,YAAA,CAAaC,GAAA,CAAI,CAACF,IAAI,CAAC;EACvBC,YAAA,CAAaC,GAAA,CAAIpC,KAAA,EAAO,CAAC;EACzB,OAAOV,MAAA,CAAO+C,MAAA,CAAOxC,sBAAA,EAAwBP,MAAA,CAAOgD,OAAA,CAAQH,YAAY,CAAC;AAC1E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}