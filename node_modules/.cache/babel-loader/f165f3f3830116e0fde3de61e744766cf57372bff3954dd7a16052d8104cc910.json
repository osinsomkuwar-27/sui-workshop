{"ast":null,"code":"import { jwtDecode } from \"./jwt-decode.js\";\nimport { normalizeZkLoginIssuer } from \"./utils.js\";\nfunction base64UrlCharTo6Bits(base64UrlChar) {\n  if (base64UrlChar.length !== 1) {\n    throw new Error(\"Invalid base64Url character: \" + base64UrlChar);\n  }\n  const base64UrlCharacterSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n  const index = base64UrlCharacterSet.indexOf(base64UrlChar);\n  if (index === -1) {\n    throw new Error(\"Invalid base64Url character: \" + base64UrlChar);\n  }\n  const binaryString = index.toString(2).padStart(6, \"0\");\n  const bits = Array.from(binaryString).map(Number);\n  return bits;\n}\nfunction base64UrlStringToBitVector(base64UrlString) {\n  let bitVector = [];\n  for (let i = 0; i < base64UrlString.length; i++) {\n    const base64UrlChar = base64UrlString.charAt(i);\n    const bits = base64UrlCharTo6Bits(base64UrlChar);\n    bitVector = bitVector.concat(bits);\n  }\n  return bitVector;\n}\nfunction decodeBase64URL(s, i) {\n  if (s.length < 2) {\n    throw new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);\n  }\n  let bits = base64UrlStringToBitVector(s);\n  const firstCharOffset = i % 4;\n  if (firstCharOffset === 0) {} else if (firstCharOffset === 1) {\n    bits = bits.slice(2);\n  } else if (firstCharOffset === 2) {\n    bits = bits.slice(4);\n  } else {\n    throw new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i}))`);\n  }\n  const lastCharOffset = (i + s.length - 1) % 4;\n  if (lastCharOffset === 3) {} else if (lastCharOffset === 2) {\n    bits = bits.slice(0, bits.length - 2);\n  } else if (lastCharOffset === 1) {\n    bits = bits.slice(0, bits.length - 4);\n  } else {\n    throw new Error(`Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i}))`);\n  }\n  if (bits.length % 8 !== 0) {\n    throw new Error(`We should never reach here...`);\n  }\n  const bytes = new Uint8Array(Math.floor(bits.length / 8));\n  let currentByteIndex = 0;\n  for (let i2 = 0; i2 < bits.length; i2 += 8) {\n    const bitChunk = bits.slice(i2, i2 + 8);\n    const byte = parseInt(bitChunk.join(\"\"), 2);\n    bytes[currentByteIndex++] = byte;\n  }\n  return new TextDecoder().decode(bytes);\n}\nfunction verifyExtendedClaim(claim) {\n  if (!(claim.slice(-1) === \"}\" || claim.slice(-1) === \",\")) {\n    throw new Error(\"Invalid claim\");\n  }\n  const json = JSON.parse(\"{\" + claim.slice(0, -1) + \"}\");\n  if (Object.keys(json).length !== 1) {\n    throw new Error(\"Invalid claim\");\n  }\n  const key = Object.keys(json)[0];\n  return [key, json[key]];\n}\nfunction extractClaimValue(claim, claimName) {\n  const extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);\n  const [name, value] = verifyExtendedClaim(extendedClaim);\n  if (name !== claimName) {\n    throw new Error(`Invalid field name: found ${name} expected ${claimName}`);\n  }\n  return value;\n}\nfunction decodeJwt(jwt) {\n  const {\n    iss,\n    aud,\n    sub,\n    ...decodedJWT\n  } = jwtDecode(jwt);\n  if (!sub || !iss || !aud) {\n    throw new Error(\"Missing jwt data\");\n  }\n  if (Array.isArray(aud)) {\n    throw new Error(\"Not supported aud. Aud is an array, string was expected.\");\n  }\n  return {\n    ...decodedJWT,\n    iss: normalizeZkLoginIssuer(iss),\n    rawIss: iss,\n    aud,\n    sub\n  };\n}\nexport { decodeJwt, extractClaimValue };","map":{"version":3,"names":["jwtDecode","normalizeZkLoginIssuer","base64UrlCharTo6Bits","base64UrlChar","length","Error","base64UrlCharacterSet","index","indexOf","binaryString","toString","padStart","bits","Array","from","map","Number","base64UrlStringToBitVector","base64UrlString","bitVector","i","charAt","concat","decodeBase64URL","s","firstCharOffset","slice","lastCharOffset","bytes","Uint8Array","Math","floor","currentByteIndex","i2","bitChunk","byte","parseInt","join","TextDecoder","decode","verifyExtendedClaim","claim","json","JSON","parse","Object","keys","key","extractClaimValue","claimName","extendedClaim","value","indexMod4","name","decodeJwt","jwt","iss","aud","sub","decodedJWT","isArray","rawIss"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\zklogin\\jwt-utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { JwtPayload } from './jwt-decode.js';\nimport { jwtDecode } from './jwt-decode.js';\nimport { normalizeZkLoginIssuer } from './utils.js';\n\nfunction base64UrlCharTo6Bits(base64UrlChar: string): number[] {\n\tif (base64UrlChar.length !== 1) {\n\t\tthrow new Error('Invalid base64Url character: ' + base64UrlChar);\n\t}\n\n\t// Define the base64URL character set\n\tconst base64UrlCharacterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n\t// Find the index of the input character in the base64URL character set\n\tconst index = base64UrlCharacterSet.indexOf(base64UrlChar);\n\n\tif (index === -1) {\n\t\tthrow new Error('Invalid base64Url character: ' + base64UrlChar);\n\t}\n\n\t// Convert the index to a 6-bit binary string\n\tconst binaryString = index.toString(2).padStart(6, '0');\n\n\t// Convert the binary string to an array of bits\n\tconst bits = Array.from(binaryString).map(Number);\n\n\treturn bits;\n}\n\nfunction base64UrlStringToBitVector(base64UrlString: string) {\n\tlet bitVector: number[] = [];\n\tfor (let i = 0; i < base64UrlString.length; i++) {\n\t\tconst base64UrlChar = base64UrlString.charAt(i);\n\t\tconst bits = base64UrlCharTo6Bits(base64UrlChar);\n\t\tbitVector = bitVector.concat(bits);\n\t}\n\treturn bitVector;\n}\n\nfunction decodeBase64URL(s: string, i: number): string {\n\tif (s.length < 2) {\n\t\tthrow new Error(`Input (s = ${s}) is not tightly packed because s.length < 2`);\n\t}\n\tlet bits = base64UrlStringToBitVector(s);\n\n\tconst firstCharOffset = i % 4;\n\tif (firstCharOffset === 0) {\n\t\t// skip\n\t} else if (firstCharOffset === 1) {\n\t\tbits = bits.slice(2);\n\t} else if (firstCharOffset === 2) {\n\t\tbits = bits.slice(4);\n\t} else {\n\t\t// (offset == 3)\n\t\tthrow new Error(`Input (s = ${s}) is not tightly packed because i%4 = 3 (i = ${i}))`);\n\t}\n\n\tconst lastCharOffset = (i + s.length - 1) % 4;\n\tif (lastCharOffset === 3) {\n\t\t// skip\n\t} else if (lastCharOffset === 2) {\n\t\tbits = bits.slice(0, bits.length - 2);\n\t} else if (lastCharOffset === 1) {\n\t\tbits = bits.slice(0, bits.length - 4);\n\t} else {\n\t\t// (offset == 0)\n\t\tthrow new Error(\n\t\t\t`Input (s = ${s}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${i}))`,\n\t\t);\n\t}\n\n\tif (bits.length % 8 !== 0) {\n\t\tthrow new Error(`We should never reach here...`);\n\t}\n\n\tconst bytes = new Uint8Array(Math.floor(bits.length / 8));\n\tlet currentByteIndex = 0;\n\tfor (let i = 0; i < bits.length; i += 8) {\n\t\tconst bitChunk = bits.slice(i, i + 8);\n\n\t\t// Convert the 8-bit chunk to a byte and add it to the bytes array\n\t\tconst byte = parseInt(bitChunk.join(''), 2);\n\t\tbytes[currentByteIndex++] = byte;\n\t}\n\treturn new TextDecoder().decode(bytes);\n}\n\nfunction verifyExtendedClaim(claim: string) {\n\t// Last character of each extracted_claim must be '}' or ','\n\tif (!(claim.slice(-1) === '}' || claim.slice(-1) === ',')) {\n\t\tthrow new Error('Invalid claim');\n\t}\n\n\t// A hack to parse the JSON key-value pair.. but it should work\n\tconst json = JSON.parse('{' + claim.slice(0, -1) + '}');\n\tif (Object.keys(json).length !== 1) {\n\t\tthrow new Error('Invalid claim');\n\t}\n\tconst key = Object.keys(json)[0];\n\treturn [key, json[key]];\n}\n\nexport type Claim = {\n\tvalue: string;\n\tindexMod4: number;\n};\n\nexport function extractClaimValue<R>(claim: Claim, claimName: string): R {\n\tconst extendedClaim = decodeBase64URL(claim.value, claim.indexMod4);\n\tconst [name, value] = verifyExtendedClaim(extendedClaim);\n\tif (name !== claimName) {\n\t\tthrow new Error(`Invalid field name: found ${name} expected ${claimName}`);\n\t}\n\treturn value;\n}\n\nexport function decodeJwt(jwt: string): Omit<JwtPayload, 'iss' | 'aud' | 'sub'> & {\n\tiss: string;\n\taud: string;\n\tsub: string;\n\trawIss: string;\n} {\n\tconst { iss, aud, sub, ...decodedJWT } = jwtDecode(jwt);\n\n\tif (!sub || !iss || !aud) {\n\t\tthrow new Error('Missing jwt data');\n\t}\n\n\tif (Array.isArray(aud)) {\n\t\tthrow new Error('Not supported aud. Aud is an array, string was expected.');\n\t}\n\n\treturn {\n\t\t...decodedJWT,\n\t\tiss: normalizeZkLoginIssuer(iss),\n\t\trawIss: iss,\n\t\taud,\n\t\tsub,\n\t};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}