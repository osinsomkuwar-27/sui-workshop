{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _client, _lastDigest;\nimport { bcs } from \"../../bcs/index.js\";\nimport { ObjectCache } from \"../ObjectCache.js\";\nimport { isTransaction } from \"../Transaction.js\";\nclass CachingTransactionExecutor {\n  constructor({\n    client,\n    ...options\n  }) {\n    __privateAdd(this, _client);\n    __privateAdd(this, _lastDigest, null);\n    __privateSet(this, _client, client);\n    this.cache = new ObjectCache(options);\n  }\n  /**\n   * Clears all Owned objects\n   * Immutable objects, Shared objects, and Move function definitions will be preserved\n   */\n  async reset() {\n    await Promise.all([this.cache.clearOwnedObjects(), this.cache.clearCustom(), this.waitForLastTransaction()]);\n  }\n  async buildTransaction({\n    transaction,\n    ...options\n  }) {\n    transaction.addBuildPlugin(this.cache.asPlugin());\n    return transaction.build({\n      client: __privateGet(this, _client),\n      ...options\n    });\n  }\n  async executeTransaction({\n    transaction,\n    options,\n    ...input\n  }) {\n    const bytes = isTransaction(transaction) ? await this.buildTransaction({\n      transaction\n    }) : transaction;\n    const results = await __privateGet(this, _client).executeTransactionBlock({\n      ...input,\n      transactionBlock: bytes,\n      options: {\n        ...options,\n        showRawEffects: true\n      }\n    });\n    if (results.rawEffects) {\n      const effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n      await this.applyEffects(effects);\n    }\n    return results;\n  }\n  async signAndExecuteTransaction({\n    options,\n    transaction,\n    ...input\n  }) {\n    transaction.setSenderIfNotSet(input.signer.toSuiAddress());\n    const bytes = await this.buildTransaction({\n      transaction\n    });\n    const {\n      signature\n    } = await input.signer.signTransaction(bytes);\n    const results = await this.executeTransaction({\n      transaction: bytes,\n      signature,\n      options\n    });\n    return results;\n  }\n  async applyEffects(effects) {\n    __privateSet(this, _lastDigest, effects.V2?.transactionDigest ?? null);\n    await this.cache.applyEffects(effects);\n  }\n  async waitForLastTransaction() {\n    if (__privateGet(this, _lastDigest)) {\n      await __privateGet(this, _client).waitForTransaction({\n        digest: __privateGet(this, _lastDigest)\n      });\n      __privateSet(this, _lastDigest, null);\n    }\n  }\n}\n_client = new WeakMap();\n_lastDigest = new WeakMap();\nexport { CachingTransactionExecutor };","map":{"version":3,"names":["_client","_lastDigest","bcs","ObjectCache","isTransaction","CachingTransactionExecutor","constructor","client","options","__privateAdd","__privateSet","cache","reset","Promise","all","clearOwnedObjects","clearCustom","waitForLastTransaction","buildTransaction","transaction","addBuildPlugin","asPlugin","build","__privateGet","executeTransaction","input","bytes","results","executeTransactionBlock","transactionBlock","showRawEffects","rawEffects","effects","TransactionEffects","parse","Uint8Array","from","applyEffects","signAndExecuteTransaction","setSenderIfNotSet","signer","toSuiAddress","signature","signTransaction","V2","transactionDigest","waitForTransaction","digest","WeakMap"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\executor\\caching.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../../bcs/index.js';\nimport type { ExecuteTransactionBlockParams, SuiClient } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { BuildTransactionOptions } from '../json-rpc-resolver.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { ObjectCache } from '../ObjectCache.js';\nimport type { Transaction } from '../Transaction.js';\nimport { isTransaction } from '../Transaction.js';\n\nexport class CachingTransactionExecutor {\n\t#client: SuiClient;\n\t#lastDigest: string | null = null;\n\tcache: ObjectCache;\n\n\tconstructor({\n\t\tclient,\n\t\t...options\n\t}: ObjectCacheOptions & {\n\t\tclient: SuiClient;\n\t}) {\n\t\tthis.#client = client;\n\t\tthis.cache = new ObjectCache(options);\n\t}\n\n\t/**\n\t * Clears all Owned objects\n\t * Immutable objects, Shared objects, and Move function definitions will be preserved\n\t */\n\tasync reset() {\n\t\tawait Promise.all([\n\t\t\tthis.cache.clearOwnedObjects(),\n\t\t\tthis.cache.clearCustom(),\n\t\t\tthis.waitForLastTransaction(),\n\t\t]);\n\t}\n\n\tasync buildTransaction({\n\t\ttransaction,\n\t\t...options\n\t}: { transaction: Transaction } & BuildTransactionOptions) {\n\t\ttransaction.addBuildPlugin(this.cache.asPlugin());\n\t\treturn transaction.build({\n\t\t\tclient: this.#client,\n\t\t\t...options,\n\t\t});\n\t}\n\n\tasync executeTransaction({\n\t\ttransaction,\n\t\toptions,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction | Uint8Array;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock'>) {\n\t\tconst bytes = isTransaction(transaction)\n\t\t\t? await this.buildTransaction({ transaction })\n\t\t\t: transaction;\n\n\t\tconst results = await this.#client.executeTransactionBlock({\n\t\t\t...input,\n\t\t\ttransactionBlock: bytes,\n\t\t\toptions: {\n\t\t\t\t...options,\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tif (results.rawEffects) {\n\t\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n\t\t\tawait this.applyEffects(effects);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tasync signAndExecuteTransaction({\n\t\toptions,\n\t\ttransaction,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction;\n\n\t\tsigner: Signer;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock' | 'signature'>) {\n\t\ttransaction.setSenderIfNotSet(input.signer.toSuiAddress());\n\t\tconst bytes = await this.buildTransaction({ transaction });\n\t\tconst { signature } = await input.signer.signTransaction(bytes);\n\t\tconst results = await this.executeTransaction({\n\t\t\ttransaction: bytes,\n\t\t\tsignature,\n\t\t\toptions,\n\t\t});\n\n\t\treturn results;\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tthis.#lastDigest = effects.V2?.transactionDigest ?? null;\n\t\tawait this.cache.applyEffects(effects);\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tif (this.#lastDigest) {\n\t\t\tawait this.#client.waitForTransaction({ digest: this.#lastDigest });\n\t\t\tthis.#lastDigest = null;\n\t\t}\n\t}\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,OAAA,EAAAC,WAAA;AAGA,SAASC,GAAA,QAAW;AAKpB,SAASC,WAAA,QAAmB;AAE5B,SAASC,aAAA,QAAqB;AAEvB,MAAMC,0BAAA,CAA2B;EAKvCC,YAAY;IACXC,MAAA;IACA,GAAGC;EACJ,GAEG;IATHC,YAAA,OAAAT,OAAA;IACAS,YAAA,OAAAR,WAAA,EAA6B;IAS5BS,YAAA,OAAKV,OAAA,EAAUO,MAAA;IACf,KAAKI,KAAA,GAAQ,IAAIR,WAAA,CAAYK,OAAO;EACrC;EAAA;AAAA;AAAA;AAAA;EAMA,MAAMI,MAAA,EAAQ;IACb,MAAMC,OAAA,CAAQC,GAAA,CAAI,CACjB,KAAKH,KAAA,CAAMI,iBAAA,CAAkB,GAC7B,KAAKJ,KAAA,CAAMK,WAAA,CAAY,GACvB,KAAKC,sBAAA,CAAuB,EAC5B;EACF;EAEA,MAAMC,iBAAiB;IACtBC,WAAA;IACA,GAAGX;EACJ,GAA2D;IAC1DW,WAAA,CAAYC,cAAA,CAAe,KAAKT,KAAA,CAAMU,QAAA,CAAS,CAAC;IAChD,OAAOF,WAAA,CAAYG,KAAA,CAAM;MACxBf,MAAA,EAAQgB,YAAA,OAAKvB,OAAA;MACb,GAAGQ;IACJ,CAAC;EACF;EAEA,MAAMgB,mBAAmB;IACxBL,WAAA;IACAX,OAAA;IACA,GAAGiB;EACJ,GAE6D;IAC5D,MAAMC,KAAA,GAAQtB,aAAA,CAAce,WAAW,IACpC,MAAM,KAAKD,gBAAA,CAAiB;MAAEC;IAAY,CAAC,IAC3CA,WAAA;IAEH,MAAMQ,OAAA,GAAU,MAAMJ,YAAA,OAAKvB,OAAA,EAAQ4B,uBAAA,CAAwB;MAC1D,GAAGH,KAAA;MACHI,gBAAA,EAAkBH,KAAA;MAClBlB,OAAA,EAAS;QACR,GAAGA,OAAA;QACHsB,cAAA,EAAgB;MACjB;IACD,CAAC;IAED,IAAIH,OAAA,CAAQI,UAAA,EAAY;MACvB,MAAMC,OAAA,GAAU9B,GAAA,CAAI+B,kBAAA,CAAmBC,KAAA,CAAMC,UAAA,CAAWC,IAAA,CAAKT,OAAA,CAAQI,UAAU,CAAC;MAChF,MAAM,KAAKM,YAAA,CAAaL,OAAO;IAChC;IAEA,OAAOL,OAAA;EACR;EAEA,MAAMW,0BAA0B;IAC/B9B,OAAA;IACAW,WAAA;IACA,GAAGM;EACJ,GAI2E;IAC1EN,WAAA,CAAYoB,iBAAA,CAAkBd,KAAA,CAAMe,MAAA,CAAOC,YAAA,CAAa,CAAC;IACzD,MAAMf,KAAA,GAAQ,MAAM,KAAKR,gBAAA,CAAiB;MAAEC;IAAY,CAAC;IACzD,MAAM;MAAEuB;IAAU,IAAI,MAAMjB,KAAA,CAAMe,MAAA,CAAOG,eAAA,CAAgBjB,KAAK;IAC9D,MAAMC,OAAA,GAAU,MAAM,KAAKH,kBAAA,CAAmB;MAC7CL,WAAA,EAAaO,KAAA;MACbgB,SAAA;MACAlC;IACD,CAAC;IAED,OAAOmB,OAAA;EACR;EAEA,MAAMU,aAAaL,OAAA,EAAmD;IACrEtB,YAAA,OAAKT,WAAA,EAAc+B,OAAA,CAAQY,EAAA,EAAIC,iBAAA,IAAqB;IACpD,MAAM,KAAKlC,KAAA,CAAM0B,YAAA,CAAaL,OAAO;EACtC;EAEA,MAAMf,uBAAA,EAAyB;IAC9B,IAAIM,YAAA,OAAKtB,WAAA,GAAa;MACrB,MAAMsB,YAAA,OAAKvB,OAAA,EAAQ8C,kBAAA,CAAmB;QAAEC,MAAA,EAAQxB,YAAA,OAAKtB,WAAA;MAAY,CAAC;MAClES,YAAA,OAAKT,WAAA,EAAc;IACpB;EACD;AACD;AAjGCD,OAAA,OAAAgD,OAAA;AACA/C,WAAA,OAAA+C,OAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}