{"ast":null,"code":"import { isValidNamedPackage, isValidNamedType } from \"../../utils/move-registry.js\";\nconst NAME_SEPARATOR = \"/\";\nconst findTransactionBlockNames = builder => {\n  const packages = /* @__PURE__ */new Set();\n  const types = /* @__PURE__ */new Set();\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      getNamesFromTypeList([command.MakeMoveVec.type]).forEach(type => {\n        types.add(type);\n      });\n      continue;\n    }\n    if (!(\"MoveCall\" in command)) continue;\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const pkg = tx.package.split(\"::\")[0];\n    if (pkg.includes(NAME_SEPARATOR)) {\n      if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n      packages.add(pkg);\n    }\n    getNamesFromTypeList(tx.typeArguments ?? []).forEach(type => {\n      types.add(type);\n    });\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n};\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */new Set();\n  for (const type of types) {\n    if (type.includes(NAME_SEPARATOR)) {\n      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n      names.add(type);\n    }\n  }\n  return [...names];\n}\nconst replaceNames = (builder, cache) => {\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      if (!command.MakeMoveVec.type.includes(NAME_SEPARATOR)) continue;\n      if (!cache.types[command.MakeMoveVec.type]) throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n      command.MakeMoveVec.type = cache.types[command.MakeMoveVec.type];\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (name.includes(NAME_SEPARATOR) && !cache.packages[name]) throw new Error(`No address found for package: ${name}`);\n    if (name.includes(NAME_SEPARATOR)) {\n      nameParts[0] = cache.packages[name];\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!types[i].includes(NAME_SEPARATOR)) continue;\n      if (!cache.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n      types[i] = cache.types[types[i]];\n    }\n    tx.typeArguments = types;\n  }\n};\nconst listToRequests = (names, batchSize) => {\n  const results = [];\n  const uniqueNames = deduplicate(names.packages);\n  const uniqueTypes = deduplicate(names.types);\n  for (const [idx, name] of uniqueNames.entries()) {\n    results.push({\n      id: idx,\n      type: \"package\",\n      name\n    });\n  }\n  for (const [idx, type] of uniqueTypes.entries()) {\n    results.push({\n      id: idx + uniqueNames.length,\n      type: \"moveType\",\n      name: type\n    });\n  }\n  return batch(results, batchSize);\n};\nconst deduplicate = arr => [...new Set(arr)];\nconst batch = (arr, size) => {\n  const batches = [];\n  for (let i = 0; i < arr.length; i += size) {\n    batches.push(arr.slice(i, i + size));\n  }\n  return batches;\n};\nexport { findTransactionBlockNames, listToRequests, replaceNames };","map":{"version":3,"names":["isValidNamedPackage","isValidNamedType","NAME_SEPARATOR","findTransactionBlockNames","builder","packages","Set","types","command","commands","MakeMoveVec","type","getNamesFromTypeList","forEach","add","tx","MoveCall","pkg","package","split","includes","Error","typeArguments","names","replaceNames","cache","nameParts","name","join","i","length","listToRequests","batchSize","results","uniqueNames","deduplicate","uniqueTypes","idx","entries","push","id","batch","arr","size","batches","slice"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\plugins\\utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidNamedPackage, isValidNamedType } from '../../utils/move-registry.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nexport type NamedPackagesPluginCache = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\nconst NAME_SEPARATOR = '/';\n\nexport type NameResolutionRequest = {\n\tid: number;\n\ttype: 'package' | 'moveType';\n\tname: string;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport const findTransactionBlockNames = (\n\tbuilder: TransactionDataBuilder,\n): { packages: string[]; types: string[] } => {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\ttypes.add(type);\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tif (!('MoveCall' in command)) continue;\n\t\tconst tx = command.MoveCall;\n\n\t\tif (!tx) continue;\n\n\t\tconst pkg = tx.package.split('::')[0];\n\t\tif (pkg.includes(NAME_SEPARATOR)) {\n\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\tpackages.add(pkg);\n\t\t}\n\n\t\tgetNamesFromTypeList(tx.typeArguments ?? []).forEach((type) => {\n\t\t\ttypes.add(type);\n\t\t});\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n};\n\n/**\n * Returns a list of unique types that include a name\n * from the given list.\n *  */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (type.includes(NAME_SEPARATOR)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn [...names];\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport const replaceNames = (builder: TransactionDataBuilder, cache: NamedPackagesPluginCache) => {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!command.MakeMoveVec.type.includes(NAME_SEPARATOR)) continue;\n\t\t\tif (!cache.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = cache.types[command.MakeMoveVec.type];\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (name.includes(NAME_SEPARATOR) && !cache.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (name.includes(NAME_SEPARATOR)) {\n\t\t\tnameParts[0] = cache.packages[name];\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!types[i].includes(NAME_SEPARATOR)) continue;\n\n\t\t\tif (!cache.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = cache.types[types[i]];\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n};\n\nexport const listToRequests = (\n\tnames: { packages: string[]; types: string[] },\n\tbatchSize: number,\n): NameResolutionRequest[][] => {\n\tconst results: NameResolutionRequest[] = [];\n\tconst uniqueNames = deduplicate(names.packages);\n\tconst uniqueTypes = deduplicate(names.types);\n\n\tfor (const [idx, name] of uniqueNames.entries()) {\n\t\tresults.push({ id: idx, type: 'package', name } as NameResolutionRequest);\n\t}\n\tfor (const [idx, type] of uniqueTypes.entries()) {\n\t\tresults.push({\n\t\t\tid: idx + uniqueNames.length,\n\t\t\ttype: 'moveType',\n\t\t\tname: type,\n\t\t} as NameResolutionRequest);\n\t}\n\n\treturn batch(results, batchSize);\n};\n\nconst deduplicate = <T>(arr: T[]): T[] => [...new Set(arr)];\n\nconst batch = <T>(arr: T[], size: number): T[][] => {\n\tconst batches = [];\n\tfor (let i = 0; i < arr.length; i += size) {\n\t\tbatches.push(arr.slice(i, i + size));\n\t}\n\treturn batches;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}