{"ast":null,"code":"import { hexToBytes } from \"@noble/hashes/utils\";\nimport { poseidonHash } from \"./poseidon.js\";\nconst MAX_KEY_CLAIM_NAME_LENGTH = 32;\nconst MAX_KEY_CLAIM_VALUE_LENGTH = 115;\nconst MAX_AUD_VALUE_LENGTH = 145;\nconst PACK_WIDTH = 248;\nfunction findFirstNonZeroIndex(bytes) {\n  for (let i = 0; i < bytes.length; i++) {\n    if (bytes[i] !== 0) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction toPaddedBigEndianBytes(num, width) {\n  const hex = num.toString(16);\n  return hexToBytes(hex.padStart(width * 2, \"0\").slice(-width * 2));\n}\nfunction toBigEndianBytes(num, width) {\n  const bytes = toPaddedBigEndianBytes(num, width);\n  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);\n  if (firstNonZeroIndex === -1) {\n    return new Uint8Array([0]);\n  }\n  return bytes.slice(firstNonZeroIndex);\n}\nfunction getExtendedEphemeralPublicKey(publicKey) {\n  return publicKey.toSuiPublicKey();\n}\nfunction chunkArray(array, chunk_size) {\n  const chunks = Array(Math.ceil(array.length / chunk_size));\n  const revArray = array.reverse();\n  for (let i = 0; i < chunks.length; i++) {\n    chunks[i] = revArray.slice(i * chunk_size, (i + 1) * chunk_size).reverse();\n  }\n  return chunks.reverse();\n}\nfunction bytesBEToBigInt(bytes) {\n  const hex = bytes.map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  if (hex.length === 0) {\n    return BigInt(0);\n  }\n  return BigInt(\"0x\" + hex);\n}\nfunction hashASCIIStrToField(str, maxSize) {\n  if (str.length > maxSize) {\n    throw new Error(`String ${str} is longer than ${maxSize} chars`);\n  }\n  const strPadded = str.padEnd(maxSize, String.fromCharCode(0)).split(\"\").map(c => c.charCodeAt(0));\n  const chunkSize = PACK_WIDTH / 8;\n  const packed = chunkArray(strPadded, chunkSize).map(chunk => bytesBEToBigInt(chunk));\n  return poseidonHash(packed);\n}\nfunction genAddressSeed(salt, name, value, aud, max_name_length = MAX_KEY_CLAIM_NAME_LENGTH, max_value_length = MAX_KEY_CLAIM_VALUE_LENGTH, max_aud_length = MAX_AUD_VALUE_LENGTH) {\n  return poseidonHash([hashASCIIStrToField(name, max_name_length), hashASCIIStrToField(value, max_value_length), hashASCIIStrToField(aud, max_aud_length), poseidonHash([BigInt(salt)])]);\n}\nfunction normalizeZkLoginIssuer(iss) {\n  if (iss === \"accounts.google.com\") {\n    return \"https://accounts.google.com\";\n  }\n  return iss;\n}\nexport { chunkArray, genAddressSeed, getExtendedEphemeralPublicKey, hashASCIIStrToField, normalizeZkLoginIssuer, toBigEndianBytes, toPaddedBigEndianBytes };","map":{"version":3,"names":["hexToBytes","poseidonHash","MAX_KEY_CLAIM_NAME_LENGTH","MAX_KEY_CLAIM_VALUE_LENGTH","MAX_AUD_VALUE_LENGTH","PACK_WIDTH","findFirstNonZeroIndex","bytes","i","length","toPaddedBigEndianBytes","num","width","hex","toString","padStart","slice","toBigEndianBytes","firstNonZeroIndex","Uint8Array","getExtendedEphemeralPublicKey","publicKey","toSuiPublicKey","chunkArray","array","chunk_size","chunks","Array","Math","ceil","revArray","reverse","bytesBEToBigInt","map","b","join","BigInt","hashASCIIStrToField","str","maxSize","Error","strPadded","padEnd","String","fromCharCode","split","c","charCodeAt","chunkSize","packed","chunk","genAddressSeed","salt","name","value","aud","max_name_length","max_value_length","max_aud_length","normalizeZkLoginIssuer","iss"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\zklogin\\utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { hexToBytes } from '@noble/hashes/utils';\n\nimport type { PublicKey } from '../cryptography/publickey.js';\nimport { poseidonHash } from './poseidon.js';\n\nconst MAX_KEY_CLAIM_NAME_LENGTH = 32;\nconst MAX_KEY_CLAIM_VALUE_LENGTH = 115;\nconst MAX_AUD_VALUE_LENGTH = 145;\nconst PACK_WIDTH = 248;\n\nfunction findFirstNonZeroIndex(bytes: Uint8Array) {\n\tfor (let i = 0; i < bytes.length; i++) {\n\t\tif (bytes[i] !== 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n// Derive bytearray from num where the bytearray is padded to the left with 0s to the specified width.\nexport function toPaddedBigEndianBytes(num: bigint, width: number): Uint8Array {\n\tconst hex = num.toString(16);\n\treturn hexToBytes(hex.padStart(width * 2, '0').slice(-width * 2));\n}\n\n// Derive bytearray from num where the bytearray is not padded with 0.\nexport function toBigEndianBytes(num: bigint, width: number): Uint8Array {\n\tconst bytes = toPaddedBigEndianBytes(num, width);\n\n\tconst firstNonZeroIndex = findFirstNonZeroIndex(bytes);\n\n\tif (firstNonZeroIndex === -1) {\n\t\treturn new Uint8Array([0]);\n\t}\n\n\treturn bytes.slice(firstNonZeroIndex);\n}\n\nexport function getExtendedEphemeralPublicKey(publicKey: PublicKey) {\n\treturn publicKey.toSuiPublicKey();\n}\n\n/**\n * Splits an array into chunks of size chunk_size. If the array is not evenly\n * divisible by chunk_size, the first chunk will be smaller than chunk_size.\n *\n * E.g., arrayChunk([1, 2, 3, 4, 5], 2) => [[1], [2, 3], [4, 5]]\n *\n * Note: Can be made more efficient by avoiding the reverse() calls.\n */\nexport function chunkArray<T>(array: T[], chunk_size: number): T[][] {\n\tconst chunks = Array(Math.ceil(array.length / chunk_size));\n\tconst revArray = array.reverse();\n\tfor (let i = 0; i < chunks.length; i++) {\n\t\tchunks[i] = revArray.slice(i * chunk_size, (i + 1) * chunk_size).reverse();\n\t}\n\treturn chunks.reverse();\n}\n\nfunction bytesBEToBigInt(bytes: number[]): bigint {\n\tconst hex = bytes.map((b) => b.toString(16).padStart(2, '0')).join('');\n\tif (hex.length === 0) {\n\t\treturn BigInt(0);\n\t}\n\treturn BigInt('0x' + hex);\n}\n\n// hashes an ASCII string to a field element\nexport function hashASCIIStrToField(str: string, maxSize: number) {\n\tif (str.length > maxSize) {\n\t\tthrow new Error(`String ${str} is longer than ${maxSize} chars`);\n\t}\n\n\t// Note: Padding with zeroes is safe because we are only using this function to map human-readable sequence of bytes.\n\t// So the ASCII values of those characters will never be zero (null character).\n\tconst strPadded = str\n\t\t.padEnd(maxSize, String.fromCharCode(0))\n\t\t.split('')\n\t\t.map((c) => c.charCodeAt(0));\n\n\tconst chunkSize = PACK_WIDTH / 8;\n\tconst packed = chunkArray(strPadded, chunkSize).map((chunk) => bytesBEToBigInt(chunk));\n\treturn poseidonHash(packed);\n}\n\nexport function genAddressSeed(\n\tsalt: string | bigint,\n\tname: string,\n\tvalue: string,\n\taud: string,\n\tmax_name_length = MAX_KEY_CLAIM_NAME_LENGTH,\n\tmax_value_length = MAX_KEY_CLAIM_VALUE_LENGTH,\n\tmax_aud_length = MAX_AUD_VALUE_LENGTH,\n): bigint {\n\treturn poseidonHash([\n\t\thashASCIIStrToField(name, max_name_length),\n\t\thashASCIIStrToField(value, max_value_length),\n\t\thashASCIIStrToField(aud, max_aud_length),\n\t\tposeidonHash([BigInt(salt)]),\n\t]);\n}\n\nexport function normalizeZkLoginIssuer(iss: string) {\n\tif (iss === 'accounts.google.com') {\n\t\treturn 'https://accounts.google.com';\n\t}\n\treturn iss;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}