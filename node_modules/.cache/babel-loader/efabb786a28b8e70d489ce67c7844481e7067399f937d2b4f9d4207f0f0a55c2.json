{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar _signer, _client, _coinBatchSize, _initialCoinBalance, _minimumCoinBalance, _epochBoundaryWindow, _defaultGasBudget, _maxPoolSize, _sourceCoins, _coinPool, _cache, _objectIdQueues, _buildQueue, _executeQueue, _lastDigest, _cacheLock, _pendingTransactions, _gasPrice, _ParallelTransactionExecutor_instances, getUsedObjects_fn, execute_fn, updateCache_fn, waitForLastDigest_fn, getGasCoin_fn, getGasPrice_fn, refillCoinPool_fn;\nimport { toBase64 } from \"@mysten/bcs\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { Transaction } from \"../Transaction.js\";\nimport { TransactionDataBuilder } from \"../TransactionData.js\";\nimport { CachingTransactionExecutor } from \"./caching.js\";\nimport { ParallelQueue, SerialQueue } from \"./queue.js\";\nimport { getGasCoinFromEffects } from \"./serial.js\";\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n  coinBatchSize: 20,\n  initialCoinBalance: 200000000n,\n  minimumCoinBalance: 50000000n,\n  maxPoolSize: 50,\n  epochBoundaryWindow: 1e3\n};\nclass ParallelTransactionExecutor {\n  constructor(options) {\n    __privateAdd(this, _ParallelTransactionExecutor_instances);\n    __privateAdd(this, _signer);\n    __privateAdd(this, _client);\n    __privateAdd(this, _coinBatchSize);\n    __privateAdd(this, _initialCoinBalance);\n    __privateAdd(this, _minimumCoinBalance);\n    __privateAdd(this, _epochBoundaryWindow);\n    __privateAdd(this, _defaultGasBudget);\n    __privateAdd(this, _maxPoolSize);\n    __privateAdd(this, _sourceCoins);\n    __privateAdd(this, _coinPool, []);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _objectIdQueues, /* @__PURE__ */new Map());\n    __privateAdd(this, _buildQueue, new SerialQueue());\n    __privateAdd(this, _executeQueue);\n    __privateAdd(this, _lastDigest, null);\n    __privateAdd(this, _cacheLock, null);\n    __privateAdd(this, _pendingTransactions, 0);\n    __privateAdd(this, _gasPrice, null);\n    __privateSet(this, _signer, options.signer);\n    __privateSet(this, _client, options.client);\n    __privateSet(this, _coinBatchSize, options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize);\n    __privateSet(this, _initialCoinBalance, options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance);\n    __privateSet(this, _minimumCoinBalance, options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance);\n    __privateSet(this, _defaultGasBudget, options.defaultGasBudget ?? __privateGet(this, _minimumCoinBalance));\n    __privateSet(this, _epochBoundaryWindow, options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow);\n    __privateSet(this, _maxPoolSize, options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize);\n    __privateSet(this, _cache, new CachingTransactionExecutor({\n      client: options.client,\n      cache: options.cache\n    }));\n    __privateSet(this, _executeQueue, new ParallelQueue(__privateGet(this, _maxPoolSize)));\n    __privateSet(this, _sourceCoins, options.sourceCoins ? new Map(options.sourceCoins.map(id => [id, null])) : null);\n  }\n  resetCache() {\n    __privateSet(this, _gasPrice, null);\n    return __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateGet(this, _cache).reset());\n  }\n  async waitForLastTransaction() {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this));\n  }\n  async executeTransaction(transaction, options) {\n    const {\n      promise,\n      resolve,\n      reject\n    } = promiseWithResolvers();\n    const usedObjects = await __privateMethod(this, _ParallelTransactionExecutor_instances, getUsedObjects_fn).call(this, transaction);\n    const execute = () => {\n      __privateGet(this, _executeQueue).runTask(() => {\n        const promise2 = __privateMethod(this, _ParallelTransactionExecutor_instances, execute_fn).call(this, transaction, usedObjects, options);\n        return promise2.then(resolve, reject);\n      });\n    };\n    const conflicts = /* @__PURE__ */new Set();\n    usedObjects.forEach(objectId => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue) {\n        conflicts.add(objectId);\n        __privateGet(this, _objectIdQueues).get(objectId).push(() => {\n          conflicts.delete(objectId);\n          if (conflicts.size === 0) {\n            execute();\n          }\n        });\n      } else {\n        __privateGet(this, _objectIdQueues).set(objectId, []);\n      }\n    });\n    if (conflicts.size === 0) {\n      execute();\n    }\n    return promise;\n  }\n}\n_signer = new WeakMap();\n_client = new WeakMap();\n_coinBatchSize = new WeakMap();\n_initialCoinBalance = new WeakMap();\n_minimumCoinBalance = new WeakMap();\n_epochBoundaryWindow = new WeakMap();\n_defaultGasBudget = new WeakMap();\n_maxPoolSize = new WeakMap();\n_sourceCoins = new WeakMap();\n_coinPool = new WeakMap();\n_cache = new WeakMap();\n_objectIdQueues = new WeakMap();\n_buildQueue = new WeakMap();\n_executeQueue = new WeakMap();\n_lastDigest = new WeakMap();\n_cacheLock = new WeakMap();\n_pendingTransactions = new WeakMap();\n_gasPrice = new WeakMap();\n_ParallelTransactionExecutor_instances = new WeakSet();\ngetUsedObjects_fn = async function (transaction) {\n  const usedObjects = /* @__PURE__ */new Set();\n  let serialized = false;\n  transaction.addSerializationPlugin(async (blockData, _options, next) => {\n    await next();\n    if (serialized) {\n      return;\n    }\n    serialized = true;\n    blockData.inputs.forEach(input => {\n      if (input.Object?.ImmOrOwnedObject?.objectId) {\n        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n      } else if (input.Object?.Receiving?.objectId) {\n        usedObjects.add(input.Object.Receiving.objectId);\n      } else if (input.UnresolvedObject?.objectId && !input.UnresolvedObject.initialSharedVersion) {\n        usedObjects.add(input.UnresolvedObject.objectId);\n      }\n    });\n  });\n  await transaction.prepareForSerialization({\n    client: __privateGet(this, _client)\n  });\n  return usedObjects;\n};\nexecute_fn = async function (transaction, usedObjects, options) {\n  let gasCoin;\n  try {\n    transaction.setSenderIfNotSet(__privateGet(this, _signer).toSuiAddress());\n    await __privateGet(this, _buildQueue).runTask(async () => {\n      const data = transaction.getData();\n      if (!data.gasData.price) {\n        transaction.setGasPrice(await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));\n      }\n      transaction.setGasBudgetIfNotSet(__privateGet(this, _defaultGasBudget));\n      await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);\n      gasCoin = await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);\n      __privateWrapper(this, _pendingTransactions)._++;\n      transaction.setGasPayment([{\n        objectId: gasCoin.id,\n        version: gasCoin.version,\n        digest: gasCoin.digest\n      }]);\n      await __privateGet(this, _cache).buildTransaction({\n        transaction,\n        onlyTransactionKind: true\n      });\n    });\n    const bytes = await transaction.build({\n      client: __privateGet(this, _client)\n    });\n    const {\n      signature\n    } = await __privateGet(this, _signer).signTransaction(bytes);\n    const results = await __privateGet(this, _cache).executeTransaction({\n      transaction: bytes,\n      signature,\n      options: {\n        ...options,\n        showEffects: true\n      }\n    });\n    const effectsBytes = Uint8Array.from(results.rawEffects);\n    const effects = bcs.TransactionEffects.parse(effectsBytes);\n    const gasResult = getGasCoinFromEffects(effects);\n    const gasUsed = effects.V2?.gasUsed;\n    if (gasCoin && gasUsed && gasResult.owner === __privateGet(this, _signer).toSuiAddress()) {\n      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);\n      let usesGasCoin = false;\n      new TransactionDataBuilder(transaction.getData()).mapArguments(arg => {\n        if (arg.$kind === \"GasCoin\") {\n          usesGasCoin = true;\n        }\n        return arg;\n      });\n      if (!usesGasCoin && gasCoin.balance >= __privateGet(this, _minimumCoinBalance)) {\n        __privateGet(this, _coinPool).push({\n          id: gasResult.ref.objectId,\n          version: gasResult.ref.version,\n          digest: gasResult.ref.digest,\n          balance: gasCoin.balance - totalUsed\n        });\n      } else {\n        if (!__privateGet(this, _sourceCoins)) {\n          __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n        }\n        __privateGet(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);\n      }\n    }\n    __privateSet(this, _lastDigest, results.digest);\n    return {\n      digest: results.digest,\n      effects: toBase64(effectsBytes),\n      data: results\n    };\n  } catch (error) {\n    if (gasCoin) {\n      if (!__privateGet(this, _sourceCoins)) {\n        __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n      }\n      __privateGet(this, _sourceCoins).set(gasCoin.id, null);\n    }\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {\n      await Promise.all([__privateGet(this, _cache).cache.deleteObjects([...usedObjects]), __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)]);\n    });\n    throw error;\n  } finally {\n    usedObjects.forEach(objectId => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue && queue.length > 0) {\n        queue.shift()();\n      } else if (queue) {\n        __privateGet(this, _objectIdQueues).delete(objectId);\n      }\n    });\n    __privateWrapper(this, _pendingTransactions)._--;\n  }\n};\nupdateCache_fn = async function (fn) {\n  if (__privateGet(this, _cacheLock)) {\n    await __privateGet(this, _cacheLock);\n  }\n  __privateSet(this, _cacheLock, fn?.().then(() => {\n    __privateSet(this, _cacheLock, null);\n  }, () => {}) ?? null);\n};\nwaitForLastDigest_fn = async function () {\n  const digest = __privateGet(this, _lastDigest);\n  if (digest) {\n    __privateSet(this, _lastDigest, null);\n    await __privateGet(this, _client).waitForTransaction({\n      digest\n    });\n  }\n};\ngetGasCoin_fn = async function () {\n  if (__privateGet(this, _coinPool).length === 0 && __privateGet(this, _pendingTransactions) <= __privateGet(this, _maxPoolSize)) {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);\n  }\n  if (__privateGet(this, _coinPool).length === 0) {\n    throw new Error(\"No coins available\");\n  }\n  const coin = __privateGet(this, _coinPool).shift();\n  return coin;\n};\ngetGasPrice_fn = async function () {\n  const remaining = __privateGet(this, _gasPrice) ? __privateGet(this, _gasPrice).expiration - __privateGet(this, _epochBoundaryWindow) - Date.now() : 0;\n  if (remaining > 0) {\n    return __privateGet(this, _gasPrice).price;\n  }\n  if (__privateGet(this, _gasPrice)) {\n    const timeToNextEpoch = Math.max(__privateGet(this, _gasPrice).expiration + __privateGet(this, _epochBoundaryWindow) - Date.now(), 1e3);\n    await new Promise(resolve => setTimeout(resolve, timeToNextEpoch));\n  }\n  const state = await __privateGet(this, _client).getLatestSuiSystemState();\n  __privateSet(this, _gasPrice, {\n    price: BigInt(state.referenceGasPrice),\n    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)\n  });\n  return __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);\n};\nrefillCoinPool_fn = async function () {\n  const batchSize = Math.min(__privateGet(this, _coinBatchSize), __privateGet(this, _maxPoolSize) - (__privateGet(this, _coinPool).length + __privateGet(this, _pendingTransactions)) + 1);\n  if (batchSize === 0) {\n    return;\n  }\n  const txb = new Transaction();\n  const address = __privateGet(this, _signer).toSuiAddress();\n  txb.setSender(address);\n  if (__privateGet(this, _sourceCoins)) {\n    const refs = [];\n    const ids = [];\n    for (const [id, ref] of __privateGet(this, _sourceCoins)) {\n      if (ref) {\n        refs.push(ref);\n      } else {\n        ids.push(id);\n      }\n    }\n    if (ids.length > 0) {\n      const coins = await __privateGet(this, _client).multiGetObjects({\n        ids\n      });\n      refs.push(...coins.filter(coin => coin.data !== null).map(({\n        data\n      }) => ({\n        objectId: data.objectId,\n        version: data.version,\n        digest: data.digest\n      })));\n    }\n    txb.setGasPayment(refs);\n    __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n  }\n  const amounts = new Array(batchSize).fill(__privateGet(this, _initialCoinBalance));\n  const results = txb.splitCoins(txb.gas, amounts);\n  const coinResults = [];\n  for (let i = 0; i < amounts.length; i++) {\n    coinResults.push(results[i]);\n  }\n  txb.transferObjects(coinResults, address);\n  await this.waitForLastTransaction();\n  const result = await __privateGet(this, _client).signAndExecuteTransaction({\n    transaction: txb,\n    signer: __privateGet(this, _signer),\n    options: {\n      showRawEffects: true\n    }\n  });\n  const effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));\n  effects.V2?.changedObjects.forEach(([id, {\n    outputState\n  }], i) => {\n    if (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n      return;\n    }\n    __privateGet(this, _coinPool).push({\n      id,\n      version: effects.V2.lamportVersion,\n      digest: outputState.ObjectWrite[0],\n      balance: BigInt(__privateGet(this, _initialCoinBalance))\n    });\n  });\n  if (!__privateGet(this, _sourceCoins)) {\n    __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n  }\n  const gasObject = getGasCoinFromEffects(effects).ref;\n  __privateGet(this, _sourceCoins).set(gasObject.objectId, gasObject);\n  await __privateGet(this, _client).waitForTransaction({\n    digest: result.digest\n  });\n};\nfunction promiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\nexport { ParallelTransactionExecutor };","map":{"version":3,"names":["_signer","_client","_coinBatchSize","_initialCoinBalance","_minimumCoinBalance","_epochBoundaryWindow","_defaultGasBudget","_maxPoolSize","_sourceCoins","_coinPool","_cache","_objectIdQueues","_buildQueue","_executeQueue","_lastDigest","_cacheLock","_pendingTransactions","_gasPrice","_ParallelTransactionExecutor_instances","getUsedObjects_fn","execute_fn","updateCache_fn","waitForLastDigest_fn","getGasCoin_fn","getGasPrice_fn","refillCoinPool_fn","toBase64","bcs","Transaction","TransactionDataBuilder","CachingTransactionExecutor","ParallelQueue","SerialQueue","getGasCoinFromEffects","PARALLEL_EXECUTOR_DEFAULTS","coinBatchSize","initialCoinBalance","minimumCoinBalance","maxPoolSize","epochBoundaryWindow","ParallelTransactionExecutor","constructor","options","__privateAdd","Map","__privateSet","signer","client","defaultGasBudget","__privateGet","cache","sourceCoins","map","id","resetCache","__privateMethod","call","reset","waitForLastTransaction","executeTransaction","transaction","promise","resolve","reject","promiseWithResolvers","usedObjects","execute","runTask","promise2","then","conflicts","Set","forEach","objectId","queue","get","add","push","delete","size","set","WeakMap","WeakSet","serialized","addSerializationPlugin","blockData","_options","next","inputs","input","Object","ImmOrOwnedObject","Receiving","UnresolvedObject","initialSharedVersion","prepareForSerialization","gasCoin","setSenderIfNotSet","toSuiAddress","data","getData","gasData","price","setGasPrice","setGasBudgetIfNotSet","__privateWrapper","_","setGasPayment","version","digest","buildTransaction","onlyTransactionKind","bytes","build","signature","signTransaction","results","showEffects","effectsBytes","Uint8Array","from","rawEffects","effects","TransactionEffects","parse","gasResult","gasUsed","V2","owner","totalUsed","BigInt","computationCost","storageCost","storageRebate","usesGasCoin","mapArguments","arg","$kind","balance","ref","error","Promise","all","deleteObjects","length","shift","fn","waitForTransaction","Error","coin","remaining","expiration","Date","now","timeToNextEpoch","Math","max","setTimeout","state","getLatestSuiSystemState","referenceGasPrice","Number","parseInt","epochStartTimestampMs","epochDurationMs","batchSize","min","txb","address","setSender","refs","ids","coins","multiGetObjects","filter","amounts","Array","fill","splitCoins","gas","coinResults","i","transferObjects","result","signAndExecuteTransaction","showRawEffects","changedObjects","outputState","gasObjectIndex","ObjectWrite","lamportVersion","gasObject","_resolve","_reject"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\transactions\\executor\\parallel.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { SuiObjectRef } from '../../bcs/types.js';\nimport type {\n\tSuiClient,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseOptions,\n} from '../../client/index.js';\nimport type { Signer } from '../../cryptography/index.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { Transaction } from '../Transaction.js';\nimport { TransactionDataBuilder } from '../TransactionData.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { ParallelQueue, SerialQueue } from './queue.js';\nimport { getGasCoinFromEffects } from './serial.js';\n\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n\tcoinBatchSize: 20,\n\tinitialCoinBalance: 200_000_000n,\n\tminimumCoinBalance: 50_000_000n,\n\tmaxPoolSize: 50,\n\tepochBoundaryWindow: 1_000,\n} satisfies Omit<ParallelTransactionExecutorOptions, 'signer' | 'client'>;\nexport interface ParallelTransactionExecutorOptions extends Omit<ObjectCacheOptions, 'address'> {\n\tclient: SuiClient;\n\tsigner: Signer;\n\t/** The number of coins to create in a batch when refilling the gas pool */\n\tcoinBatchSize?: number;\n\t/** The initial balance of each coin created for the gas pool */\n\tinitialCoinBalance?: bigint;\n\t/** The minimum balance of a coin that can be reused for future transactions.  If the gasCoin is below this value, it will be used when refilling the gasPool */\n\tminimumCoinBalance?: bigint;\n\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `minimumCoinBalance` */\n\tdefaultGasBudget?: bigint;\n\t/**\n\t * Time to wait before/after the expected epoch boundary before re-fetching the gas pool (in milliseconds).\n\t * Building transactions will be paused for up to 2x this duration around each epoch boundary to ensure the\n\t * gas price is up-to-date for the next epoch.\n\t * */\n\tepochBoundaryWindow?: number;\n\t/** The maximum number of transactions that can be execute in parallel, this also determines the maximum number of gas coins that will be created */\n\tmaxPoolSize?: number;\n\t/** An initial list of coins used to fund the gas pool, uses all owned SUI coins by default */\n\tsourceCoins?: string[];\n}\n\ninterface CoinWithBalance {\n\tid: string;\n\tversion: string;\n\tdigest: string;\n\tbalance: bigint;\n}\nexport class ParallelTransactionExecutor {\n\t#signer: Signer;\n\t#client: SuiClient;\n\t#coinBatchSize: number;\n\t#initialCoinBalance: bigint;\n\t#minimumCoinBalance: bigint;\n\t#epochBoundaryWindow: number;\n\t#defaultGasBudget: bigint;\n\t#maxPoolSize: number;\n\t#sourceCoins: Map<string, SuiObjectRef | null> | null;\n\t#coinPool: CoinWithBalance[] = [];\n\t#cache: CachingTransactionExecutor;\n\t#objectIdQueues = new Map<string, (() => void)[]>();\n\t#buildQueue = new SerialQueue();\n\t#executeQueue: ParallelQueue;\n\t#lastDigest: string | null = null;\n\t#cacheLock: Promise<void> | null = null;\n\t#pendingTransactions = 0;\n\t#gasPrice: null | {\n\t\tprice: bigint;\n\t\texpiration: number;\n\t} = null;\n\n\tconstructor(options: ParallelTransactionExecutorOptions) {\n\t\tthis.#signer = options.signer;\n\t\tthis.#client = options.client;\n\t\tthis.#coinBatchSize = options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize;\n\t\tthis.#initialCoinBalance =\n\t\t\toptions.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance;\n\t\tthis.#minimumCoinBalance =\n\t\t\toptions.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance;\n\t\tthis.#defaultGasBudget = options.defaultGasBudget ?? this.#minimumCoinBalance;\n\t\tthis.#epochBoundaryWindow =\n\t\t\toptions.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow;\n\t\tthis.#maxPoolSize = options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t});\n\t\tthis.#executeQueue = new ParallelQueue(this.#maxPoolSize);\n\t\tthis.#sourceCoins = options.sourceCoins\n\t\t\t? new Map(options.sourceCoins.map((id) => [id, null]))\n\t\t\t: null;\n\t}\n\n\tresetCache() {\n\t\tthis.#gasPrice = null;\n\t\treturn this.#updateCache(() => this.#cache.reset());\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tawait this.#updateCache(() => this.#waitForLastDigest());\n\t}\n\n\tasync executeTransaction(transaction: Transaction, options?: SuiTransactionBlockResponseOptions) {\n\t\tconst { promise, resolve, reject } = promiseWithResolvers<{\n\t\t\tdigest: string;\n\t\t\teffects: string;\n\t\t\tdata: SuiTransactionBlockResponse;\n\t\t}>();\n\t\tconst usedObjects = await this.#getUsedObjects(transaction);\n\n\t\tconst execute = () => {\n\t\t\tthis.#executeQueue.runTask(() => {\n\t\t\t\tconst promise = this.#execute(transaction, usedObjects, options);\n\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t});\n\t\t};\n\n\t\tconst conflicts = new Set<string>();\n\n\t\tusedObjects.forEach((objectId) => {\n\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\tif (queue) {\n\t\t\t\tconflicts.add(objectId);\n\t\t\t\tthis.#objectIdQueues.get(objectId)!.push(() => {\n\t\t\t\t\tconflicts.delete(objectId);\n\t\t\t\t\tif (conflicts.size === 0) {\n\t\t\t\t\t\texecute();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.#objectIdQueues.set(objectId, []);\n\t\t\t}\n\t\t});\n\n\t\tif (conflicts.size === 0) {\n\t\t\texecute();\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tasync #getUsedObjects(transaction: Transaction) {\n\t\tconst usedObjects = new Set<string>();\n\t\tlet serialized = false;\n\n\t\ttransaction.addSerializationPlugin(async (blockData, _options, next) => {\n\t\t\tawait next();\n\n\t\t\tif (serialized) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tserialized = true;\n\n\t\t\tblockData.inputs.forEach((input) => {\n\t\t\t\tif (input.Object?.ImmOrOwnedObject?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t\t\t} else if (input.Object?.Receiving?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.Receiving.objectId);\n\t\t\t\t} else if (\n\t\t\t\t\tinput.UnresolvedObject?.objectId &&\n\t\t\t\t\t!input.UnresolvedObject.initialSharedVersion\n\t\t\t\t) {\n\t\t\t\t\tusedObjects.add(input.UnresolvedObject.objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tawait transaction.prepareForSerialization({ client: this.#client });\n\n\t\treturn usedObjects;\n\t}\n\n\tasync #execute(\n\t\ttransaction: Transaction,\n\t\tusedObjects: Set<string>,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t) {\n\t\tlet gasCoin!: CoinWithBalance;\n\t\ttry {\n\t\t\ttransaction.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\t\tawait this.#buildQueue.runTask(async () => {\n\t\t\t\tconst data = transaction.getData();\n\n\t\t\t\tif (!data.gasData.price) {\n\t\t\t\t\ttransaction.setGasPrice(await this.#getGasPrice());\n\t\t\t\t}\n\n\t\t\t\ttransaction.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\n\t\t\t\tawait this.#updateCache();\n\t\t\t\tgasCoin = await this.#getGasCoin();\n\t\t\t\tthis.#pendingTransactions++;\n\t\t\t\ttransaction.setGasPayment([\n\t\t\t\t\t{\n\t\t\t\t\t\tobjectId: gasCoin.id,\n\t\t\t\t\t\tversion: gasCoin.version,\n\t\t\t\t\t\tdigest: gasCoin.digest,\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\t// Resolve cached references\n\t\t\t\tawait this.#cache.buildTransaction({ transaction, onlyTransactionKind: true });\n\t\t\t});\n\n\t\t\tconst bytes = await transaction.build({ client: this.#client });\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\n\t\t\tconst results = await this.#cache.executeTransaction({\n\t\t\t\ttransaction: bytes,\n\t\t\t\tsignature,\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tshowEffects: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\tconst effects = bcs.TransactionEffects.parse(effectsBytes);\n\n\t\t\tconst gasResult = getGasCoinFromEffects(effects);\n\t\t\tconst gasUsed = effects.V2?.gasUsed;\n\n\t\t\tif (gasCoin && gasUsed && gasResult.owner === this.#signer.toSuiAddress()) {\n\t\t\t\tconst totalUsed =\n\t\t\t\t\tBigInt(gasUsed.computationCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) -\n\t\t\t\t\tBigInt(gasUsed.storageRebate);\n\n\t\t\t\tlet usesGasCoin = false;\n\t\t\t\tnew TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n\t\t\t\t\tif (arg.$kind === 'GasCoin') {\n\t\t\t\t\t\tusesGasCoin = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arg;\n\t\t\t\t});\n\n\t\t\t\tif (!usesGasCoin && gasCoin.balance >= this.#minimumCoinBalance) {\n\t\t\t\t\tthis.#coinPool.push({\n\t\t\t\t\t\tid: gasResult.ref.objectId,\n\t\t\t\t\t\tversion: gasResult.ref.version,\n\t\t\t\t\t\tdigest: gasResult.ref.digest,\n\t\t\t\t\t\tbalance: gasCoin.balance - totalUsed,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t\t}\n\t\t\t\t\tthis.#sourceCoins.set(gasResult.ref.objectId, gasResult.ref);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.#lastDigest = results.digest;\n\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (gasCoin) {\n\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t}\n\n\t\t\t\tthis.#sourceCoins.set(gasCoin.id, null);\n\t\t\t}\n\n\t\t\tawait this.#updateCache(async () => {\n\t\t\t\tawait Promise.all([\n\t\t\t\t\tthis.#cache.cache.deleteObjects([...usedObjects]),\n\t\t\t\t\tthis.#waitForLastDigest(),\n\t\t\t\t]);\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tusedObjects.forEach((objectId) => {\n\t\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\t\tif (queue && queue.length > 0) {\n\t\t\t\t\tqueue.shift()!();\n\t\t\t\t} else if (queue) {\n\t\t\t\t\tthis.#objectIdQueues.delete(objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.#pendingTransactions--;\n\t\t}\n\t}\n\n\t/** Helper for synchronizing cache updates, by ensuring only one update happens at a time.  This can also be used to wait for any pending cache updates  */\n\tasync #updateCache(fn?: () => Promise<void>) {\n\t\tif (this.#cacheLock) {\n\t\t\tawait this.#cacheLock;\n\t\t}\n\n\t\tthis.#cacheLock =\n\t\t\tfn?.().then(\n\t\t\t\t() => {\n\t\t\t\t\tthis.#cacheLock = null;\n\t\t\t\t},\n\t\t\t\t() => {},\n\t\t\t) ?? null;\n\t}\n\n\tasync #waitForLastDigest() {\n\t\tconst digest = this.#lastDigest;\n\t\tif (digest) {\n\t\t\tthis.#lastDigest = null;\n\t\t\tawait this.#client.waitForTransaction({ digest });\n\t\t}\n\t}\n\n\tasync #getGasCoin() {\n\t\tif (this.#coinPool.length === 0 && this.#pendingTransactions <= this.#maxPoolSize) {\n\t\t\tawait this.#refillCoinPool();\n\t\t}\n\n\t\tif (this.#coinPool.length === 0) {\n\t\t\tthrow new Error('No coins available');\n\t\t}\n\n\t\tconst coin = this.#coinPool.shift()!;\n\t\treturn coin;\n\t}\n\n\tasync #getGasPrice(): Promise<bigint> {\n\t\tconst remaining = this.#gasPrice\n\t\t\t? this.#gasPrice.expiration - this.#epochBoundaryWindow - Date.now()\n\t\t\t: 0;\n\n\t\tif (remaining > 0) {\n\t\t\treturn this.#gasPrice!.price;\n\t\t}\n\n\t\tif (this.#gasPrice) {\n\t\t\tconst timeToNextEpoch = Math.max(\n\t\t\t\tthis.#gasPrice.expiration + this.#epochBoundaryWindow - Date.now(),\n\t\t\t\t1_000,\n\t\t\t);\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n\t\t}\n\n\t\tconst state = await this.#client.getLatestSuiSystemState();\n\n\t\tthis.#gasPrice = {\n\t\t\tprice: BigInt(state.referenceGasPrice),\n\t\t\texpiration:\n\t\t\t\tNumber.parseInt(state.epochStartTimestampMs, 10) +\n\t\t\t\tNumber.parseInt(state.epochDurationMs, 10),\n\t\t};\n\n\t\treturn this.#getGasPrice();\n\t}\n\n\tasync #refillCoinPool() {\n\t\tconst batchSize = Math.min(\n\t\t\tthis.#coinBatchSize,\n\t\t\tthis.#maxPoolSize - (this.#coinPool.length + this.#pendingTransactions) + 1,\n\t\t);\n\n\t\tif (batchSize === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst txb = new Transaction();\n\t\tconst address = this.#signer.toSuiAddress();\n\t\ttxb.setSender(address);\n\n\t\tif (this.#sourceCoins) {\n\t\t\tconst refs = [];\n\t\t\tconst ids = [];\n\t\t\tfor (const [id, ref] of this.#sourceCoins) {\n\t\t\t\tif (ref) {\n\t\t\t\t\trefs.push(ref);\n\t\t\t\t} else {\n\t\t\t\t\tids.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ids.length > 0) {\n\t\t\t\tconst coins = await this.#client.multiGetObjects({\n\t\t\t\t\tids,\n\t\t\t\t});\n\t\t\t\trefs.push(\n\t\t\t\t\t...coins\n\t\t\t\t\t\t.filter((coin): coin is typeof coin & { data: object } => coin.data !== null)\n\t\t\t\t\t\t.map(({ data }) => ({\n\t\t\t\t\t\t\tobjectId: data.objectId,\n\t\t\t\t\t\t\tversion: data.version,\n\t\t\t\t\t\t\tdigest: data.digest,\n\t\t\t\t\t\t})),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttxb.setGasPayment(refs);\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst amounts = new Array(batchSize).fill(this.#initialCoinBalance);\n\t\tconst results = txb.splitCoins(txb.gas, amounts);\n\t\tconst coinResults = [];\n\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\tcoinResults.push(results[i]);\n\t\t}\n\t\ttxb.transferObjects(coinResults, address);\n\n\t\tawait this.waitForLastTransaction();\n\n\t\tconst result = await this.#client.signAndExecuteTransaction({\n\t\t\ttransaction: txb,\n\t\t\tsigner: this.#signer,\n\t\t\toptions: {\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects!));\n\t\teffects.V2?.changedObjects.forEach(([id, { outputState }], i) => {\n\t\t\tif (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.#coinPool.push({\n\t\t\t\tid,\n\t\t\t\tversion: effects.V2!.lamportVersion,\n\t\t\t\tdigest: outputState.ObjectWrite[0],\n\t\t\t\tbalance: BigInt(this.#initialCoinBalance),\n\t\t\t});\n\t\t});\n\n\t\tif (!this.#sourceCoins) {\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst gasObject = getGasCoinFromEffects(effects).ref;\n\t\tthis.#sourceCoins!.set(gasObject.objectId, gasObject);\n\n\t\tawait this.#client.waitForTransaction({ digest: result.digest });\n\t}\n}\n\nfunction promiseWithResolvers<T>() {\n\tlet resolve: (value: T) => void;\n\tlet reject: (reason: any) => void;\n\n\tconst promise = new Promise<T>((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}