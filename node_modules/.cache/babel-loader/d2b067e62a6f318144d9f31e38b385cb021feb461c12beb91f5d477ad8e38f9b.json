{"ast":null,"code":"import { BcsType, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, lazyBcsType, stringLikeBcsType, uIntBcsType } from \"./bcs-type.js\";\nimport { ulebEncode } from \"./uleb.js\";\nconst bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      name: \"u8\",\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      name: \"u16\",\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      name: \"u32\",\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      name: \"u64\",\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      name: \"u128\",\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      name: \"u256\",\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      name: \"bool\",\n      size: 1,\n      read: reader => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      name: \"uleb128\",\n      read: reader => reader.readULEB(),\n      serialize: value => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      name: `bytes[${size}]`,\n      size,\n      read: reader => reader.readBytes(size),\n      write: (value, writer) => {\n        const array = new Uint8Array(value);\n        for (let i = 0; i < size; i++) {\n          writer.write8(array[i] ?? 0);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length byte array\n   *\n   * @example\n   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n   */\n  byteVector(options) {\n    return new BcsType({\n      name: `bytesVector`,\n      read: reader => {\n        const length = reader.readULEB();\n        return reader.readBytes(length);\n      },\n      write: (value, writer) => {\n        const array = new Uint8Array(value);\n        writer.writeULEB(array.length);\n        for (let i = 0; i < array.length; i++) {\n          writer.write8(array[i] ?? 0);\n        }\n      },\n      ...options,\n      serializedSize: value => {\n        const length = \"length\" in value ? value.length : null;\n        return length == null ? null : ulebEncode(length).length + length;\n      },\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      name: \"string\",\n      toBytes: value => new TextEncoder().encode(value),\n      fromBytes: bytes => new TextDecoder().decode(bytes),\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray(size, type, options) {\n    return new BcsType({\n      name: `${type.name}[${size}]`,\n      read: reader => {\n        const result = new Array(size);\n        for (let i = 0; i < size; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option(type) {\n    return bcs.enum(`Option<${type.name}>`, {\n      None: null,\n      Some: type\n    }).transform({\n      input: value => {\n        if (value == null) {\n          return {\n            None: true\n          };\n        }\n        return {\n          Some: value\n        };\n      },\n      output: value => {\n        if (value.$kind === \"Some\") {\n          return value.Some;\n        }\n        return null;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector(type, options) {\n    return new BcsType({\n      name: `vector<${type.name}>`,\n      read: reader => {\n        const length = reader.readULEB();\n        const result = new Array(length);\n        for (let i = 0; i < length; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        writer.writeULEB(value.length);\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(types, options) {\n    return new BcsType({\n      name: `(${types.map(t => t.name).join(\", \")})`,\n      serializedSize: values => {\n        let total = 0;\n        for (let i = 0; i < types.length; i++) {\n          const size = types[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = [];\n        for (const type of types) {\n          result.push(type.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < types.length; i++) {\n          types[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== types.length) {\n          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    const canonicalOrder = Object.entries(fields);\n    return new BcsType({\n      name,\n      serializedSize: values => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: reader => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, values, options) {\n    const canonicalOrder = Object.entries(values);\n    return new BcsType({\n      name,\n      read: reader => {\n        const index = reader.readULEB();\n        const enumEntry = canonicalOrder[index];\n        if (!enumEntry) {\n          throw new TypeError(`Unknown value ${index} for enum ${name}`);\n        }\n        const [kind, type] = enumEntry;\n        return {\n          [kind]: type?.read(reader) ?? true,\n          $kind: kind\n        };\n      },\n      write: (value, writer) => {\n        const [name2, val] = Object.entries(value).filter(([name3]) => Object.hasOwn(values, name3))[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name2) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value).filter(k => value[k] !== void 0 && Object.hasOwn(values, k));\n        if (keys.length !== 1) {\n          throw new TypeError(`Expected object with one key, but found ${keys.length} for type ${name}}`);\n        }\n        const [variant] = keys;\n        if (!Object.hasOwn(values, variant)) {\n          throw new TypeError(`Invalid enum variant ${variant}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map(keyType, valueType) {\n    return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n      name: `Map<${keyType.name}, ${valueType.name}>`,\n      input: value => {\n        return [...value.entries()];\n      },\n      output: value => {\n        const result = /* @__PURE__ */new Map();\n        for (const [key, val] of value) {\n          result.set(key, val);\n        }\n        return result;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\nexport { bcs };","map":{"version":3,"names":["BcsType","bigUIntBcsType","dynamicSizeBcsType","fixedSizeBcsType","lazyBcsType","stringLikeBcsType","uIntBcsType","ulebEncode","bcs","u8","options","name","readMethod","writeMethod","size","maxValue","u16","u32","u64","u128","u256","bool","read","reader","read8","write","value","writer","write8","validate","TypeError","uleb128","readULEB","serialize","Uint8Array","from","bytes","readBytes","array","i","length","byteVector","writeULEB","serializedSize","string","toBytes","TextEncoder","encode","fromBytes","TextDecoder","decode","fixedArray","type","result","Array","item","option","enum","None","Some","transform","input","output","$kind","vector","tuple","types","map","t","join","values","total","push","isArray","struct","fields","canonicalOrder","Object","entries","field","index","enumEntry","kind","name2","val","filter","name3","hasOwn","optionName","optionType","keys","k","variant","keyType","valueType","Map","key","set","lazy","cb"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\bcs\\src\\bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytesVector`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}