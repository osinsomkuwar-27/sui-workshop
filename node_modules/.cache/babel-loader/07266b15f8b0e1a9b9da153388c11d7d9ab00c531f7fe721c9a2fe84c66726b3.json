{"ast":null,"code":"import { fromHex } from \"@mysten/bcs\";\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nconst ED25519_CURVE = \"ed25519 seed\";\nconst HARDENED_OFFSET = 2147483648;\nconst pathRegex = new RegExp(\"^m(\\\\/[0-9]+')+$\");\nconst replaceDerive = val => val.replace(\"'\", \"\");\nconst getMasterKeyFromSeed = seed => {\n  const h = hmac.create(sha512, ED25519_CURVE);\n  const I = h.update(fromHex(seed)).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nconst CKDPriv = ({\n  key,\n  chainCode\n}, index) => {\n  const indexBuffer = new ArrayBuffer(4);\n  const cv = new DataView(indexBuffer);\n  cv.setUint32(0, index);\n  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);\n  data.set(new Uint8Array(1).fill(0));\n  data.set(key, 1);\n  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);\n  const I = hmac.create(sha512, chainCode).update(data).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nconst isValidPath = path => {\n  if (!pathRegex.test(path)) {\n    return false;\n  }\n  return !path.split(\"/\").slice(1).map(replaceDerive).some(isNaN\n  /* ts T_T*/);\n};\nconst derivePath = (path, seed, offset = HARDENED_OFFSET) => {\n  if (!isValidPath(path)) {\n    throw new Error(\"Invalid derivation path\");\n  }\n  const {\n    key,\n    chainCode\n  } = getMasterKeyFromSeed(seed);\n  const segments = path.split(\"/\").slice(1).map(replaceDerive).map(el => parseInt(el, 10));\n  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n    key,\n    chainCode\n  });\n};\nexport { derivePath };","map":{"version":3,"names":["fromHex","hmac","sha512","ED25519_CURVE","HARDENED_OFFSET","pathRegex","RegExp","replaceDerive","val","replace","getMasterKeyFromSeed","seed","h","create","I","update","digest","IL","slice","IR","key","chainCode","CKDPriv","index","indexBuffer","ArrayBuffer","cv","DataView","setUint32","data","Uint8Array","length","byteLength","set","fill","isValidPath","path","test","split","map","some","isNaN","derivePath","offset","Error","segments","el","parseInt","reduce","parentKeys","segment"],"sources":["C:\\Users\\hp\\OneDrive\\Desktop\\r\\sui-workshop\\node_modules\\@mysten\\sui\\src\\keypairs\\ed25519\\ed25519-hd-key.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This is adapted from https://github.com/alepop/ed25519-hd-key replacing create-hmac\n// with @noble/hashes to be browser compatible.\n\nimport { fromHex } from '@mysten/bcs';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\ntype Hex = string;\ntype Path = string;\n\ntype Keys = {\n\tkey: Uint8Array;\n\tchainCode: Uint8Array;\n};\n\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\n\nconst pathRegex = new RegExp(\"^m(\\\\/[0-9]+')+$\");\n\nconst replaceDerive = (val: string): string => val.replace(\"'\", '');\n\nconst getMasterKeyFromSeed = (seed: Hex): Keys => {\n\tconst h = hmac.create(sha512, ED25519_CURVE);\n\tconst I = h.update(fromHex(seed)).digest();\n\tconst IL = I.slice(0, 32);\n\tconst IR = I.slice(32);\n\treturn {\n\t\tkey: IL,\n\t\tchainCode: IR,\n\t};\n};\n\nconst CKDPriv = ({ key, chainCode }: Keys, index: number): Keys => {\n\tconst indexBuffer = new ArrayBuffer(4);\n\tconst cv = new DataView(indexBuffer);\n\tcv.setUint32(0, index);\n\n\tconst data = new Uint8Array(1 + key.length + indexBuffer.byteLength);\n\tdata.set(new Uint8Array(1).fill(0));\n\tdata.set(key, 1);\n\tdata.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);\n\n\tconst I = hmac.create(sha512, chainCode).update(data).digest();\n\tconst IL = I.slice(0, 32);\n\tconst IR = I.slice(32);\n\treturn {\n\t\tkey: IL,\n\t\tchainCode: IR,\n\t};\n};\n\nconst isValidPath = (path: string): boolean => {\n\tif (!pathRegex.test(path)) {\n\t\treturn false;\n\t}\n\treturn !path\n\t\t.split('/')\n\t\t.slice(1)\n\t\t.map(replaceDerive)\n\t\t.some(isNaN as any /* ts T_T*/);\n};\n\nexport const derivePath = (path: Path, seed: Hex, offset = HARDENED_OFFSET): Keys => {\n\tif (!isValidPath(path)) {\n\t\tthrow new Error('Invalid derivation path');\n\t}\n\n\tconst { key, chainCode } = getMasterKeyFromSeed(seed);\n\tconst segments = path\n\t\t.split('/')\n\t\t.slice(1)\n\t\t.map(replaceDerive)\n\t\t.map((el) => parseInt(el, 10));\n\n\treturn segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n\t\tkey,\n\t\tchainCode,\n\t});\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}